<?xml version="1.0" encoding="utf-8"?>
<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Tool" referent="RBX0">
		<Properties>
			<bool name="CanBeDropped">true</bool>
			<bool name="Enabled">true</bool>
			<CoordinateFrame name="Grip">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
				<R00>1</R00>
				<R01>0</R01>
				<R02>0</R02>
				<R10>0</R10>
				<R11>1</R11>
				<R12>0</R12>
				<R20>0</R20>
				<R21>0</R21>
				<R22>1</R22>
			</CoordinateFrame>
			<string name="Name">ClassicTool</string>
			<Content name="TextureId"><url>rbxasset://../../../shareddata/textures/59105322.png</url></Content>
			<string name="ToolTip"></string>
		</Properties>
		<Item class="LocalScript" referent="RBX1">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">ClassicToolController</string>
				<ProtectedString name="Source">local Tool = script.Parent

local keyUpCon = nil
local gui = nil

local connections = {}
local buttons = {}

local colorButton,SurfaceButton,MaterialButton,ResizeButton,draggerButton = nil

game:GetService("ContentProvider"):Preload("http://www.roblox.com/asset?id=59103051")
game:GetService("ContentProvider"):Preload("http://www.roblox.com/asset?id=59103080")
game:GetService("ContentProvider"):Preload("http://www.roblox.com/asset?id=59103092")
game:GetService("ContentProvider"):Preload("http://www.roblox.com/asset?id=59103119")
game:GetService("ContentProvider"):Preload("http://www.roblox.com/asset?id=59103152")

function makeImageButton(buttonName, image, position, parent, hotKeyString)
	local button = Instance.new("ImageButton")
	button.Name = buttonName
	button.Style = Enum.ButtonStyle.RobloxButton
	button.Size = UDim2.new(0,45,0,45)
	if position then button.Position = position end
	button.Parent = parent

	local buttonImage = Instance.new("ImageLabel")
	buttonImage.Name = "ButtonImage"
	buttonImage.BackgroundTransparency = 1
	buttonImage.Size = UDim2.new(1,12,1,12)
	buttonImage.Position = UDim2.new(0,-6,0,-6)
	buttonImage.Image = image
	buttonImage.Parent = button

	if hotKeyString then
		local textShortcut = Instance.new("TextLabel")
		textShortcut.Text = hotKeyString
		textShortcut.Name = "TextShortcut"
		textShortcut.Font = Enum.Font.ArialBold
		textShortcut.BackgroundTransparency = 1
		textShortcut.FontSize = Enum.FontSize.Size14
		textShortcut.TextColor3 = Color3.new(1,1,1)
		textShortcut.Size = UDim2.new(0,textShortcut.TextBounds.X,0,textShortcut.TextBounds.X)
		textShortcut.Parent = button
	end

	return button
end

function deactivateTool(script)
	local enable = script:FindFirstChild("Active")
	if enable and enable:IsA("BoolValue") then
		enable.Value = false
	end
end

function deactivateAllTools()
	local toolChildren = Tool:GetChildren()
	for i = 1, #toolChildren do
		if toolChildren[i]:IsA("BaseScript") and toolChildren[i] ~= script then
			deactivateTool(toolChildren[i])
		end
	end
	for i = 1, #buttons do
		buttons[i].Selected = false
	end
end

function goToTool(toolName, button)
	deactivateAllTools()
	button.Selected = true

	wait() -- give scripts a heartbeat to get set straight

	local toolScript = Tool:FindFirstChild(toolName)
	if toolScript and toolScript:IsA("BaseScript") then
		local enable = toolScript:FindFirstChild("Active")
		if enable and enable:IsA("BoolValue") then
			enable.Value = true
		end
	end
end

function makeClassicControlGui()
	clearAllConnections()

	local classicGui = Instance.new("ScreenGui")
	classicGui.Name = "ClassicGui"
	
	local classicFrame = Instance.new("Frame")
	classicFrame.Name = "ClassicFrame"
	classicFrame.BackgroundTransparency = 1
	classicFrame.Size = UDim2.new(0,246,0,45)
	classicFrame.Position = UDim2.new(0.5, -113, 1, -130)
	classicFrame.Parent = classicGui

	colorButton = makeImageButton("ColorButton","http://www.roblox.com/asset?id=59103051",UDim2.new(0,0,0.5,-23), classicFrame, "F")
	local colorCon = colorButton.MouseButton1Click:connect(function() goToTool("Color", colorButton) end)
	table.insert(connections,colorCon)
	table.insert(buttons,colorButton)

	SurfaceButton = makeImageButton("SurfaceButton","http://www.roblox.com/asset?id=59103080",UDim2.new(0,90,0.5,-23), classicFrame, "H")
	local surfaceCon = SurfaceButton.MouseButton1Click:connect(function() goToTool("Surface", SurfaceButton) end)
	table.insert(connections,surfaceCon)
	table.insert(buttons,SurfaceButton)

	MaterialButton = makeImageButton("MaterialButton","http://www.roblox.com/asset?id=59103092",UDim2.new(0,45,0.5,-23), classicFrame, "G")
	local materialCon = MaterialButton.MouseButton1Click:connect(function() goToTool("Material", MaterialButton) end)
	table.insert(connections,materialCon)
	table.insert(buttons,MaterialButton)

	ResizeButton = makeImageButton("ResizeButton","http://www.roblox.com/asset?id=59103119",UDim2.new(0,180,0.5,-23), classicFrame, "K")
	local resizeCon = ResizeButton.MouseButton1Click:connect(function() goToTool("Resize", ResizeButton) end)
	table.insert(connections,resizeCon)
	table.insert(buttons,ResizeButton)

	draggerButton = makeImageButton("ResizeButton","http://www.roblox.com/asset?id=59103152",UDim2.new(0,135,0.5,-23), classicFrame, "J")
	local draggerCon = draggerButton.MouseButton1Click:connect(function() goToTool("Dragger", draggerButton) end)
	table.insert(connections,draggerCon)
	table.insert(buttons,draggerButton)

	return classicGui
end

function clearAllConnections()
	for i = 1, #connections do
		connections[i]:disconnect()
	end
	connections = {}
end


function hotKey(key)
	key = key:lower()

	if key == "f" then
		goToTool("Color", colorButton)
	elseif key == "g" then
		goToTool("Material", MaterialButton)
	elseif key == "h" then
		goToTool("Surface", SurfaceButton)
	elseif key == "j" then
		goToTool("Dragger", draggerButton)
	elseif key == "k" then
		goToTool("Resize", ResizeButton)
	end
end


function onEquippedLocal(mouse)
	Tool.Mouse.Value = mouse
	if not gui then
		gui = makeClassicControlGui()
	end
	gui.Parent = game.Players.LocalPlayer.PlayerGui

	keyUpCon = mouse.KeyUp:connect(function(key) hotKey(key) end)
end

function onUnequippedLocal()
	if keyUpCon then keyUpCon:disconnect() end
	deactivateAllTools()
	gui.Parent = nil	
end

Tool.Equipped:connect(onEquippedLocal)
Tool.Unequipped:connect(onUnequippedLocal)
</ProtectedString>
			</Properties>
		</Item>
		<Item class="Part" referent="RBX2">
			<Properties>
				<bool name="Anchored">false</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">0</token>
				<token name="BottomSurfaceInput">0</token>
				<int name="BrickColor">199</int>
				<CoordinateFrame name="CFrame">
					<X>-259.053711</X>
					<Y>24.1241074</Y>
					<Z>24.773859</Z>
					<R00>-0.809955359</R00>
					<R01>-0.578492582</R01>
					<R02>-0.0965344012</R02>
					<R10>-0.0977992862</R10>
					<R11>0.29551208</R11>
					<R12>-0.950320005</R12>
					<R20>0.578280091</R20>
					<R21>-0.760275602</R21>
					<R22>-0.295927882</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<float name="Elasticity">0.5</float>
				<float name="Friction">0.300000012</float>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">true</bool>
				<token name="Material">256</token>
				<string name="Name">Handle</string>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<Vector3 name="RotVelocity">
					<X>-39.0690536</X>
					<Y>-45.7426643</Y>
					<Z>-3.96868753</Z>
				</Vector3>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">0</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>1.56936264</X>
					<Y>20.0873489</Y>
					<Z>-31.4765129</Z>
				</Vector3>
				<token name="formFactorRaw">2</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>1</X>
					<Y>0.800000012</Y>
					<Z>2</Z>
				</Vector3>
			</Properties>
			<Item class="SpecialMesh" referent="RBX3">
				<Properties>
					<token name="LODX">2</token>
					<token name="LODY">2</token>
					<Content name="MeshId"><url>rbxasset://../../../shareddata/fonts/15952510.mesh</url></Content>
					<token name="MeshType">5</token>
					<string name="Name">Mesh</string>
					<Vector3 name="Offset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<Vector3 name="Scale">
						<X>0.400000006</X>
						<Y>0.400000006</Y>
						<Z>0.400000006</Z>
					</Vector3>
					<Content name="TextureId"><url>rbxasset://../../../shareddata/textures/15952494.png</url></Content>
					<Vector3 name="VertexColor">
						<X>1</X>
						<Y>1</Y>
						<Z>1</Z>
					</Vector3>
				</Properties>
			</Item>
			<Item class="Sound" referent="RBX4">
				<Properties>
					<bool name="Looped">false</bool>
					<string name="Name">Sound</string>
					<float name="Pitch">1</float>
					<bool name="PlayOnRemove">false</bool>
					<Content name="SoundId"><url>rbxasset://sounds/swordslash.wav</url></Content>
					<float name="Volume">1</float>
				</Properties>
			</Item>
			<Item class="Sound" referent="RBX5">
				<Properties>
					<bool name="Looped">false</bool>
					<string name="Name">Sound</string>
					<float name="Pitch">1</float>
					<bool name="PlayOnRemove">false</bool>
					<Content name="SoundId"><url>rbxasset://sounds/unsheath.wav</url></Content>
					<float name="Volume">1</float>
				</Properties>
			</Item>
			<Item class="Sound" referent="RBX6">
				<Properties>
					<bool name="Looped">false</bool>
					<string name="Name">Sound</string>
					<float name="Pitch">1</float>
					<bool name="PlayOnRemove">false</bool>
					<Content name="SoundId"><url>rbxasset://sounds/swordslash.wav</url></Content>
					<float name="Volume">1</float>
				</Properties>
			</Item>
			<Item class="Sound" referent="RBX7">
				<Properties>
					<bool name="Looped">false</bool>
					<string name="Name">Sound</string>
					<float name="Pitch">1</float>
					<bool name="PlayOnRemove">false</bool>
					<Content name="SoundId"><url>rbxasset://sounds/unsheath.wav</url></Content>
					<float name="Volume">1</float>
				</Properties>
			</Item>
		</Item>
		<Item class="LocalScript" referent="RBX8">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Color</string>
				<ProtectedString name="Source">-- basic functions
function waitForChild(instance, name)
	while not instance:findFirstChild(name) do
		instance.ChildAdded:wait()
	end
end

local Tool = script.Parent

enabled = true
local menu
local origTexture = 	Tool.TextureId
local localAssetBase = "rbxasset://textures/ui/"
local currentColorButton = nil
game:GetService("ContentProvider"):Preload("rbxasset://icons/color_sel.png")

local buttonDownCon, mouseMoveCon
local clickCons = {}

function onButton1Down(mouse)
	if not enabled then
		return
	end

	enabled = false
	mouse.Icon = "rbxasset://textures\\GunWaitCursor.png"

	wait(.5)
	mouse.Icon = "rbxasset://textures\\GunCursor.png"
	enabled = true

end


local selectionBox
local selectionLasso


function setSelectionBox(part) 
	unsetSelectionBox()
	selectionBox.Adornee = part
	selectionLasso.Part = part
end
function unsetSelectionBox() 
	selectionBox.Adornee = nil
	selectionLasso.Part = nil
end

function canSelectObject(part)
	return part and not (part.Locked) and (part.Position - Tool.Parent.Head.Position).Magnitude &lt; 60
end

function on3dButton1Down(mouse) 
	local part = mouse.Target
	if canSelectObject(part) then
		if Instance.Lock(part) then
			color =  Tool.Color.CurrentColor.Value
			if color == nil then
				Instance.Unlock(part)
				return
			end
			part.BrickColor = color
			Instance.Unlock(part)
		end
	end
end

function on3dMouseMove(mouse) 
	mouse.Icon ="rbxasset://textures\\FillCursor.png"
	local part = mouse.Target
	if canSelectObject(part) then
		setSelectionBox(part)
	else
		unsetSelectionBox()
	end
end

function makeColorMenu()
	local paintGui = Instance.new("ScreenGui")
	paintGui.Name = "PaintGui"

	local paintMenu = Instance.new("ImageLabel")
	paintMenu.Name = "PaintMenu"
	paintMenu.Position = UDim2.new(0,0,1,-600)
	paintMenu.Size = UDim2.new(0,120,0,500)
	paintMenu.BackgroundTransparency = 1
	paintMenu.ZIndex = 2
	paintMenu.Image = localAssetBase .. "PaintMenu.png"
	paintMenu.Parent = paintGui

	local paintColorButton = Instance.new("ImageButton")
	paintColorButton.BorderSizePixel = 0
	paintColorButton.ZIndex = 3
	paintColorButton.Size = UDim2.new(0.200000003, 0,0.0500000007, 0)

	local selection = Instance.new("Frame")
	selection.Name = "Selection"
	selection.BorderSizePixel = 0
	selection.BackgroundColor3 = Color3.new(1,1,1)
	selection.BackgroundTransparency = 1
	selection.ZIndex = 2
	selection.Size = UDim2.new(1.1,0,1.1,0)
	selection.Position = UDim2.new(-0.05,0,-0.05,0)
	selection.Parent = paintColorButton

	local header  = 0.08
	local spacing = 18

	local count = 1

	local function findNextColor()
		colorName = tostring(BrickColor.new(count))
		while colorName == "Medium stone grey" do
			count = count + 1
			colorName = tostring(BrickColor.new(count))
		end
		return count
	end

	for i = 0,15 do
		for j = 1, 4 do
			newButton = paintColorButton:clone()
			newButton.BackgroundColor3 = BrickColor.new(findNextColor()).Color
			newButton.Name = tostring(BrickColor.new(count))
			count = count + 1
			if j == 1 then newButton.Position = UDim2.new(0.08,0,i/spacing + header,0)
			elseif j == 2 then newButton.Position = UDim2.new(0.29,0,i/spacing + header,0)
			elseif j == 3 then newButton.Position = UDim2.new(0.5,0,i/spacing + header,0)
			elseif j == 4 then newButton.Position = UDim2.new(0.71,0,i/spacing + header,0) end
			newButton.Parent = paintMenu
		end
	end

	local paintButtons = paintMenu:GetChildren()
	for i = 1, #paintButtons do
		local newCon = paintButtons[i].MouseButton1Click:connect(function()
			Tool.Color.CurrentColor.Value = BrickColor.new(paintButtons[i].Name)

			if currentColorButton then
				if currentColorButton:FindFirstChild("Selection") then
					currentColorButton.Selection.BackgroundTransparency = 1
				end
			end

			currentColorButton = paintButtons[i]
			paintButtons[i].Selection.BackgroundTransparency = 0
		end)
		local anotherCon = paintButtons[i].MouseEnter:connect(function()
			paintButtons[i].Selection.BackgroundTransparency = 0
		end)
		local oneMoreCon = paintButtons[i].MouseLeave:connect(function()
			if paintButtons[i] ~= currentColorButton then paintButtons[i].Selection.BackgroundTransparency = 1 end
		end)

		table.insert(clickCons,newCon)
		table.insert(clickCons,anotherCon)
		table.insert(clickCons,oneMoreCon)
	end

	return paintGui
end

function onEquippedLocal(mouse)
	Tool.TextureId = "rbxasset://icons/color_sel.png"

	local character = script.Parent.Parent
	local player = game.Players:GetPlayerFromCharacter(character)

	buttonDownCon = mouse.Button1Down:connect(function() on3dButton1Down(mouse) end)
	mouseMoveCon  = mouse.Move:connect(function() on3dMouseMove(mouse) end)
	mouse.Icon ="rbxasset://textures\\FillCursor.png"

	selectionBox = Instance.new("SelectionBox")
	selectionBox.Color = Tool.Color.CurrentColor.Value
	selectionBox.Adornee = nil
	selectionBox.Parent = player.PlayerGui

	selectionLasso = Instance.new("SelectionPartLasso")
	selectionLasso.Name = "Model Delete Lasso"
	selectionLasso.Humanoid = character.Humanoid
	selectionLasso.Part = nil
	selectionLasso.Visible = true
	selectionLasso.archivable = false
	selectionLasso.Color = Tool.Color.CurrentColor.Value
	selectionLasso.Parent = game.workspace

	menu = makeColorMenu()
	menu.Parent = game.Players.LocalPlayer.PlayerGui
end

function onUnequippedLocal()
	if menu then menu:remove() end
	Tool.TextureId = origTexture

	for i = 1, #clickCons do
		clickCons[i]:disconnect()
	end
	clickCons = {}

	if selectionBox then selectionBox:Remove() end
	if selectionLasso then selectionLasso:Remove() end
	if mouseMoveCon then mouseMoveCon:disconnect() end
	if buttonDownCon then buttonDownCon:disconnect() end
end

waitForChild(Tool.Color,"CurrentColor")
waitForChild(Tool.Color,"Active")
Tool.Color.CurrentColor.Changed:connect(function()
	if selectionBox then selectionBox.Color = Tool.Color.CurrentColor.Value end
	if selectionLasso then selectionLasso.Color = Tool.Color.CurrentColor.Value end
end)

script.Active.Changed:connect(function(prop)
	if script.Active.Value == true then
		onEquippedLocal(Tool.Mouse.Value)
	else
		onUnequippedLocal()
	end
end)</ProtectedString>
			</Properties>
			<Item class="BoolValue" referent="RBX9">
				<Properties>
					<string name="Name">Active</string>
					<bool name="Value">false</bool>
				</Properties>
			</Item>
			<Item class="BrickColorValue" referent="RBX10">
				<Properties>
					<string name="Name">CurrentColor</string>
					<int name="Value">194</int>
				</Properties>
			</Item>
		</Item>
		<Item class="LocalScript" referent="RBX11">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Material</string>
				<ProtectedString name="Source">-- basic functions
function waitForChild(instance, name)
	while not instance:findFirstChild(name) do
		instance.ChildAdded:wait()
	end
end

local Tool = script.Parent
waitForChild(Tool.Material,"Active")
waitForChild(Tool.Material,"CurrentMaterial")

enabled = true
local origTexture = 	Tool.TextureId
local localAssetBase = "rbxasset://textures/ui/"
game:GetService("ContentProvider"):Preload("rbxasset://icons/material_sel.png")

local menu

local selectionBox
local selectionLasso

local selectedButton

local value = nil

local downCons = {}

local currentMaterialButton = nil

function setSelectionBox(part) 
	unsetSelectionBox()
	selectionBox.Adornee = part
	selectionLasso.Part = part
end
function unsetSelectionBox() 
	selectionBox.Adornee = nil
	selectionLasso.Part = nil
end

local MaterialEnum = {}
MaterialEnum["Plastic"] = Enum.Material.Plastic
MaterialEnum["Wood"] = Enum.Material.Wood
MaterialEnum["Slate"] = Enum.Material.Slate
MaterialEnum["CorrodedMetal"] = Enum.Material.CorrodedMetal
MaterialEnum["Ice"] = Enum.Material.Ice
MaterialEnum["Grass"] = Enum.Material.Grass
MaterialEnum["Foil"] = Enum.Material.Foil
MaterialEnum["DiamondPlate"] = Enum.Material.DiamondPlate
MaterialEnum["Concrete"] = Enum.Material.Concrete

function on3dButton1Down(mouse) 
	local part = mouse.Target
	if part and not (part.Locked) then
		if Instance.Lock(part) then
			part.Material = MaterialEnum[Tool.Material.CurrentMaterial.Value]
			Instance.Unlock(part)
		end
	end
end

function canSelectObject(part)
	return part and not (part.Locked) and (part.Position - Tool.Parent.Head.Position).Magnitude &lt; 60
end


function on3dMouseMove(mouse) 
	mouse.Icon ="rbxasset://textures\\MaterialCursor.png"
	local part = mouse.Target
	if canSelectObject(part) then
		setSelectionBox(part)
	else
		unsetSelectionBox()
	end
end

function createMaterialMenu()
	local materialGui = Instance.new("ScreenGui")
	materialGui.Name = "MaterialGui"

	local materialMenu = Instance.new("ImageLabel")
	materialMenu.Name = "MaterialMenu"
	materialMenu.Position = UDim2.new(0,0,1,-350)
	materialMenu.Size = UDim2.new(0,100,0,250)
	materialMenu.BackgroundTransparency = 1
	materialMenu.ZIndex = 2
	materialMenu.Image = localAssetBase .. "MaterialMenu.png"
	materialMenu.Parent = materialGui

	local textures = {"Plastic","Wood","Slate","CorrodedMetal","Ice","Grass","Foil","DiamondPlate","Concrete"}

	local materialButtons = {}

	local materialButton = Instance.new("ImageButton")
	materialButton.BackgroundTransparency = 1
	materialButton.Size = UDim2.new(0.400000003, 0,0.16, 0)
	materialButton.ZIndex = 4

	local selection = Instance.new("Frame")
	selection.Name = "Selection"
	selection.BorderSizePixel = 0
	selection.BackgroundColor3 = Color3.new(1,1,1)
	selection.BackgroundTransparency = 1
	selection.ZIndex = 3
	selection.Size = UDim2.new(1.1,0,1.1,0)
	selection.Position = UDim2.new(-0.05,0,-0.05,0)
	selection.Parent = materialButton

	local current = 1
	local function getTextureAndName(button)

		if current &gt; #textures then
			button:remove()
			return false
		end
		button.Image = localAssetBase .. textures[current] .. ".png"
		button.Name = textures[current]
		current = current + 1
		return true

	end

	local ySpacing = 0.10
	local xSpacing  = 0.07
	for i = 1,5 do
		for j = 1,2 do
			local button = materialButton:clone()
			button.Position = UDim2.new((j -1)/2.2 + xSpacing,0,ySpacing + (i - 1)/5.5,0)
			if getTextureAndName(button) then button.Parent = materialMenu else button:remove() end
			table.insert(materialButtons,button)
		end
	end


	for i = 1, #materialButtons do
		local newCon = materialButtons[i].MouseButton1Click:connect(function()
			Tool.Material.CurrentMaterial.Value = materialButtons[i].Name

			if currentMaterialButton then
				if currentMaterialButton:FindFirstChild("Selection") then
					currentMaterialButton.Selection.BackgroundTransparency = 1
				end
			end

			currentMaterialButton = materialButtons[i]
			materialButtons[i].Selection.BackgroundTransparency = 0
		end)
		local enterCon = materialButtons[i].MouseEnter:connect(function()
			materialButtons[i].Selection.BackgroundTransparency = 0
		end)
		local leaveCon = materialButtons[i].MouseLeave:connect(function()
			if materialButtons[i] ~= currentMaterialButton then materialButtons[i].Selection.BackgroundTransparency = 1 end
		end)
		table.insert(downCons, newCon)
		table.insert(downCons, enterCon)
		table.insert(downCons, leaveCon)
	end

	return materialGui
end

function onEquippedLocal(mouse)
	Tool.TextureId = "rbxasset://icons/material_sel.png"
	value = nil
	selectedButton = nil

	local character = script.Parent.Parent
	local player = game.Players:GetPlayerFromCharacter(character)

	selectedButton = nil

	button1DownCon = mouse.Button1Down:connect(function() on3dButton1Down(mouse) end)
	mouseMoveCon = mouse.Move:connect(function() on3dMouseMove(mouse) end)
	mouse.Icon ="rbxasset://textures\\MaterialCursor.png"

	selectionBox = Instance.new("SelectionBox")
	selectionBox.Color = BrickColor.Yellow()
	selectionBox.Adornee = nil
	selectionBox.Parent = player.PlayerGui

	selectionLasso = Instance.new("SelectionPartLasso")
	selectionLasso.Name = "Model Material Lasso"
	selectionLasso.Humanoid = character.Humanoid
	selectionLasso.Parent = game.workspace
	selectionLasso.Part = nil
	selectionLasso.Visible = true
	selectionLasso.archivable = false
	selectionLasso.Color = BrickColor.Green()

	menu = createMaterialMenu()
	menu.Parent = game.Players.LocalPlayer.PlayerGui
end

function onUnequippedLocal()
	if button1DownCon then button1DownCon:disconnect() end
	if mouseMoveCon then mouseMoveCon:disconnect() end

	for i = 1, #downCons do
		downCons[i]:disconnect()
	end
	downCons = {}

	menu:remove()
	Tool.TextureId = origTexture
	if selectionBox then selectionBox:Remove() end
	if selectionLasso then selectionLasso:Remove() end
end

script.Active.Changed:connect(function(prop)
	if script.Active.Value == true then
		onEquippedLocal(Tool.Mouse.Value)
	else
		onUnequippedLocal()
	end
end)
</ProtectedString>
			</Properties>
			<Item class="BoolValue" referent="RBX12">
				<Properties>
					<string name="Name">Active</string>
					<bool name="Value">false</bool>
				</Properties>
			</Item>
			<Item class="StringValue" referent="RBX13">
				<Properties>
					<string name="Name">CurrentMaterial</string>
					<string name="Value">Plastic</string>
				</Properties>
			</Item>
		</Item>
		<Item class="LocalScript" referent="RBX14">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Resize</string>
				<ProtectedString name="Source">-- basic functions
function waitForChild(instance, name)
	while not instance:findFirstChild(name) do
		instance.ChildAdded:wait()
	end
end

local Tool = script.Parent
waitForChild(Tool.Resize,"Active")

enabled = true
local origTexture = 	Tool.TextureId
game:GetService("ContentProvider"):Preload("rbxasset://icons/resize_sel.png")

local selectionBox
local selectionLasso
local handles

local previousDistance
local needsCursor = true

local currMouseTarget
local connections = {}

function onHandlesDown(normal)
	previousDistance = 0
end
function onHandlesDrag(normal, distance)
	
	if handles.Adornee then
		local delta = distance - previousDistance 
		if math.abs(delta) &gt;= handles.Adornee.ResizeIncrement then
			local sizeDelta = math.floor(delta / handles.Adornee.ResizeIncrement + 0.5) * handles.Adornee.ResizeIncrement
			if handles.Adornee:Resize(normal, sizeDelta) then
				previousDistance = distance
			end
		end
	end
end

function onButton1Down(mouse)
	local success = pcall(function() theMouse = mouse.Target end)

	if success then
		if canSelect(mouse.Target) then
			selectionBox.Adornee = mouse.Target
			selectionLasso.Part = mouse.Target
			handles.Adornee = mouse.Target
			handles.Faces = mouse.Target.ResizeableFaces
		else
			selectionBox.Adornee = nil
			selectionLasso.Part = nil
			handles.Adornee = nil
		end
	end
end

function mouseTargetChanged(mouse)

	if canSelect(mouse.Target) then
		if needsCursor then
			mouse.Icon ="rbxasset://textures\\DragCursor.png"
			needsCursor = false
		end
	else
		needsCursor = true
		mouse.Icon = ""
	end

end

local function isPartOfModel(object)
	if object and object ~= game.Workspace and object:IsA("Model") then
		return true
	elseif not object or object == game.Workspace then
		return false
	else
		return isPartOfModel(object.Parent)
	end
end

function canSelect(object)
	local isModel = isPartOfModel(object)
	return object and object:IsA("BasePart") and not object.Locked and not isPartOfModel(object)
end


function onEquippedLocal(mouse)

	currMouseTarget = nil

	table.insert(connections,mouse.Button1Down:connect(function() onButton1Down(mouse) end) )
	table.insert(connections, mouse.Move:connect(function()
			if currMouseTarget ~= mouse.Target then
				mouseTargetChanged(mouse)
				currMouseTarget = mouse.Target
			end
		end)
	)

	local character = script.Parent.Parent
	local player = game.Players:GetPlayerFromCharacter(character)
	
	selectionBox = Instance.new("SelectionBox")
	selectionBox.Color = BrickColor.Blue()
	selectionBox.Adornee = nil
	selectionBox.Parent = player.PlayerGui

	selectionLasso = Instance.new("SelectionPartLasso")
	selectionLasso.Name = "Model Delete Lasso"
	selectionLasso.Humanoid = character.Humanoid
	selectionLasso.Parent = game.workspace
	selectionLasso.Part = nil
	selectionLasso.Visible = true
	selectionLasso.archivable = false
	selectionLasso.Color = BrickColor.Red()

	handles = Instance.new("Handles")
	handles.Color = BrickColor.Blue()
	handles.Adornee = nil
	handles.MouseDrag:connect(onHandlesDrag)
	handles.MouseButton1Down:connect(onHandlesDown)
	handles.Parent = player.PlayerGui
end

function onUnequippedLocal()
	Tool.TextureId = origTexture
	selectionBox:Remove()
	selectionLasso:Remove()
	handles:Remove()

	for i = 1, #connections do
		if connections[i] then connections[i]:disconnect() end
	end

	connections = {}
end

script.Active.Changed:connect(function(prop)
	if script.Active.Value == true then
		onEquippedLocal(Tool.Mouse.Value)
	else
		onUnequippedLocal()
	end
end)
</ProtectedString>
			</Properties>
			<Item class="BoolValue" referent="RBX15">
				<Properties>
					<string name="Name">Active</string>
					<bool name="Value">false</bool>
				</Properties>
			</Item>
		</Item>
		<Item class="LocalScript" referent="RBX16">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Surface</string>
				<ProtectedString name="Source">-- basic functions
function waitForChild(instance, name)
	while not instance:findFirstChild(name) do
		instance.ChildAdded:wait()
	end
end

local Tool = script.Parent
local menu


waitForChild(Tool.Surface,"Active")
waitForChild(Tool.Surface,"CurrentSurface")

enabled = true
local origTexture = 	Tool.TextureId
local localAssetBase = "rbxasset://textures/ui/"
game:GetService("ContentProvider"):Preload("rbxasset://icons/surface_sel.png")

local selectionSurface
local selectionLasso

local currentSurfaceButton = nil

local mouseMoveCon, button1DownCon
local conArray = {}

function setSelectionSurface(part, surface) 
	unsetSelectionSurface()
	selectionSurface.Adornee = part
	selectionSurface.TargetSurface = surface
	selectionLasso.Part = part
end
function unsetSelectionSurface() 
	selectionSurface.Adornee = nil
	selectionLasso.Part = nil
end

local SurfaceEnum = {}
SurfaceEnum["Smooth"] = Enum.SurfaceType.Smooth
SurfaceEnum["Studs"] = Enum.SurfaceType.Studs
SurfaceEnum["Inlet"] = Enum.SurfaceType.Inlet
SurfaceEnum["Universal"] = Enum.SurfaceType.Universal
SurfaceEnum["Glue"] = Enum.SurfaceType.Glue
SurfaceEnum["Weld"] = Enum.SurfaceType.Weld
SurfaceEnum["Hinge"] = Enum.SurfaceType.Hinge
SurfaceEnum["Motor"] = Enum.SurfaceType.Motor


function canSelectObject(part, surface)
	return part and not (part.Locked) and part:IsA("BasePart") and (part.Position - Tool.Parent.Head.Position).Magnitude &lt; 60 and 
		(not(part:IsA("WedgePart")) or surface ~= Enum.NormalId.Front)
end


function on3dMouseMove(mouse)
	local part = mouse.Target
	local surface = mouse.TargetSurface
	if canSelectObject(part, surface) then
		setSelectionSurface(part, surface)
	else
		unsetSelectionSurface()
	end

end
function on3dButton1Down(mouse) 
	local part = selectionSurface.Adornee
	if part then
		local normalId = selectionSurface.TargetSurface
		local surface = Tool.Surface.CurrentSurface.Value
		if surface == nil then return end
		--Apply the selected surface to the current parts
		if normalId == Enum.NormalId.Top then
			part.TopSurface = surface
		elseif normalId == Enum.NormalId.Bottom then  
		elseif normalId == Enum.NormalId.Front then  
			part.BottomSurface = surface
			part.FrontSurface = surface
		elseif normalId == Enum.NormalId.Back then  
			part.BackSurface = surface
		elseif normalId == Enum.NormalId.Left then  
			part.LeftSurface = surface
		elseif normalId == Enum.NormalId.Right then  
			part.RightSurface = surface
		end
	end
end

function createSurfaceMenu()

	local surfaceGui = Instance.new("ScreenGui")
	surfaceGui.Name = "SurfaceGui"

	local surfaceMenu = Instance.new("ImageLabel")
	surfaceMenu.Name = "SurfaceMenu"
	surfaceMenu.Position = UDim2.new(0,0,1,-400)
	surfaceMenu.Size = UDim2.new(0,150,0,300)
	surfaceMenu.BackgroundTransparency = 1
	surfaceMenu.ZIndex = 2
	surfaceMenu.Image = localAssetBase .. "SurfaceMenu.png"
	surfaceMenu.Parent = surfaceGui

	textures = {"Smooth", "Studs", "Inlets", "Universal", "Glue", "Weld", "Hinge", "Motor"}
	current = 1

	local surfaceButtons = {}

	local surfaceButton = Instance.new("ImageButton")
	surfaceButton.BackgroundTransparency = 1
	surfaceButton.Size = UDim2.new(0.400000003, 0,0.19, 0)
	surfaceButton.ZIndex = 4
	
	local selection = Instance.new("Frame")
	selection.Name = "Selection"
	selection.BorderSizePixel = 0
	selection.BackgroundColor3 = Color3.new(1,1,1)
	selection.BackgroundTransparency = 1
	selection.ZIndex = 3
	selection.Size = UDim2.new(1.1,0,1.1,0)
	selection.Position = UDim2.new(-0.05,0,-0.05,0)
	selection.Parent = surfaceButton

	local function getTextureAndName(button)
		if current &gt; #textures then
			button:remove()
			return false
		end
		button.Image = localAssetBase .. textures[current] .. ".png"

		if textures[current] == "Inlets" then --nice hack to adjust for inconsistent namings
			button.Name = "Inlet"
		else
			button.Name = textures[current]
		end

		current = current + 1
		return true
	end

	local ySpacing = 0.14
	local xSpacing  = 0.07
	for i = 1,4 do
		for j = 1,2 do
			local button = surfaceButton:clone()
			button.Position = UDim2.new((j -1)/2.2 + xSpacing,0,ySpacing + (i - 1)/4.6,0)
			getTextureAndName(button)
			button.Parent = surfaceMenu
			table.insert(surfaceButtons,button)
		end
	end

	for i = 1, #surfaceButtons do
		local newCon = surfaceButtons[i].MouseButton1Click:connect(function()
			Tool.Surface.CurrentSurface.Value = surfaceButtons[i].Name

			if currentSurfaceButton then 
				if currentSurfaceButton:FindFirstChild("Selection") then
					currentSurfaceButton.Selection.BackgroundTransparency = 1
				end
			end

			currentSurfaceButton = surfaceButtons[i]
			surfaceButtons[i].Selection.BackgroundTransparency = 0
		end)
		local enterCon = surfaceButtons[i].MouseEnter:connect(function()
			surfaceButtons[i].Selection.BackgroundTransparency = 0
		end)
		local leaveCon = surfaceButtons[i].MouseLeave:connect(function()
			if surfaceButtons[i] ~= currentSurfaceButton then surfaceButtons[i].Selection.BackgroundTransparency = 1 end
		end)
		table.insert(conArray,newCon)
		table.insert(conArray,enterCon)
		table.insert(conArray,leaveCon)
	end

	return surfaceGui
end



function onEquippedLocal(mouse)
	Tool.TextureId = "rbxasset://icons/surface_sel.png"
	local character = script.Parent.Parent
	local player = game.Players:GetPlayerFromCharacter(character)

	mouseMoveCon = mouse.Move:connect(function() on3dMouseMove(mouse) end)
	button1DownCon = mouse.Button1Down:connect(function() on3dButton1Down(mouse) end)

	selectionSurface = Instance.new("SurfaceSelection")
	selectionSurface.Color = BrickColor.Red()
	selectionSurface.Adornee = nil
	selectionSurface.Parent = player.PlayerGui

	selectionLasso = Instance.new("SelectionPartLasso")
	selectionLasso.Name = "Model Surface Lasso"
	selectionLasso.Humanoid = character.Humanoid
	selectionLasso.Parent = game.workspace
	selectionLasso.Part = nil
	selectionLasso.Visible = true
	selectionLasso.archivable = false
	selectionLasso.Color = BrickColor.Yellow()

	menu = createSurfaceMenu()
	menu.Parent = game.Players.LocalPlayer.PlayerGui
end

function onUnequippedLocal()
	if mouseMoveCon then mouseMoveCon:disconnect() end
	if button1DownCon then button1DownCon:disconnect() end

	for i = 1, #conArray do
		if conArray[i] then conArray[i]:disconnect() end
	end
	conArray = {}

	menu:remove()
	Tool.TextureId = origTexture
	if selectionBox then selectionBox:Remove() end
	if selectionLasso then selectionLasso:Remove() end
	if selectionSurface then selectionSurface:Remove() end
end

script.Active.Changed:connect(function(prop)
	if script.Active.Value == true then
		onEquippedLocal(Tool.Mouse.Value)
	else
		onUnequippedLocal()
	end
end)
</ProtectedString>
			</Properties>
			<Item class="BoolValue" referent="RBX17">
				<Properties>
					<string name="Name">Active</string>
					<bool name="Value">false</bool>
				</Properties>
			</Item>
			<Item class="StringValue" referent="RBX18">
				<Properties>
					<string name="Name">CurrentSurface</string>
					<string name="Value">Smooth</string>
				</Properties>
			</Item>
		</Item>
		<Item class="ObjectValue" referent="RBX19">
			<Properties>
				<string name="Name">Mouse</string>
				<Ref name="Value">null</Ref>
			</Properties>
		</Item>
		<Item class="LocalScript" referent="RBX20">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Dragger</string>
				<ProtectedString name="Source">-- basic functions
function waitForChild(instance, name)
	while not instance:findFirstChild(name) do
		instance.ChildAdded:wait()
	end
end

local Tool = script.Parent

waitForChild(Tool.Dragger, "Active")


local gui = nil

local connections = {}

function deactivateTool(script)
	local enable = script:FindFirstChild("Active")
	if enable and enable:IsA("BoolValue") then
		enable.Value = false
	end
end

function deactivateAllTools()
	local toolChildren = script:GetChildren()
	for i = 1, #toolChildren do
		if toolChildren[i]:IsA("BaseScript") and toolChildren[i] ~= script then
			deactivateTool(toolChildren[i])
		end
	end
end

function switchGrid(type)
	deactivateAllTools()

	wait()

	if type == "1" then
		script.OldDragger.Active.Value = true
		gui.DraggerButton.Selected = true
		gui.Dragger4xButton.Selected = false
	else
		script.NewDragger.Active.Value = true
		gui.DraggerButton.Selected = false
		gui.Dragger4xButton.Selected = true
	end
end

function makeTextButton(buttonName, text, position, parent)
	local button = Instance.new("TextButton")
	button.Name = buttonName
	button.Style = Enum.ButtonStyle.RobloxButton
	button.Size = UDim2.new(0,100,0,40)
	if position then button.Position = position end
	button.Parent = parent

	button.Text = text
	button.Font = Enum.Font.ArialBold
	button.FontSize = Enum.FontSize.Size18
	button.TextColor3 = Color3.new(1,1,1)

	return button
end

function makeDraggerGui()
	local draggerGui = Instance.new("ScreenGui")
	draggerGui.Name = "DraggerGui"

	local draggerButton = makeTextButton("DraggerButton","1x1 Grid",UDim2.new(0.5,-100,0,0),draggerGui)
	local dragger4xButton = makeTextButton("Dragger4xButton","4x4 Grid",UDim2.new(0.5,0,0,0),draggerGui)

	local con = draggerButton.MouseButton1Click:connect(function() switchGrid("1") end)
	local con2 = dragger4xButton.MouseButton1Click:connect(function() switchGrid("4") end)
	table.insert(connections,con)
	table.insert(connections,con2)

	return draggerGui
end


function onEquippedLocal(mouse)
	Tool.Mouse.Value = mouse
	if not gui then
		gui = makeDraggerGui()
	end
	gui.Parent = game.Players.LocalPlayer.PlayerGui
	script.NewDragger.Active.Value = true
	gui.Dragger4xButton.Selected = true
end

function onUnequippedLocal()
	for i = 1, #connections do
		connections[i]:disconnect()
	end
	connections = {}

	gui:remove()
	gui = nil
	deactivateAllTools()
end

script.Active.Changed:connect(function(prop)
	if script.Active.Value == true then
		onEquippedLocal(Tool.Mouse.Value)
	else
		onUnequippedLocal()
	end
end)

</ProtectedString>
			</Properties>
			<Item class="LocalScript" referent="RBX21">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">OldDragger</string>
					<ProtectedString name="Source">-- basic functions
function waitForChild(instance, name)
	while not instance:findFirstChild(name) do
		instance.ChildAdded:wait()
	end
end

local Tool = script.Parent.Parent


waitForChild(Tool.Dragger.OldDragger, "Active")

enabled = true
local origTexture = 	Tool.TextureId
game:GetService("ContentProvider"):Preload("rbxasset://icons/freemove_sel.png")

local selectionBox
local currentSelection
local currentSelectionColors = {}
local selectionLasso
local inGui = false
local inPalette = false

local connections = {}

function canSelectObject(part)
	return part and not (part.Locked) and (part.Position - Tool.Parent.Head.Position).Magnitude &lt; 60
end

function findModel(part)
	while part ~= nil do
		if part:IsA("Model") and part ~= game.Workspace then
			return part
		elseif part == game.Workspace then
			return nil
		end
		part = part.Parent
	end

	return nil
end


function startDrag(mousePart, hitPoint, collection)
	dragger = Instance.new("Dragger")
	pcall(function() dragger:MouseDown(mousePart, hitPoint, collection) end)
end

function collectBaseParts(object, collection)
	if object == nil then return end
	if object:IsA("BasePart") then
		collection[#collection+1] = object
	end
	for index,child in pairs(object:GetChildren()) do
		collectBaseParts(child, collection)
	end
end

function onMouseDown(mouse) 
	mouse.Icon ="rbxasset://textures\\GrabRotateCursor.png"
	local part = mouse.Target
	if canSelectObject(part) then
		local hitPoint = mouse.Hit:toObjectSpace(part.CFrame).p
		if trySelection(part) then
			local instances = {}
			collectBaseParts(currentSelection, instances)
			startDrag(part, hitPoint, instances)
			return
		end
	end
	onMouseUp(mouse)
end



function onMouseUp(mouse)
	mouse.Icon ="rbxasset://textures\\GrabCursor.png"
	if dragger ~= nil then
		pcall(function() dragger:MouseUp() end)
		dragger = nil
	end
end

function trySelection(part)
	if canSelectObject(part) then
		selectionLasso.Part = part
		local model = findModel(part)
		if model then 		
			return setSelection(model)
		else
			return setSelection(part)
		end
	else
		clearSelection()
		return false
	end
end

function onKeyDown(key)
	if dragger ~= nil then
		if key == 'R' or key == 'r'  then
			dragger:AxisRotate(Enum.Axis.Y)
		elseif key == 'T' or key == 't' then
			dragger:AxisRotate(Enum.Axis.Z)
		end
	end
end
local alreadyMoving
function onMouseMove(mouse)
	if alreadyMoving then
		return
	end

	alreadyMoving = true
	if dragger ~= nil then
		pcall(function() dragger:MouseMove(mouse.UnitRay) end)
	else
		trySelection(mouse.Target)
	end
	alreadyMoving = false
end


function saveSelectionColor(instance)
	if instance:IsA("BasePart") then
		currentSelectionColors[instance] = instance.BrickColor
		if instance.BrickColor == BrickColor.Blue() then
			instance.BrickColor = BrickColor.new("Deep blue")
		else
			instance.BrickColor = BrickColor.Blue()
		end
	end

	local children = instance:GetChildren() 
	if children then
		for pos, child in pairs(children) do
			saveSelectionColor(child)
		end
	end
end
	
function setSelection(partOrModel)
	if partOrModel ~= currentSelection then
		clearSelection()
		currentSelection = partOrModel
		saveSelectionColor(currentSelection)
		selectionBox.Adornee = currentSelection
		return true
	else
		if currentSelection ~= nil then
			return true
		end
	end

	return false
end

function clearSelection()
	if currentSelection ~= nil then
		for part, color in pairs(currentSelectionColors) do
			part.BrickColor = color
		end
		selectionBox.Adornee = nil
	end
	currentSelectionColors = {}
	currentSelection = nil
	
	if(selectionLasso) then
		selectionLasso.Part = nil
	end
	if(selectionBox) then
		selectionBox.Adornee = nil
	end
end

function onEquippedLocal(mouse)
	wait(0.1)
	Tool.TextureId = "rbxasset://icons/freemove_sel.png"

	local character = script.Parent.Parent
	local player = game.Players:GetPlayerFromCharacter(character)
	guiMain = Instance.new("ScreenGui")
	guiMain.Parent = game.Players.LocalPlayer.PlayerGui

	inGui = false
	inPalette = false

	mouse.Icon ="rbxasset://textures\\GrabCursor.png"

	local con = mouse.Button1Down:connect(function() onMouseDown(mouse) end)
	table.insert(connections,con)
	con = mouse.Button1Up:connect(function() onMouseUp(mouse) end)
	con = table.insert(connections,con)
	con = mouse.Move:connect(function() onMouseMove(mouse) end)
	table.insert(connections,con)
	con = mouse.KeyDown:connect(function(string) onKeyDown(string) end)
	table.insert(connections,con)

	selectionBox = Instance.new("SelectionBox")
	selectionBox.Name = "Model Delete Selection"
	selectionBox.Color = BrickColor.Blue()
	selectionBox.Adornee = nil
	selectionBox.Parent = game.Players.LocalPlayer.PlayerGui

	selectionLasso = Instance.new("SelectionPartLasso")
	selectionLasso.Name = "Model Drag Lasso"
	selectionLasso.Humanoid = game.Players.LocalPlayer.Character.Humanoid
	selectionLasso.archivable = false
	selectionLasso.Visible = true
	selectionLasso.Parent = game.workspace
	selectionLasso.Color = BrickColor.Blue()

	alreadyMoving = false
end

function onUnequippedLocal()
	for i = 1, #connections do
		connections[i]:disconnect()
	end
	connections = {}

	Tool.TextureId = origTexture
	clearSelection()
	selectionBox:Remove()
	selectionLasso:Remove()
end


script.Active.Changed:connect(function()
	if script.Active.Value then
		onEquippedLocal(Tool.Mouse.Value)
	else
		onUnequippedLocal()
	end
end)
</ProtectedString>
				</Properties>
				<Item class="BoolValue" referent="RBX22">
					<Properties>
						<string name="Name">Active</string>
						<bool name="Value">false</bool>
					</Properties>
				</Item>
			</Item>
			<Item class="BoolValue" referent="RBX23">
				<Properties>
					<string name="Name">Active</string>
					<bool name="Value">false</bool>
				</Properties>
			</Item>
			<Item class="LocalScript" referent="RBX24">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">NewDragger</string>
					<ProtectedString name="Source">local Tool = script.Parent.Parent

game:GetService("ContentProvider"):Preload("rbxasset://icons/freemove_sel.png")

local selectionBox
local currentSelection
local currentSelectionColors = {}
local Mouse = nil

local player = nil

local instances = {}
local maxDragDistance = 60

local connections = {}

while not Tool:FindFirstChild("ErrorBox") do Tool.ChildAdded:wait() end
local errorBox = Tool.ErrorBox

local lastTargetCFrame = nil

function canSelectObject(part)
	return part and not (part.Locked) and (part.Position - script.Parent.Parent.Parent.Head.Position).Magnitude &lt; maxDragDistance
end

function findModel(part)
	while part ~= nil do
		if part.className == "Model" then
			return part
		end
		part = part.Parent
	end

	return nil
end

function isPart(object)
	return object and (object:IsA("Part") or object:IsA("TrussPart") or object:IsA("WedgePart") or object:IsA("VehicleSeat"))
end

function positionPartsAtCFrame3(collection, aCFrame)

	local insertCFrame
	if collection[1]:IsA("Model") then
		-- we assume model has at least one part in it; need to find first part
		i = 1
		while (i &lt; (#collection[1]:GetChildren()) and not isPart(collection[1]:GetChildren()[i])) do
			i = i + 1
		end
		insertCFrame = collection[1]:GetChildren()[i].CFrame

		for i, object in pairs(collection[1]:GetChildren()) do
			if isPart(object) then
				local posPartInWorld = object.Position
				local posPart1InWorld = insertCFrame.p
				local newPosPartInWorld = posPartInWorld - posPart1InWorld + aCFrame.p
	
				local x, y, z, R00, R01, R02, R10, R11, R12, R20, R21, R22 = object.CFrame:components()
				object.CFrame = CFrame.new(newPosPartInWorld.x, newPosPartInWorld.y, newPosPartInWorld.z, R00, R01, R02, R10, R11, R12, R20, R21, R22)
			end
		end
	else
		collection[1].CFrame = aCFrame
	end

end

function getBoundingBox2(partOrModel)

-- for models, the bounding box is defined as the minimum and maximum individual part bounding boxes
-- relative to the first part's coordinate frame.

	local minVec = Vector3.new(math.huge, math.huge, math.huge)
	local maxVec = Vector3.new(-math.huge, -math.huge, -math.huge)

	if isPart(partOrModel) then
		minVec = -0.5 * partOrModel.Size
		maxVec = -minVec
	elseif partOrModel:IsA("Terrain") then
		minVec = Vector3.new(-2, -2, -2)
		maxVec = Vector3.new(2, 2, 2)
	else
		local part1 = partOrModel:GetChildren()[1]
		for i, object in pairs(partOrModel:GetChildren()) do
			if isPart(object) then
				boxMinInWorld = object.CFrame:pointToWorldSpace(-0.5 * object.Size)
				boxMinInPart1 = part1.CFrame:pointToObjectSpace(boxMinInWorld)
				boxMaxInWorld = object.CFrame:pointToWorldSpace(0.5 * object.Size)
				boxMaxInPart1 = part1.CFrame:pointToObjectSpace(boxMaxInWorld)

				local minX = minVec.x
				local minY = minVec.y
				local minZ = minVec.z
				local maxX = maxVec.x
				local maxY = maxVec.y
				local maxZ = maxVec.z
				if boxMinInPart1.x &lt; minVec.x then
					minX = boxMinInPart1.x
				end
				if boxMinInPart1.y &lt; minVec.y then
					minY = boxMinInPart1.y
				end
				if boxMinInPart1.z &lt; minVec.z then
					minZ = boxMinInPart1.z
				end
				if boxMaxInPart1.x &lt; minX then
					minX = boxMaxInPart1.x
				end
				if boxMaxInPart1.y &lt; minY then
					minY = boxMaxInPart1.y
				end
				if boxMaxInPart1.z &lt; minZ then
					minZ = boxMaxInPart1.z
				end

				if boxMinInPart1.x &gt; maxVec.x then
					maxX = boxMinInPart1.x
				end
				if boxMinInPart1.y &gt; maxVec.y then
					maxY = boxMinInPart1.y
				end
				if boxMinInPart1.z &gt; maxVec.z then
					maxZ = boxMinInPart1.z
				end
				if boxMaxInPart1.x &gt; maxX then
					maxX = boxMaxInPart1.x
				end
				if boxMaxInPart1.y &gt; maxY then
					maxY = boxMaxInPart1.y
				end
				if boxMaxInPart1.z &gt; maxZ then
					maxZ = boxMaxInPart1.z
				end

				minVec = Vector3.new(minX, minY, minZ)
				maxVec = Vector3.new(maxX, maxY, maxZ)
			end
		end
	end

	return minVec, maxVec

end


-- function to do the same as above, but in world coordinates (really only used for region3-based bounds-checking)
function getBoundingBoxInWorldCoordinates(partOrModel)
	local minVec = Vector3.new(math.huge, math.huge, math.huge)
	local maxVec = Vector3.new(-math.huge, -math.huge, -math.huge)

	if partOrModel:IsA("Part") or partOrModel:IsA("WedgePart") or partOrModel:IsA("TrussPart")then
		vec1 = partOrModel.CFrame:pointToWorldSpace(-0.5 * partOrModel.Size)
		vec2 = partOrModel.CFrame:pointToWorldSpace(0.5 * partOrModel.Size)
		minVec = Vector3.new(math.min(vec1.X, vec2.X), math.min(vec1.Y, vec2.Y), math.min(vec1.Z, vec2.Z))
		maxVec = Vector3.new(math.max(vec1.X, vec2.X), math.max(vec1.Y, vec2.Y), math.max(vec1.Z, vec2.Z))
	elseif partOrModel:IsA("Terrain") then
		-- we shouldn't have to deal with this case
		--minVec = Vector3.new(-2, -2, -2)
		--maxVec = Vector3.new(2, 2, 2)
	else
		local part1 = partOrModel:GetChildren()[1]
		for i, object in pairs(partOrModel:GetChildren()) do
			if (object:IsA("Part") or object:IsA("WedgePart") or object:IsA("TrussPart")) then
				boxMinInWorld = object.CFrame:pointToWorldSpace(-0.5 * object.Size)
				boxMinInPart1 = part1.CFrame:pointToObjectSpace(boxMinInWorld)
				boxMaxInWorld = object.CFrame:pointToWorldSpace(0.5 * object.Size)
				boxMaxInPart1 = part1.CFrame:pointToObjectSpace(boxMaxInWorld)

				local minX = minVec.x
				local minY = minVec.y
				local minZ = minVec.z
				local maxX = maxVec.x
				local maxY = maxVec.y
				local maxZ = maxVec.z
				if boxMinInWorld.x &lt; minVec.x then
					minX = boxMinInWorld.x
				end
				if boxMinInWorld.y &lt; minVec.y then
					minY = boxMinInWorld.y
				end
				if boxMinInWorld.z &lt; minVec.z then
					minZ = boxMinInWorld.z
				end
				if boxMaxInWorld.x &lt; minX then
					minX = boxMaxInWorld.x
				end
				if boxMaxInWorld.y &lt; minY then
					minY = boxMaxInWorld.y
				end
				if boxMaxInWorld.z &lt; minZ then
					minZ = boxMaxInWorld.z
				end

				if boxMinInWorld.x &gt; maxVec.x then
					maxX = boxMinInWorld.x
				end
				if boxMinInWorld.y &gt; maxVec.y then
					maxY = boxMinInWorld.y
				end
				if boxMinInWorld.z &gt; maxVec.z then
					maxZ = boxMinInWorld.z
				end
				if boxMaxInWorld.x &gt; maxX then
					maxX = boxMaxInWorld.x
				end
				if boxMaxInWorld.y &gt; maxY then
					maxY = boxMaxInWorld.y
				end
				if boxMaxInWorld.z &gt; maxZ then
					maxZ = boxMaxInWorld.z
				end

				minVec = Vector3.new(minX, minY, minZ)
				maxVec = Vector3.new(maxX, maxY, maxZ)
			end
		end
	end

	return minVec, maxVec
end


function getTargetPartBoundingBox(targetPart)

	if targetPart.Parent:FindFirstChild("RobloxModel") ~= nil then
		return getBoundingBox2(targetPart.Parent)
	else
		return getBoundingBox2(targetPart)
	end

end

function getMouseTargetCFrame(targetPart)

	if targetPart.Parent:FindFirstChild("RobloxModel") ~= nil then
		return targetPart.Parent:GetChildren()[1].CFrame
	else
		return targetPart.CFrame
	end

end

function getClosestAlignedWorldDirection(aVector3InWorld)

	local xDir = Vector3.new(1,0,0)
	local yDir = Vector3.new(0,1,0)
	local zDir = Vector3.new(0,0,1)
	local xDot = aVector3InWorld.x * xDir.x + aVector3InWorld.y * xDir.y + aVector3InWorld.z * xDir.z
	local yDot = aVector3InWorld.x * yDir.x + aVector3InWorld.y * yDir.y + aVector3InWorld.z * yDir.z
	local zDot = aVector3InWorld.x * zDir.x + aVector3InWorld.y * zDir.y + aVector3InWorld.z * zDir.z

	if math.abs(xDot) &gt; math.abs(yDot) and math.abs(xDot) &gt; math.abs(zDot) then
		if xDot &gt; 0 then
			return 0
		else
			return 3
		end
	elseif math.abs(yDot) &gt; math.abs(xDot) and math.abs(yDot) &gt; math.abs(zDot) then
		if yDot &gt; 0 then
			return 1
		else
			return 4
		end
	else
		if zDot &gt; 0 then
			return 2
		else
			return 5
		end
	end 

end


function findConfigAtMouseTarget(collection)

-- *Critical Assumption* :
--				This function assumes the target CF axes are orthogonal with the target bounding box faces
--				And, it assumes the insert CF axes are orthongonal with the insert bounding box faces
--				Therefore, insertion will not work with angled faces on wedges or other "non-block" parts, nor
--				will it work for parts in a model that are not orthogonally aligned with the model's CF.

	local grid = 4.0
	local admissibleConfig = false
	local targetConfig = CFrame.new(0,0,0)

	local minBB, maxBB = getBoundingBox2(collection[1])
	local diagBB = maxBB - minBB

	local insertCFrame
	if collection[1]:IsA("Model") then
		i = 1
		while (i &lt; (#collection[1]:GetChildren()) and not isPart(collection[1]:GetChildren()[i])) do
			i = i + 1
		end
		insertCFrame = collection[1]:GetChildren()[i].CFrame
	else
		insertCFrame = collection[1].CFrame
	end

	Mouse.TargetFilter = collection[1]

	local targetPart = Mouse.Target

	if targetPart == nil then
		return admissibleConfig, targetConfig
	end

	-- test mouse hit location
	local minBBTarget, maxBBTarget = getTargetPartBoundingBox(targetPart)
	local diagBBTarget = maxBBTarget - minBBTarget
	local targetCFrame = getMouseTargetCFrame(targetPart)
	local hitCFrame = Mouse.Hit
	local mouseHitInWorld = hitCFrame.p

	--local targetVectorInWorld = targetCFrame:vectorToWorldSpace(Vector3.FromNormalId(Mouse.TargetSurface))

	if targetPart:IsA("Terrain") then
		if not cluster then cluster = game.Workspace.Terrain end

		-- the prefer solid is messing things up very slightly!! (because the TargetSurface stays correct when the cells are shifted very slightly prematurely)
		cellID = cluster:WorldToCellPreferSolid(mouseHitInWorld)
		targetCFrame = CFrame.new(cluster:CellCenterToWorld(cellID.x, cellID.y, cellID.z))
	end

	local targetVectorInWorld = targetCFrame:vectorToWorldSpace(Vector3.FromNormalId(Mouse.TargetSurface))
	local mouseHitInTarget = targetCFrame:pointToObjectSpace(mouseHitInWorld)

	local targetRefPointInTarget
	local clampToSurface

	if getClosestAlignedWorldDirection(targetVectorInWorld) == 0 then
		targetRefPointInTarget = targetCFrame:vectorToObjectSpace(Vector3.new(1, -1, 1))
		insertRefPointInInsert = insertCFrame:vectorToObjectSpace(Vector3.new(-1, -1, 1))
		clampToSurface = Vector3.new(0,1,1)
	elseif getClosestAlignedWorldDirection(targetVectorInWorld) == 3 then
		targetRefPointInTarget = targetCFrame:vectorToObjectSpace(Vector3.new(-1, -1, -1))
		insertRefPointInInsert = insertCFrame:vectorToObjectSpace(Vector3.new(1, -1, -1))
		clampToSurface = Vector3.new(0,1,1)
	elseif getClosestAlignedWorldDirection(targetVectorInWorld) == 1 then
		targetRefPointInTarget = targetCFrame:vectorToObjectSpace(Vector3.new(-1, 1, 1))
		insertRefPointInInsert = insertCFrame:vectorToObjectSpace(Vector3.new(-1, -1, 1))
		clampToSurface = Vector3.new(1,0,1)		
	elseif getClosestAlignedWorldDirection(targetVectorInWorld) == 4 then
		targetRefPointInTarget = targetCFrame:vectorToObjectSpace(Vector3.new(-1, -1, 1))
		insertRefPointInInsert = insertCFrame:vectorToObjectSpace(Vector3.new(-1, 1, 1))
		clampToSurface = Vector3.new(1,0,1)
	elseif getClosestAlignedWorldDirection(targetVectorInWorld) == 2 then
		targetRefPointInTarget = targetCFrame:vectorToObjectSpace(Vector3.new(-1, -1, 1))
		insertRefPointInInsert = insertCFrame:vectorToObjectSpace(Vector3.new(-1, -1, -1))
		clampToSurface = Vector3.new(1,1,0)
	else
		targetRefPointInTarget = targetCFrame:vectorToObjectSpace(Vector3.new(1, -1, -1))
		insertRefPointInInsert = insertCFrame:vectorToObjectSpace(Vector3.new(1, -1, 1))
		clampToSurface = Vector3.new(1,1,0)
	end

	targetRefPointInTarget = targetRefPointInTarget * (0.5 * diagBBTarget) + 0.5 * (maxBBTarget + minBBTarget)
	insertRefPointInInsert = insertRefPointInInsert * (0.5 * diagBB) + 0.5 * (maxBB + minBB)
	
	-- To Do: For cases that are not aligned to the world grid, account for the minimal rotation
	-- needed to bring the Insert part(s) into alignment with the Target Part
	-- Apply the rotation here

	local delta = mouseHitInTarget - targetRefPointInTarget
	local deltaClamped = Vector3.new(grid * math.modf(delta.x/grid), grid * math.modf(delta.y/grid), grid * math.modf(delta.z/grid))
	deltaClamped = deltaClamped * clampToSurface
	local targetTouchInTarget = deltaClamped + targetRefPointInTarget

	local TargetTouchRelToWorld = targetCFrame:pointToWorldSpace(targetTouchInTarget)
	local InsertTouchInWorld = insertCFrame:vectorToWorldSpace(insertRefPointInInsert)
	local posInsertOriginInWorld = TargetTouchRelToWorld - InsertTouchInWorld

	local x, y, z, R00, R01, R02, R10, R11, R12, R20, R21, R22 = insertCFrame:components()
	targetConfig = CFrame.new(posInsertOriginInWorld.x, posInsertOriginInWorld.y, posInsertOriginInWorld.z, R00, R01, R02, R10, R11, R12, R20, R21, R22)
	admissibleConfig = true

	return admissibleConfig, targetConfig

end


function startDrag(mousePart, hitPoint, collection)
	lastTargetCFrame = nil
	dragger = Instance.new("Dragger")
	pcall(function() dragger:MouseDown(mousePart, hitPoint, collection) end)
end

function collectBaseParts(object, collection)
	if object == nil then return end
	--if object:IsA("BasePart") then
	if isPart(object) then
		collection[#collection+1] = object
	end
	for index,child in pairs(object:GetChildren()) do
		collectBaseParts(child, collection)
	end
end

function onMouseDown(mouse) 
	mouse.Icon ="rbxasset://textures\\GrabRotateCursor.png"
	local part = mouse.Target
	if canSelectObject(part) then
		local hitPoint = mouse.Hit:toObjectSpace(part.CFrame).p
		if trySelection(part) then
			instances = {}
			game.JointsService:ClearJoinAfterMoveJoints()
			game.JointsService:SetJoinAfterMoveInstance(mouse.Target)
			collectBaseParts(currentSelection, instances)
			startDrag(part, hitPoint, instances)
			return
		end
	end
end



-- stampability-checking functions (copied from StampScript)

function flashRedBox(targetModel)
	if not player then return end
	errorBox.Parent = player.PlayerGui
	errorBox.Adornee = targetModel

	delay(0,function()
		for i = 1, 3 do
			errorBox.Visible = true
			wait(0.13)
			errorBox.Visible = false
			wait(0.13)
		end
		errorBox.Adornee = nil
		errorBox.Parent = Tool
	end)
end

-- below function should work as a Region3 query, returning true if a single cluster part is within this region
function clusterPartsInRegion(startVector, endVector)

	if not cluster then return false end

	local startCell = cluster:WorldToCell(startVector)
	local endCell = cluster:WorldToCell(endVector)

	local startX = startCell.X
	local startY = startCell.Y
	local startZ = startCell.Z

	local endX = endCell.X
	local endY = endCell.Y
	local endZ = endCell.Z

	if startX &lt; cluster.MaxExtents.Min.X then startX = cluster.MaxExtents.Min.X end
	if startY &lt; cluster.MaxExtents.Min.Y then startY = cluster.MaxExtents.Min.Y end
	if startZ &lt; cluster.MaxExtents.Min.Z then startZ = cluster.MaxExtents.Min.Z end

	if endX &gt; cluster.MaxExtents.Max.X then endX = cluster.MaxExtents.Max.X end
	if endY &gt; cluster.MaxExtents.Max.Y then endY = cluster.MaxExtents.Max.Y end
	if endZ &gt; cluster.MaxExtents.Max.Z then endZ = cluster.MaxExtents.Max.Z end

	--print(startX, endX)
	--print(startY, endY)
	--print(startZ, endZ)

	for x = startX, endX do
		for y = startY, endY do
			for z = startZ, endZ do
				--if game.Workspace.Cluster:GetCell(x, y, z) &gt; 0 then return true end
				if (cluster:GetCell(x, y, z).Value) &gt; 0 then return true end
			end
		end
	end

	return false
end


-- helper function to determine if a character can be pushed upwards by a certain amount
-- FILL THIS OUT!!!  -- character is 5 studs tall, we'll check a 1.5 x 1.5 x 4.5 box around char, with center .5 studs below torsocenter
function spaceAboveCharacter(charTorso, newTorsoY)
	local partsAboveChar = game.Workspace:FindPartsInRegion3(Region3.new(Vector3.new(charTorso.Position.X, newTorsoY, charTorso.Position.Z) - Vector3.new(.75, 2.75, .75), Vector3.new(charTorso.Position.X, newTorsoY, charTorso.Position.Z) + Vector3.new(.75, 1.75, .75)), charTorso.Parent, 100)
	for j = 1, #partsAboveChar do
		if partsAboveChar[j].CanCollide and not partsAboveChar[j]:IsDescendantOf(currentSelection) then return false end
	end

	if clusterPartsInRegion(Vector3.new(charTorso.Position.X, newTorsoY, charTorso.Position.Z) - Vector3.new(.75, 2.75, .75), Vector3.new(charTorso.Position.X, newTorsoY, charTorso.Position.Z) + Vector3.new(.75, 1.75, .75)) then return false end

	return true
end



local insertBoundingBoxOverlapVector = Vector3.new(1, 1, 1)

function onMouseUp(mouse)
	mouse.Icon ="rbxasset://textures\\GrabCursor.png"
	local thingToPlace = {}
	thingToPlace[1] = currentSelection

	if dragger ~= nil then
		local minBB, maxBB = getBoundingBoxInWorldCoordinates(currentSelection)
		local configFound, targetCFrame = findConfigAtMouseTarget(thingToPlace)

		if configFound then
			-- don't drag into terrain
			if clusterPartsInRegion(minBB+insertBoundingBoxOverlapVector, maxBB-insertBoundingBoxOverlapVector) then flashRedBox(currentSelection) return end
			
			local blockingParts = game.Workspace:FindPartsInRegion3(Region3.new(minBB+insertBoundingBoxOverlapVector, maxBB-insertBoundingBoxOverlapVector), currentSelection, 100)
			for b = 1, #blockingParts do
				-- put code back here if we want to prevent dragger from dragging into other stamped models (once Region3 fix goes out)
			end

			local alreadyPushedUp = {}
			-- if no blocking model below, then see if stamping on top of a character
			for b = 1, #blockingParts do
				if blockingParts[b].Parent and not alreadyPushedUp[blockingParts[b].Parent] and blockingParts[b].Parent:FindFirstChild("Humanoid") and blockingParts[b].Parent:FindFirstChild("Humanoid"):IsA("Humanoid") then
					local blockingPersonTorso = blockingParts[b].Parent:FindFirstChild("Torso")
					alreadyPushedUp[blockingParts[b].Parent] = true

					if blockingPersonTorso then
						-- if so, let's push the person upwards so they pop on top of the stamped model/part (but only if there's space above them)
						local newY = maxBB.Y + 3
						if spaceAboveCharacter(blockingPersonTorso, newY) then
							blockingPersonTorso.CFrame = blockingPersonTorso.CFrame + Vector3.new(0, newY - blockingPersonTorso.CFrame.p.Y, 0)
						else
							-- if no space, we just error
							flashRedBox(currentSelection)
							return
						end
					end
				end
			end

			Mouse.TargetFilter = nil
			pcall(function() dragger:MouseUp() end)
			game.JointsService:CreateJoinAfterMoveJoints()
			dragger = nil
		end
	end
end


function trySelection(part)
	if canSelectObject(part) then
		local model = findModel(part)
		if model then 		
			return setSelection(model)
		else
			return setSelection(part)
		end
	else
		clearSelection()
		return false
	end
end

function onKeyDown(key)
	if dragger ~= nil then
		if key == 'R' or key == 'r'  then
			pcall(function() dragger:AxisRotate(Enum.Axis.Y) end)
		elseif key == 'T' or key == 't' then
			pcall(function() dragger:AxisRotate(Enum.Axis.Z) end)
		end
	end
end

local alreadyMoving = false
function onMouseMove(mouse)
	if alreadyMoving then
		return
	end

	alreadyMoving = true
	if dragger ~= nil then
		local thingToDrag = {}
		thingToDrag[1] = currentSelection 
	
		pcall(function() dragger:MouseMove(mouse.UnitRay) end)-- needed to break welds properly
		configFound, targetCFrame = findConfigAtMouseTarget(thingToDrag)
		if configFound then
			local minBB, maxBB = getBoundingBoxInWorldCoordinates(currentSelection)
	
			-- need to offset by distance to be dragged
			local currModelCFrame
			if currentSelection:IsA("Model") then
				-- we assume model has at least one part in it; need to find first part
				i = 1
				while (i &lt; (#currentSelection:GetChildren()) and not isPart(currentSelection:GetChildren()[i])) do
					i = i + 1
				end
				currModelCFrame = currentSelection:GetChildren()[i].CFrame
			else currModelCFrame = currentSelection.CFrame end
			minBB = minBB + targetCFrame.p - currModelCFrame.p
			maxBB = maxBB + targetCFrame.p - currModelCFrame.p

			-- don't drag into terrain
			if clusterPartsInRegion(minBB+insertBoundingBoxOverlapVector, maxBB-insertBoundingBoxOverlapVector) then 
				if lastTargetCFrame then positionPartsAtCFrame3(thingToDrag, lastTargetCFrame) end
				alreadyMoving = false 
				return 
			end
			
			local blockingParts = game.Workspace:FindPartsInRegion3(Region3.new(minBB+insertBoundingBoxOverlapVector, maxBB-insertBoundingBoxOverlapVector), currentSelection, 100)
			for b = 1, #blockingParts do
				-- put code back here if we want to prevent dragger from dragging into other stamped models (once Region3 fix goes out)
			end
			positionPartsAtCFrame3(thingToDrag, targetCFrame)
			lastTargetCFrame = targetCFrame
		end
	else
		trySelection(mouse.Target)
	end
	alreadyMoving = false
end


function saveSelectionColor(instance)
	if instance:IsA("BasePart") then
		currentSelectionColors[instance] = instance.BrickColor
		if instance.BrickColor == BrickColor.Blue() then
			instance.BrickColor = BrickColor.new("Deep blue")
		else
			instance.BrickColor = BrickColor.Blue()
		end
	end

	local children = instance:GetChildren() 
	if children then
		for pos, child in pairs(children) do
			saveSelectionColor(child)
		end
	end
end
	
function setSelection(partOrModel)
	if partOrModel ~= currentSelection then
		clearSelection()
		currentSelection = partOrModel
		saveSelectionColor(currentSelection)
		selectionBox.Adornee = currentSelection
		return true
	elseif partOrModel == nil then
		clearSelection()
		return false
	end

	return partOrModel == currentSelection
end

function clearSelection()
	if currentSelection ~= nil then
		for part, color in pairs(currentSelectionColors) do
			part.BrickColor = color
		end
		selectionBox.Adornee = nil
	end
	currentSelectionColors = {}
	currentSelection = nil

	if(selectionBox) then
		selectionBox.Adornee = nil
	end
end

function onEquippedLocal(mouse)
	Mouse = mouse

	local character = script.Parent.Parent.Parent
	player = game.Players:GetPlayerFromCharacter(character)

	mouse.Icon ="rbxasset://textures\\GrabCursor.png"

	local con = Mouse.Button1Down:connect(function() onMouseDown(Mouse) end)
	table.insert(connections,con)
	con = Mouse.Button1Up:connect(function() onMouseUp(Mouse) end)
	con = table.insert(connections,con)
	con = Mouse.Move:connect(function() onMouseMove(Mouse) end)
	table.insert(connections,con)
	con = Mouse.KeyDown:connect(function(string) onKeyDown(string) end)
	table.insert(connections,con)

	selectionBox = Instance.new("SelectionBox")
	selectionBox.Name = "Model Delete Selection"
	selectionBox.Color = BrickColor.Blue()
	selectionBox.Adornee = nil
	selectionBox.Parent = player.PlayerGui

	alreadyMoving = false
end

function onUnequippedLocal()
	for i = 1, #connections do
		connections[i]:disconnect()
	end
	connections = {}

	clearSelection()
	selectionBox:Remove()
end

script.Active.Changed:connect(function()
	if script.Active.Value then
		onEquippedLocal(Tool.Mouse.Value)
	else
		onUnequippedLocal()
	end
end)</ProtectedString>
				</Properties>
				<Item class="BoolValue" referent="RBX25">
					<Properties>
						<string name="Name">Active</string>
						<bool name="Value">false</bool>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="SelectionBox" referent="RBX26">
			<Properties>
				<Ref name="Adornee">null</Ref>
				<int name="Color">21</int>
				<string name="Name">ErrorBox</string>
				<float name="Transparency">0</float>
				<bool name="Visible">false</bool>
			</Properties>
		</Item>
	</Item>
	<Item class="Tool" referent="RBX27">
		<Properties>
			<bool name="CanBeDropped">true</bool>
			<bool name="Enabled">true</bool>
			<CoordinateFrame name="Grip">
				<X>0</X>
				<Y>0</Y>
				<Z>-0.699999988</Z>
				<R00>0</R00>
				<R01>0</R01>
				<R02>1</R02>
				<R10>1</R10>
				<R11>0</R11>
				<R12>0</R12>
				<R20>0</R20>
				<R21>1</R21>
				<R22>0</R22>
			</CoordinateFrame>
			<string name="Name">ConfigTool</string>
			<Content name="TextureId"><url>rbxasset://../../../shareddata/textures/59102714.png</url></Content>
			<string name="ToolTip">Configure Parts</string>
		</Properties>
		<Item class="Part" referent="RBX28">
			<Properties>
				<bool name="Anchored">false</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">0</token>
				<token name="BottomSurfaceInput">0</token>
				<int name="BrickColor">194</int>
				<CoordinateFrame name="CFrame">
					<X>0</X>
					<Y>14.3999958</Y>
					<Z>21.5</Z>
					<R00>0</R00>
					<R01>0</R01>
					<R02>-1</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>1</R20>
					<R21>0</R21>
					<R22>0</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<float name="Elasticity">0.5</float>
				<float name="Friction">0.300000012</float>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">true</bool>
				<token name="Material">256</token>
				<string name="Name">Handle</string>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">0</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">2</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>1</X>
					<Y>0.800000012</Y>
					<Z>2</Z>
				</Vector3>
			</Properties>
			<Item class="SpecialMesh" referent="RBX29">
				<Properties>
					<token name="LODX">2</token>
					<token name="LODY">2</token>
					<Content name="MeshId"><url>rbxasset://../../../shareddata/fonts/16884681.mesh</url></Content>
					<token name="MeshType">5</token>
					<string name="Name">Mesh</string>
					<Vector3 name="Offset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<Vector3 name="Scale">
						<X>0.600000024</X>
						<Y>0.600000024</Y>
						<Z>0.600000024</Z>
					</Vector3>
					<Content name="TextureId"><url>rbxasset://../../../shareddata/textures/16884673.png</url></Content>
					<Vector3 name="VertexColor">
						<X>1</X>
						<Y>1</Y>
						<Z>1</Z>
					</Vector3>
				</Properties>
			</Item>
		</Item>
		<Item class="LocalScript" referent="RBX30">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">ConfigurationLocal</string>
				<ProtectedString name="Source">
local t = {}

local function ScopedConnect(parentInstance, instance, event, signalFunc, syncFunc, removeFunc)
	local eventConnection = nil

	--Connection on parentInstance is scoped by parentInstance (when destroyed, it goes away)
	local tryConnect = function()
		if game:IsAncestorOf(parentInstance) then
			--Entering the world, make sure we are connected/synced
			if not eventConnection then
				eventConnection = instance[event]:connect(signalFunc)
				if syncFunc then syncFunc() end
			end
		else
			--Probably leaving the world, so disconnect for now
			if eventConnection then
				eventConnection:disconnect()
				if removeFunc then removeFunc() end
			end
		end
	end

	--Hook it up to ancestryChanged signal
	local connection = parentInstance.AncestryChanged:connect(tryConnect)
	
	--Now connect us if we're already in the world
	tryConnect()
	
	return connection
end

local function getScreenGuiAncestor(instance)
	local localInstance = instance
	while localInstance and not localInstance:IsA("ScreenGui") do
		localInstance = localInstance.Parent
	end
	return localInstance
end

local function CreateButtons(frame, buttons, yPos, ySize)
	local buttonNum = 1
	local buttonObjs = {}
	for i, obj in ipairs(buttons) do 
		local button = Instance.new("TextButton")
		button.Name = "Button" .. buttonNum
		button.Font = Enum.Font.Arial
		button.FontSize = Enum.FontSize.Size18
		button.AutoButtonColor = true
		button.Modal = true
		if obj["Style"] then
			button.Style = obj.Style
		else
			button.Style = Enum.ButtonStyle.RobloxButton
		end
		if obj["ZIndex"] then
			button.ZIndex = obj.ZIndex
		end
		button.Text = obj.Text
		button.TextColor3 = Color3.new(1,1,1)
		button.MouseButton1Click:connect(obj.Function)
		button.Parent = frame
		buttonObjs[buttonNum] = button

		buttonNum = buttonNum + 1
	end
	local numButtons = buttonNum-1

	if numButtons == 1 then
		frame.Button1.Position = UDim2.new(0.35, 0, yPos.Scale, yPos.Offset)
		frame.Button1.Size = UDim2.new(.4,0,ySize.Scale, ySize.Offset)
	elseif numButtons == 2 then
		frame.Button1.Position = UDim2.new(0.1, 0, yPos.Scale, yPos.Offset)
		frame.Button1.Size = UDim2.new(.8/3,0, ySize.Scale, ySize.Offset)

		frame.Button2.Position = UDim2.new(0.55, 0, yPos.Scale, yPos.Offset)
		frame.Button2.Size = UDim2.new(.35,0, ySize.Scale, ySize.Offset)
	elseif numButtons &gt;= 3 then
		local spacing = .1 / numButtons
		local buttonSize = .9 / numButtons

		buttonNum = 1
		while buttonNum &lt;= numButtons do
			buttonObjs[buttonNum].Position = UDim2.new(spacing*buttonNum + (buttonNum-1) * buttonSize, 0, yPos.Scale, yPos.Offset)
			buttonObjs[buttonNum].Size = UDim2.new(buttonSize, 0, ySize.Scale, ySize.Offset)
			buttonNum = buttonNum + 1
		end
	end
end

local function setSliderPos(newAbsPosX,slider,sliderPosition,bar,steps)

	local newStep = steps - 1 --otherwise we really get one more step than we want
	local relativePosX = math.min(1, math.max(0, (newAbsPosX - bar.AbsolutePosition.X) / bar.AbsoluteSize.X ))
	local wholeNum, remainder = math.modf(relativePosX * newStep)
	if remainder &gt; 0.5 then
		wholeNum = wholeNum + 1
	end
	relativePosX = wholeNum/newStep

	local result = math.ceil(relativePosX * newStep)
	if sliderPosition.Value ~= (result + 1) then --only update if we moved a step
		sliderPosition.Value = result + 1
		slider.Position = UDim2.new(relativePosX,-slider.AbsoluteSize.X/2,slider.Position.Y.Scale,slider.Position.Y.Offset)
	end
	
end

local function cancelSlide(areaSoak)
	areaSoak.Visible = false
	if areaSoakMouseMoveCon then areaSoakMouseMoveCon:disconnect() end
end

t.CreateStyledMessageDialog = function(title, message, style, buttons)
	local frame = Instance.new("Frame")
	frame.Size = UDim2.new(0.5, 0, 0, 165)
	frame.Position = UDim2.new(0.25, 0, 0.5, -72.5)
	frame.Name = "MessageDialog"
	frame.Active = true
	frame.Style = Enum.FrameStyle.RobloxRound	
	
	local styleImage = Instance.new("ImageLabel")
	styleImage.Name = "StyleImage"
	styleImage.BackgroundTransparency = 1
	styleImage.Position = UDim2.new(0,5,0,15)
	if style == "error" or style == "Error" then
		styleImage.Size = UDim2.new(0, 71, 0, 71)
		styleImage.Image = "http://www.roblox.com/asset/?id=42565285"
	elseif style == "notify" or style == "Notify" then
		styleImage.Size = UDim2.new(0, 71, 0, 71)
		styleImage.Image = "http://www.roblox.com/asset/?id=42604978"
	elseif style == "confirm" or style == "Confirm" then
		styleImage.Size = UDim2.new(0, 74, 0, 76)
		styleImage.Image = "http://www.roblox.com/asset/?id=42557901"
	else
		return t.CreateMessageDialog(title,message,buttons)
	end
	styleImage.Parent = frame
	
	local titleLabel = Instance.new("TextLabel")
	titleLabel.Name = "Title"
	titleLabel.Text = title
	titleLabel.TextStrokeTransparency = 0
	titleLabel.BackgroundTransparency = 1
	titleLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
	titleLabel.Position = UDim2.new(0, 80, 0, 0)
	titleLabel.Size = UDim2.new(1, -80, 0, 40)
	titleLabel.Font = Enum.Font.ArialBold
	titleLabel.FontSize = Enum.FontSize.Size36
	titleLabel.TextXAlignment = Enum.TextXAlignment.Center
	titleLabel.TextYAlignment = Enum.TextYAlignment.Center
	titleLabel.Parent = frame

	local messageLabel = Instance.new("TextLabel")
	messageLabel.Name = "Message"
	messageLabel.Text = message
	messageLabel.TextStrokeTransparency = 0
	messageLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
	messageLabel.Position = UDim2.new(0.025, 80, 0, 45)
	messageLabel.Size = UDim2.new(0.95, -80, 0, 55)
	messageLabel.BackgroundTransparency = 1
	messageLabel.Font = Enum.Font.Arial
	messageLabel.FontSize = Enum.FontSize.Size18
	messageLabel.TextWrap = true
	messageLabel.TextXAlignment = Enum.TextXAlignment.Left
	messageLabel.TextYAlignment = Enum.TextYAlignment.Top
	messageLabel.Parent = frame

	CreateButtons(frame, buttons, UDim.new(0, 105), UDim.new(0, 40) )

	return frame
end

t.CreateMessageDialog = function(title, message, buttons)
	local frame = Instance.new("Frame")
	frame.Size = UDim2.new(0.5, 0, 0.5, 0)
	frame.Position = UDim2.new(0.25, 0, 0.25, 0)
	frame.Name = "MessageDialog"
	frame.Active = true
	frame.Style = Enum.FrameStyle.RobloxRound

	local titleLabel = Instance.new("TextLabel")
	titleLabel.Name = "Title"
	titleLabel.Text = title
	titleLabel.BackgroundTransparency = 1
	titleLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
	titleLabel.Position = UDim2.new(0, 0, 0, 0)
	titleLabel.Size = UDim2.new(1, 0, 0.15, 0)
	titleLabel.Font = Enum.Font.ArialBold
	titleLabel.FontSize = Enum.FontSize.Size36
	titleLabel.TextXAlignment = Enum.TextXAlignment.Center
	titleLabel.TextYAlignment = Enum.TextYAlignment.Center
	titleLabel.Parent = frame

	local messageLabel = Instance.new("TextLabel")
	messageLabel.Name = "Message"
	messageLabel.Text = message
	messageLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
	messageLabel.Position = UDim2.new(0.025, 0, 0.175, 0)
	messageLabel.Size = UDim2.new(0.95, 0, .55, 0)
	messageLabel.BackgroundTransparency = 1
	messageLabel.Font = Enum.Font.Arial
	messageLabel.FontSize = Enum.FontSize.Size18
	messageLabel.TextWrap = true
	messageLabel.TextXAlignment = Enum.TextXAlignment.Left
	messageLabel.TextYAlignment = Enum.TextYAlignment.Top
	messageLabel.Parent = frame

	CreateButtons(frame, buttons, UDim.new(0.8,0), UDim.new(0.15, 0))

	return frame
end

t.CreateDropDownMenu = function(items, onSelect, forRoblox, whiteSkin, baseZ)
	local baseZIndex = 0
	if (type(baseZ) == "number") then
		baseZIndex = baseZ
	end
	local width = UDim.new(0, 100)
	local height = UDim.new(0, 32)

	local xPos = 0.055
	local frame = Instance.new("Frame")
	local textColor = Color3.new(1,1,1)
	if (whiteSkin) then
		textColor = Color3.new(0.5, 0.5, 0.5)
	end
	frame.Name = "DropDownMenu"
	frame.BackgroundTransparency = 1
	frame.Size = UDim2.new(width, height)

	local dropDownMenu = Instance.new("TextButton")
	dropDownMenu.Name = "DropDownMenuButton"
	dropDownMenu.TextWrap = true
	dropDownMenu.TextColor3 = textColor
	dropDownMenu.Text = "Choose One"
	dropDownMenu.Font = Enum.Font.ArialBold
	dropDownMenu.FontSize = Enum.FontSize.Size18
	dropDownMenu.TextXAlignment = Enum.TextXAlignment.Left
	dropDownMenu.TextYAlignment = Enum.TextYAlignment.Center
	dropDownMenu.BackgroundTransparency = 1
	dropDownMenu.AutoButtonColor = true
	if (whiteSkin) then
		dropDownMenu.Style = Enum.ButtonStyle.RobloxRoundDropdownButton
	else
		dropDownMenu.Style = Enum.ButtonStyle.RobloxButton
	end
	dropDownMenu.Size = UDim2.new(1,0,1,0)
	dropDownMenu.Parent = frame
	dropDownMenu.ZIndex = 2 + baseZIndex

	local dropDownIcon = Instance.new("ImageLabel")
	dropDownIcon.Name = "Icon"
	dropDownIcon.Active = false
	if (whiteSkin) then
		dropDownIcon.Image = "rbxasset://textures/ui/dropdown_arrow.png"
		dropDownIcon.Size = UDim2.new(0,16,0,12)
		dropDownIcon.Position = UDim2.new(1,-17,0.5, -6)
	else
		dropDownIcon.Image = "http://www.roblox.com/asset/?id=45732894"
		dropDownIcon.Size = UDim2.new(0,11,0,6)
		dropDownIcon.Position = UDim2.new(1,-11,0.5, -2)
	end
	dropDownIcon.BackgroundTransparency = 1
	dropDownIcon.Parent = dropDownMenu
	dropDownIcon.ZIndex = 2 + baseZIndex
	
	local itemCount = #items
	local dropDownItemCount = #items
	local useScrollButtons = false
	if dropDownItemCount &gt; 6 then
		useScrollButtons = true
		dropDownItemCount = 6
	end
	
	local droppedDownMenu = Instance.new("TextButton")
	droppedDownMenu.Name = "List"
	droppedDownMenu.Text = ""
	droppedDownMenu.BackgroundTransparency = 1
	--droppedDownMenu.AutoButtonColor = true
	if (whiteSkin) then
		droppedDownMenu.Style = Enum.ButtonStyle.RobloxRoundDropdownButton
	else
		droppedDownMenu.Style = Enum.ButtonStyle.RobloxButton
	end
	droppedDownMenu.Visible = false
	droppedDownMenu.Active = true	--Blocks clicks
	droppedDownMenu.Position = UDim2.new(0,0,0,0)
	droppedDownMenu.Size = UDim2.new(1,0, (1 + dropDownItemCount)*.8, 0)
	droppedDownMenu.Parent = frame
	droppedDownMenu.ZIndex = 2 + baseZIndex

	local choiceButton = Instance.new("TextButton")
	choiceButton.Name = "ChoiceButton"
	choiceButton.BackgroundTransparency = 1
	choiceButton.BorderSizePixel = 0
	choiceButton.Text = "ReplaceMe"
	choiceButton.TextColor3 = textColor
	choiceButton.TextXAlignment = Enum.TextXAlignment.Left
	choiceButton.TextYAlignment = Enum.TextYAlignment.Center
	choiceButton.BackgroundColor3 = Color3.new(1, 1, 1)
	choiceButton.Font = Enum.Font.Arial
	choiceButton.FontSize = Enum.FontSize.Size18
	if useScrollButtons then
		choiceButton.Size = UDim2.new(1,-13, .8/((dropDownItemCount + 1)*.8),0) 
	else
		choiceButton.Size = UDim2.new(1, 0, .8/((dropDownItemCount + 1)*.8),0) 
	end
	choiceButton.TextWrap = true
	choiceButton.ZIndex = 2 + baseZIndex

	local areaSoak = Instance.new("TextButton")
	areaSoak.Name = "AreaSoak"
	areaSoak.Text = ""
	areaSoak.BackgroundTransparency = 1
	areaSoak.Active = true
	areaSoak.Size = UDim2.new(1,0,1,0)
	areaSoak.Visible = false
	areaSoak.ZIndex = 3 + baseZIndex

	local dropDownSelected = false

	local scrollUpButton 
	local scrollDownButton
	local scrollMouseCount = 0

	local setZIndex = function(baseZIndex)
		droppedDownMenu.ZIndex = baseZIndex +1
		if scrollUpButton then
			scrollUpButton.ZIndex = baseZIndex + 3
		end
		if scrollDownButton then
			scrollDownButton.ZIndex = baseZIndex + 3
		end
		
		local children = droppedDownMenu:GetChildren()
		if children then
			for i, child in ipairs(children) do
				if child.Name == "ChoiceButton" then
					child.ZIndex = baseZIndex + 2
				elseif child.Name == "ClickCaptureButton" then
					child.ZIndex = baseZIndex
				end
			end
		end
	end

	local scrollBarPosition = 1
	local updateScroll = function()
		if scrollUpButton then
			scrollUpButton.Active = scrollBarPosition &gt; 1 
		end
		if scrollDownButton then
			scrollDownButton.Active = scrollBarPosition + dropDownItemCount &lt;= itemCount 
		end

		local children = droppedDownMenu:GetChildren()
		if not children then return end

		local childNum = 1			
		for i, obj in ipairs(children) do
			if obj.Name == "ChoiceButton" then
				if childNum &lt; scrollBarPosition or childNum &gt;= scrollBarPosition + dropDownItemCount then
					obj.Visible = false
				else
					obj.Position = UDim2.new(0,0,((childNum-scrollBarPosition+1)*.8)/((dropDownItemCount+1)*.8),0)
					obj.Visible = true
				end
				obj.TextColor3 = textColor
				obj.BackgroundTransparency = 1

				childNum = childNum + 1
			end
		end
	end
	local toggleVisibility = function()
		dropDownSelected = not dropDownSelected

		areaSoak.Visible = not areaSoak.Visible
		dropDownMenu.Visible = not dropDownSelected
		droppedDownMenu.Visible = dropDownSelected
		if dropDownSelected then
			setZIndex(4 + baseZIndex)
		else
			setZIndex(2 + baseZIndex)
		end
		if useScrollButtons then
			updateScroll()
		end
	end
	droppedDownMenu.MouseButton1Click:connect(toggleVisibility)

	local updateSelection = function(text)
		local foundItem = false
		local children = droppedDownMenu:GetChildren()
		local childNum = 1
		if children then
			for i, obj in ipairs(children) do
				if obj.Name == "ChoiceButton" then
					if obj.Text == text then
						obj.Font = Enum.Font.ArialBold
						foundItem = true			
						scrollBarPosition = childNum						
						if (whiteSkin) then
							obj.TextColor3 = Color3.new(90/255,142/255,233/255)
						end
					else
						obj.Font = Enum.Font.Arial
						if (whiteSkin) then
							obj.TextColor3 = textColor
						end
					end
					childNum = childNum + 1
				end
			end
		end
		if not text then
			dropDownMenu.Text = "Choose One"
			scrollBarPosition = 1
		else
			if not foundItem then
				error("Invalid Selection Update -- " .. text)
			end

			if scrollBarPosition + dropDownItemCount &gt; itemCount + 1 then
				scrollBarPosition = itemCount - dropDownItemCount + 1
			end

			dropDownMenu.Text = text
		end
	end
	
	local function scrollDown()
		if scrollBarPosition + dropDownItemCount &lt;= itemCount then
			scrollBarPosition = scrollBarPosition + 1
			updateScroll()
			return true
		end
		return false
	end
	local function scrollUp()
		if scrollBarPosition &gt; 1 then
			scrollBarPosition = scrollBarPosition - 1
			updateScroll()
			return true
		end
		return false
	end
	
	if useScrollButtons then
		--Make some scroll buttons
		scrollUpButton = Instance.new("ImageButton")
		scrollUpButton.Name = "ScrollUpButton"
		scrollUpButton.BackgroundTransparency = 1
		scrollUpButton.Image = "rbxasset://textures/ui/scrollbuttonUp.png"
		scrollUpButton.Size = UDim2.new(0,17,0,17) 
		scrollUpButton.Position = UDim2.new(1,-11,(1*.8)/((dropDownItemCount+1)*.8),0)
		scrollUpButton.MouseButton1Click:connect(
			function()
				scrollMouseCount = scrollMouseCount + 1
			end)
		scrollUpButton.MouseLeave:connect(
			function()
				scrollMouseCount = scrollMouseCount + 1
			end)
		scrollUpButton.MouseButton1Down:connect(
			function()
				scrollMouseCount = scrollMouseCount + 1
	
				scrollUp()
				local val = scrollMouseCount
				wait(0.5)
				while val == scrollMouseCount do
					if scrollUp() == false then
						break
					end
					wait(0.1)
				end				
			end)

		scrollUpButton.Parent = droppedDownMenu

		scrollDownButton = Instance.new("ImageButton")
		scrollDownButton.Name = "ScrollDownButton"
		scrollDownButton.BackgroundTransparency = 1
		scrollDownButton.Image = "rbxasset://textures/ui/scrollbuttonDown.png"
		scrollDownButton.Size = UDim2.new(0,17,0,17) 
		scrollDownButton.Position = UDim2.new(1,-11,1,-11)
		scrollDownButton.Parent = droppedDownMenu
		scrollDownButton.MouseButton1Click:connect(
			function()
				scrollMouseCount = scrollMouseCount + 1
			end)
		scrollDownButton.MouseLeave:connect(
			function()
				scrollMouseCount = scrollMouseCount + 1
			end)
		scrollDownButton.MouseButton1Down:connect(
			function()
				scrollMouseCount = scrollMouseCount + 1

				scrollDown()
				local val = scrollMouseCount
				wait(0.5)
				while val == scrollMouseCount do
					if scrollDown() == false then
						break
					end
					wait(0.1)
				end				
			end)	

		local scrollbar = Instance.new("ImageLabel")
		scrollbar.Name = "ScrollBar"
		scrollbar.Image = "rbxasset://textures/ui/scrollbar.png"
		scrollbar.BackgroundTransparency = 1
		scrollbar.Size = UDim2.new(0, 18, (dropDownItemCount*.8)/((dropDownItemCount+1)*.8), -(17) - 11 - 4)
		scrollbar.Position = UDim2.new(1,-11,(1*.8)/((dropDownItemCount+1)*.8),17+2)
		scrollbar.Parent = droppedDownMenu
	end

	for i,item in ipairs(items) do
		-- needed to maintain local scope for items in event listeners below
		local button = choiceButton:clone()
		if forRoblox then
			button.RobloxLocked = true
		end		
		button.Text = item
		button.Parent = droppedDownMenu
		if (whiteSkin) then
			button.TextColor3 = textColor
		end

		button.MouseButton1Click:connect(function()
			--Remove Highlight
			if (not whiteSkin) then
				button.TextColor3 = Color3.new(1,1,1)
			end
			button.BackgroundTransparency = 1

			updateSelection(item)
			onSelect(item)

			toggleVisibility()
		end)
		button.MouseEnter:connect(function()
			--Add Highlight	
			if (not whiteSkin) then
				button.TextColor3 = Color3.new(0,0,0)
			end
			button.BackgroundTransparency = 0
		end)

		button.MouseLeave:connect(function()
			--Remove Highlight
			if (not whiteSkin) then
				button.TextColor3 = Color3.new(1,1,1)
			end
			button.BackgroundTransparency = 1
		end)
	end

	--This does the initial layout of the buttons	
	updateScroll()
	
	frame.AncestryChanged:connect(function(child,parent)
		if parent == nil then
			areaSoak.Parent = nil
		else
			areaSoak.Parent = getScreenGuiAncestor(frame)
		end
	end)

	dropDownMenu.MouseButton1Click:connect(toggleVisibility)
	areaSoak.MouseButton1Click:connect(toggleVisibility)
	return frame, updateSelection
end

t.CreatePropertyDropDownMenu = function(instance, property, enum)

	local items = enum:GetEnumItems()
	local names = {}
	local nameToItem = {}
	for i,obj in ipairs(items) do
		names[i] = obj.Name
		nameToItem[obj.Name] = obj
	end

	local frame
	local updateSelection
	frame, updateSelection = t.CreateDropDownMenu(names, function(text) instance[property] = nameToItem[text] end)

	ScopedConnect(frame, instance, "Changed", 
		function(prop)
			if prop == property then
				updateSelection(instance[property].Name)
			end
		end,
		function()
			updateSelection(instance[property].Name)
		end)

	return frame
end

t.GetFontHeight = function(font, fontSize)
	if font == nil or fontSize == nil then
		error("Font and FontSize must be non-nil")
	end

	if font == Enum.Font.Legacy then
		if fontSize == Enum.FontSize.Size8 then
			return 12
		elseif fontSize == Enum.FontSize.Size9 then
			return 14
		elseif fontSize == Enum.FontSize.Size10 then
			return 15
		elseif fontSize == Enum.FontSize.Size11 then
			return 17
		elseif fontSize == Enum.FontSize.Size12 then
			return 18
		elseif fontSize == Enum.FontSize.Size14 then
			return 21
		elseif fontSize == Enum.FontSize.Size18 then
			return 27
		elseif fontSize == Enum.FontSize.Size24 then
			return 36
		elseif fontSize == Enum.FontSize.Size36 then
			return 54
		elseif fontSize == Enum.FontSize.Size48 then
			return 72
		else
			error("Unknown FontSize")
		end
	elseif font == Enum.Font.Arial or font == Enum.Font.ArialBold then
		if fontSize == Enum.FontSize.Size8 then
			return 8
		elseif fontSize == Enum.FontSize.Size9 then
			return 9
		elseif fontSize == Enum.FontSize.Size10 then
			return 10
		elseif fontSize == Enum.FontSize.Size11 then
			return 11
		elseif fontSize == Enum.FontSize.Size12 then
			return 12
		elseif fontSize == Enum.FontSize.Size14 then
			return 14
		elseif fontSize == Enum.FontSize.Size18 then
			return 18
		elseif fontSize == Enum.FontSize.Size24 then
			return 24
		elseif fontSize == Enum.FontSize.Size36 then
			return 36
		elseif fontSize == Enum.FontSize.Size48 then
			return 48
		else
			error("Unknown FontSize")
		end
	else
		error("Unknown Font " .. font)
	end
end

local function layoutGuiObjectsHelper(frame, guiObjects, settingsTable)
	local totalPixels = frame.AbsoluteSize.Y
	local pixelsRemaining = frame.AbsoluteSize.Y
	for i, child in ipairs(guiObjects) do
		if child:IsA("TextLabel") or child:IsA("TextButton") then
			local isLabel = child:IsA("TextLabel")
			if isLabel then
				pixelsRemaining = pixelsRemaining - settingsTable["TextLabelPositionPadY"]
			else
				pixelsRemaining = pixelsRemaining - settingsTable["TextButtonPositionPadY"]
			end
			child.Position = UDim2.new(child.Position.X.Scale, child.Position.X.Offset, 0, totalPixels - pixelsRemaining)
			child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, pixelsRemaining)

			if child.TextFits and child.TextBounds.Y &lt; pixelsRemaining then
				child.Visible = true
				if isLabel then
					child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, child.TextBounds.Y + settingsTable["TextLabelSizePadY"])
				else 
					child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, child.TextBounds.Y + settingsTable["TextButtonSizePadY"])
				end

				while not child.TextFits do
					child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, child.AbsoluteSize.Y + 1)
				end
				pixelsRemaining = pixelsRemaining - child.AbsoluteSize.Y		

				if isLabel then
					pixelsRemaining = pixelsRemaining - settingsTable["TextLabelPositionPadY"]
				else
					pixelsRemaining = pixelsRemaining - settingsTable["TextButtonPositionPadY"]
				end
			else
				child.Visible = false
				pixelsRemaining = -1
			end			

		else
			--GuiObject
			child.Position = UDim2.new(child.Position.X.Scale, child.Position.X.Offset, 0, totalPixels - pixelsRemaining)
			pixelsRemaining = pixelsRemaining - child.AbsoluteSize.Y
			child.Visible = (pixelsRemaining &gt;= 0)
		end
	end
end

t.LayoutGuiObjects = function(frame, guiObjects, settingsTable)
	if not frame:IsA("GuiObject") then
		error("Frame must be a GuiObject")
	end
	for i, child in ipairs(guiObjects) do
		if not child:IsA("GuiObject") then
			error("All elements that are layed out must be of type GuiObject")
		end
	end

	if not settingsTable then
		settingsTable = {}
	end

	if not settingsTable["TextLabelSizePadY"] then
		settingsTable["TextLabelSizePadY"] = 0
	end
	if not settingsTable["TextLabelPositionPadY"] then
		settingsTable["TextLabelPositionPadY"] = 0
	end
	if not settingsTable["TextButtonSizePadY"] then
		settingsTable["TextButtonSizePadY"] = 12
	end
	if not settingsTable["TextButtonPositionPadY"] then
		settingsTable["TextButtonPositionPadY"] = 2
	end

	--Wrapper frame takes care of styled objects
	local wrapperFrame = Instance.new("Frame")
	wrapperFrame.Name = "WrapperFrame"
	wrapperFrame.BackgroundTransparency = 1
	wrapperFrame.Size = UDim2.new(1,0,1,0)
	wrapperFrame.Parent = frame

	for i, child in ipairs(guiObjects) do
		child.Parent = wrapperFrame
	end

	local recalculate = function()
		wait()
		layoutGuiObjectsHelper(wrapperFrame, guiObjects, settingsTable)
	end
	
	frame.Changed:connect(
		function(prop)
			if prop == "AbsoluteSize" then
				--Wait a heartbeat for it to sync in
				recalculate(nil)
			end
		end)
	frame.AncestryChanged:connect(recalculate)

	layoutGuiObjectsHelper(wrapperFrame, guiObjects, settingsTable)
end


t.CreateSlider = function(steps,width,position)
	local sliderGui = Instance.new("Frame")
	sliderGui.Size = UDim2.new(1,0,1,0)
	sliderGui.BackgroundTransparency = 1
	sliderGui.Name = "SliderGui"
	
	local sliderSteps = Instance.new("IntValue")
	sliderSteps.Name = "SliderSteps"
	sliderSteps.Value = steps
	sliderSteps.Parent = sliderGui
	
	local areaSoak = Instance.new("TextButton")
	areaSoak.Name = "AreaSoak"
	areaSoak.Text = ""
	areaSoak.BackgroundTransparency = 1
	areaSoak.Active = false
	areaSoak.Size = UDim2.new(1,0,1,0)
	areaSoak.Visible = false
	areaSoak.ZIndex = 4
	
	sliderGui.AncestryChanged:connect(function(child,parent)
		if parent == nil then
			areaSoak.Parent = nil
		else
			areaSoak.Parent = getScreenGuiAncestor(sliderGui)
		end
	end)
	
	local sliderPosition = Instance.new("IntValue")
	sliderPosition.Name = "SliderPosition"
	sliderPosition.Value = 0
	sliderPosition.Parent = sliderGui
	
	local id = math.random(1,100)
	
	local bar = Instance.new("TextButton")
	bar.Text = ""
	bar.AutoButtonColor = false
	bar.Name = "Bar"
	bar.BackgroundColor3 = Color3.new(0,0,0)
	if type(width) == "number" then
		bar.Size = UDim2.new(0,width,0,5)
	else
		bar.Size = UDim2.new(0,200,0,5)
	end
	bar.BorderColor3 = Color3.new(95/255,95/255,95/255)
	bar.ZIndex = 2
	bar.Parent = sliderGui
	
	if position["X"] and position["X"]["Scale"] and position["X"]["Offset"] and position["Y"] and position["Y"]["Scale"] and position["Y"]["Offset"] then
		bar.Position = position
	end
	
	local slider = Instance.new("ImageButton")
	slider.Name = "Slider"
	slider.BackgroundTransparency = 1
	slider.Image = "rbxasset://textures/ui/Slider.png"
	slider.Position = UDim2.new(0,0,0.5,-10)
	slider.Size = UDim2.new(0,20,0,20)
	slider.ZIndex = 3
	slider.Parent = bar
	
	local areaSoakMouseMoveCon = nil
	
	areaSoak.MouseLeave:connect(function()
		if areaSoak.Visible then
			cancelSlide(areaSoak)
		end
	end)
	areaSoak.MouseButton1Up:connect(function()
		if areaSoak.Visible then
			cancelSlide(areaSoak)
		end
	end)
	
	slider.MouseButton1Down:connect(function()
		areaSoak.Visible = true
		if areaSoakMouseMoveCon then areaSoakMouseMoveCon:disconnect() end
		areaSoakMouseMoveCon = areaSoak.MouseMoved:connect(function(x,y)
			setSliderPos(x,slider,sliderPosition,bar,steps)
		end)
	end)
	
	slider.MouseButton1Up:connect(function() cancelSlide(areaSoak) end)
	
	sliderPosition.Changed:connect(function(prop)
		sliderPosition.Value = math.min(steps, math.max(1,sliderPosition.Value))
		local relativePosX = (sliderPosition.Value - 1) / (steps - 1)
		slider.Position = UDim2.new(relativePosX,-slider.AbsoluteSize.X/2,slider.Position.Y.Scale,slider.Position.Y.Offset)
	end)
	
	bar.MouseButton1Down:connect(function(x,y)
		setSliderPos(x,slider,sliderPosition,bar,steps)
	end)
	
	return sliderGui, sliderPosition, sliderSteps

end



t.CreateSliderNew = function(steps,width,position)
	local sliderGui = Instance.new("Frame")
	sliderGui.Size = UDim2.new(1,0,1,0)
	sliderGui.BackgroundTransparency = 1
	sliderGui.Name = "SliderGui"
	
	local sliderSteps = Instance.new("IntValue")
	sliderSteps.Name = "SliderSteps"
	sliderSteps.Value = steps
	sliderSteps.Parent = sliderGui
	
	local areaSoak = Instance.new("TextButton")
	areaSoak.Name = "AreaSoak"
	areaSoak.Text = ""
	areaSoak.BackgroundTransparency = 1
	areaSoak.Active = false
	areaSoak.Size = UDim2.new(1,0,1,0)
	areaSoak.Visible = false
	areaSoak.ZIndex = 6
	
	sliderGui.AncestryChanged:connect(function(child,parent)
		if parent == nil then
			areaSoak.Parent = nil
		else
			areaSoak.Parent = getScreenGuiAncestor(sliderGui)
		end
	end)
	
	local sliderPosition = Instance.new("IntValue")
	sliderPosition.Name = "SliderPosition"
	sliderPosition.Value = 0
	sliderPosition.Parent = sliderGui
	
	local id = math.random(1,100)
	
	local sliderBarImgHeight = 7
	local sliderBarCapImgWidth = 4

	local bar = Instance.new("ImageButton")
	bar.BackgroundTransparency = 1
	bar.Image = "rbxasset://textures/ui/Slider-BKG-Center.png"
	bar.Name = "Bar"
	local displayWidth = 200
	if type(width) == "number" then
		bar.Size = UDim2.new(0,width - (sliderBarCapImgWidth * 2),0,sliderBarImgHeight)
		displayWidth = width - (sliderBarCapImgWidth * 2)
	else
		bar.Size = UDim2.new(0,200,0,sliderBarImgHeight)
	end
	bar.ZIndex = 3
	bar.Parent = sliderGui	
	if position["X"] and position["X"]["Scale"] and position["X"]["Offset"] and position["Y"] and position["Y"]["Scale"] and position["Y"]["Offset"] then
		bar.Position = position
	end

	local barLeft = bar:clone()
	barLeft.Name = "BarLeft"
	barLeft.Image = "rbxasset://textures/ui/Slider-BKG-Left-Cap.png"
	barLeft.Size = UDim2.new(0, sliderBarCapImgWidth, 0, sliderBarImgHeight)
	barLeft.Position = UDim2.new(position.X.Scale, position.X.Offset - sliderBarCapImgWidth, position.Y.Scale, position.Y.Offset)
	barLeft.Parent = sliderGui	
	barLeft.ZIndex = 3

	local barRight = barLeft:clone()
	barRight.Name = "BarRight"
	barRight.Image = "rbxasset://textures/ui/Slider-BKG-Right-Cap.png"
	barRight.Position = UDim2.new(position.X.Scale, position.X.Offset + displayWidth, position.Y.Scale, position.Y.Offset)
	barRight.Parent = sliderGui	

	local fillLeft = barLeft:clone()
	fillLeft.Name = "FillLeft"
	fillLeft.Image = "rbxasset://textures/ui/Slider-Fill-Left-Cap.png"
	fillLeft.Parent = sliderGui	
	fillLeft.ZIndex = 4

	local fill = fillLeft:clone()
	fill.Name = "Fill"
	fill.Image = "rbxasset://textures/ui/Slider-Fill-Center.png"
	fill.Parent = bar	
	fill.ZIndex = 4
	fill.Position = UDim2.new(0, 0, 0, 0)
	fill.Size = UDim2.new(0.5, 0, 1, 0)


--	bar.Visible = false

	local slider = Instance.new("ImageButton")
	slider.Name = "Slider"
	slider.BackgroundTransparency = 1
	slider.Image = "rbxasset://textures/ui/slider_new_tab.png"
	slider.Position = UDim2.new(0,0,0.5,-14)
	slider.Size = UDim2.new(0,28,0,28)
	slider.ZIndex = 5
	slider.Parent = bar
	
	local areaSoakMouseMoveCon = nil
	
	areaSoak.MouseLeave:connect(function()
		if areaSoak.Visible then
			cancelSlide(areaSoak)
		end
	end)
	areaSoak.MouseButton1Up:connect(function()
		if areaSoak.Visible then
			cancelSlide(areaSoak)
		end
	end)
	
	slider.MouseButton1Down:connect(function()
		areaSoak.Visible = true
		if areaSoakMouseMoveCon then areaSoakMouseMoveCon:disconnect() end
		areaSoakMouseMoveCon = areaSoak.MouseMoved:connect(function(x,y)
			setSliderPos(x,slider,sliderPosition,bar,steps)
		end)
	end)
	
	slider.MouseButton1Up:connect(function() cancelSlide(areaSoak) end)
	
	sliderPosition.Changed:connect(function(prop)
		sliderPosition.Value = math.min(steps, math.max(1,sliderPosition.Value))
		local relativePosX = (sliderPosition.Value - 1) / (steps - 1)
		slider.Position = UDim2.new(relativePosX,-slider.AbsoluteSize.X/2,slider.Position.Y.Scale,slider.Position.Y.Offset)
		fill.Size = UDim2.new(relativePosX, 0, 1, 0)
	end)
	
	bar.MouseButton1Down:connect(function(x,y)
		setSliderPos(x,slider,sliderPosition,bar,steps)
	end)

	return sliderGui, sliderPosition, sliderSteps

end





t.CreateTrueScrollingFrame = function()
	local lowY = nil
	local highY = nil
	
	local dragCon = nil
	local upCon = nil

	local internalChange = false

	local descendantsChangeConMap = {}

	local scrollingFrame = Instance.new("Frame")
	scrollingFrame.Name = "ScrollingFrame"
	scrollingFrame.Active = true
	scrollingFrame.Size = UDim2.new(1,0,1,0)
	scrollingFrame.ClipsDescendants = true

	local controlFrame = Instance.new("Frame")
	controlFrame.Name = "ControlFrame"
	controlFrame.BackgroundTransparency = 1
	controlFrame.Size = UDim2.new(0,18,1,0)
	controlFrame.Position = UDim2.new(1,-20,0,0)
	controlFrame.Parent = scrollingFrame
	
	local scrollBottom = Instance.new("BoolValue")
	scrollBottom.Value = false
	scrollBottom.Name = "ScrollBottom"
	scrollBottom.Parent = controlFrame
	
	local scrollUp = Instance.new("BoolValue")
	scrollUp.Value = false
	scrollUp.Name = "scrollUp"
	scrollUp.Parent = controlFrame

	local scrollUpButton = Instance.new("TextButton")
	scrollUpButton.Name = "ScrollUpButton"
	scrollUpButton.Text = ""
	scrollUpButton.AutoButtonColor = false
	scrollUpButton.BackgroundColor3 = Color3.new(0,0,0)
	scrollUpButton.BorderColor3 = Color3.new(1,1,1)
	scrollUpButton.BackgroundTransparency = 0.5
	scrollUpButton.Size = UDim2.new(0,18,0,18)
	scrollUpButton.ZIndex = 2
	scrollUpButton.Parent = controlFrame
	for i = 1, 6 do
		local triFrame = Instance.new("Frame")
		triFrame.BorderColor3 = Color3.new(1,1,1)
		triFrame.Name = "tri" .. tostring(i)
		triFrame.ZIndex = 3
		triFrame.BackgroundTransparency = 0.5
		triFrame.Size = UDim2.new(0,12 - ((i -1) * 2),0,0)
		triFrame.Position = UDim2.new(0,3 + (i -1),0.5,2 - (i -1))
		triFrame.Parent = scrollUpButton
	end
	scrollUpButton.MouseEnter:connect(function()
		scrollUpButton.BackgroundTransparency = 0.1
		local upChildren = scrollUpButton:GetChildren()
		for i = 1, #upChildren do
			upChildren[i].BackgroundTransparency = 0.1
		end
	end)
	scrollUpButton.MouseLeave:connect(function()
		scrollUpButton.BackgroundTransparency = 0.5
		local upChildren = scrollUpButton:GetChildren()
		for i = 1, #upChildren do
			upChildren[i].BackgroundTransparency = 0.5
		end
	end)

	local scrollDownButton = scrollUpButton:clone()
	scrollDownButton.Name = "ScrollDownButton"
	scrollDownButton.Position = UDim2.new(0,0,1,-18)
	local downChildren = scrollDownButton:GetChildren()
	for i = 1, #downChildren do
		downChildren[i].Position = UDim2.new(0,3 + (i -1),0.5,-2 + (i - 1))
	end
	scrollDownButton.MouseEnter:connect(function()
		scrollDownButton.BackgroundTransparency = 0.1
		local downChildren = scrollDownButton:GetChildren()
		for i = 1, #downChildren do
			downChildren[i].BackgroundTransparency = 0.1
		end
	end)
	scrollDownButton.MouseLeave:connect(function()
		scrollDownButton.BackgroundTransparency = 0.5
		local downChildren = scrollDownButton:GetChildren()
		for i = 1, #downChildren do
			downChildren[i].BackgroundTransparency = 0.5
		end
	end)
	scrollDownButton.Parent = controlFrame
	
	local scrollTrack = Instance.new("Frame")
	scrollTrack.Name = "ScrollTrack"
	scrollTrack.BackgroundTransparency = 1
	scrollTrack.Size = UDim2.new(0,18,1,-38)
	scrollTrack.Position = UDim2.new(0,0,0,19)
	scrollTrack.Parent = controlFrame

	local scrollbar = Instance.new("TextButton")
	scrollbar.BackgroundColor3 = Color3.new(0,0,0)
	scrollbar.BorderColor3 = Color3.new(1,1,1)
	scrollbar.BackgroundTransparency = 0.5
	scrollbar.AutoButtonColor = false
	scrollbar.Text = ""
	scrollbar.Active = true
	scrollbar.Name = "ScrollBar"
	scrollbar.ZIndex = 2
	scrollbar.BackgroundTransparency = 0.5
	scrollbar.Size = UDim2.new(0, 18, 0.1, 0)
	scrollbar.Position = UDim2.new(0,0,0,0)
	scrollbar.Parent = scrollTrack

	local scrollNub = Instance.new("Frame")
	scrollNub.Name = "ScrollNub"
	scrollNub.BorderColor3 = Color3.new(1,1,1)
	scrollNub.Size = UDim2.new(0,10,0,0)
	scrollNub.Position = UDim2.new(0.5,-5,0.5,0)
	scrollNub.ZIndex = 2
	scrollNub.BackgroundTransparency = 0.5
	scrollNub.Parent = scrollbar

	local newNub = scrollNub:clone()
	newNub.Position = UDim2.new(0.5,-5,0.5,-2)
	newNub.Parent = scrollbar
	
	local lastNub = scrollNub:clone()
	lastNub.Position = UDim2.new(0.5,-5,0.5,2)
	lastNub.Parent = scrollbar

	scrollbar.MouseEnter:connect(function()
		scrollbar.BackgroundTransparency = 0.1
		scrollNub.BackgroundTransparency = 0.1
		newNub.BackgroundTransparency = 0.1
		lastNub.BackgroundTransparency = 0.1
	end)
	scrollbar.MouseLeave:connect(function()
		scrollbar.BackgroundTransparency = 0.5
		scrollNub.BackgroundTransparency = 0.5
		newNub.BackgroundTransparency = 0.5
		lastNub.BackgroundTransparency = 0.5
	end)

	local mouseDrag = Instance.new("ImageButton")
	mouseDrag.Active = false
	mouseDrag.Size = UDim2.new(1.5, 0, 1.5, 0)
	mouseDrag.AutoButtonColor = false
	mouseDrag.BackgroundTransparency = 1
	mouseDrag.Name = "mouseDrag"
	mouseDrag.Position = UDim2.new(-0.25, 0, -0.25, 0)
	mouseDrag.ZIndex = 10
	
	local function positionScrollBar(x,y,offset)
		local oldPos = scrollbar.Position

		if y &lt; scrollTrack.AbsolutePosition.y then
			scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,0,0)
			return (oldPos ~= scrollbar.Position)
		end
		
		local relativeSize = scrollbar.AbsoluteSize.Y/scrollTrack.AbsoluteSize.Y

		if y &gt; (scrollTrack.AbsolutePosition.y + scrollTrack.AbsoluteSize.y) then
			scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,1 - relativeSize,0)
			return (oldPos ~= scrollbar.Position)
		end
		local newScaleYPos = (y - scrollTrack.AbsolutePosition.y - offset)/scrollTrack.AbsoluteSize.y
		if newScaleYPos + relativeSize &gt; 1 then
			newScaleYPos = 1 - relativeSize
			scrollBottom.Value = true
			scrollUp.Value = false
		elseif newScaleYPos &lt;= 0 then
			newScaleYPos = 0
			scrollUp.Value = true
			scrollBottom.Value = false
		else
			scrollUp.Value = false
			scrollBottom.Value = false
		end
		scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,newScaleYPos,0)
		
		return (oldPos ~= scrollbar.Position)
	end

	local function drillDownSetHighLow(instance)
		if not instance or not instance:IsA("GuiObject") then return end
		if instance == controlFrame then return end
		if instance:IsDescendantOf(controlFrame) then return end
		if not instance.Visible then return end

		if lowY and lowY &gt; instance.AbsolutePosition.Y then
			lowY = instance.AbsolutePosition.Y
		elseif not lowY then
			lowY = instance.AbsolutePosition.Y
		end
		if highY and highY &lt; (instance.AbsolutePosition.Y + instance.AbsoluteSize.Y) then
			highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
		elseif not highY then
			highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
		end
		local children = instance:GetChildren()
		for i = 1, #children do
			drillDownSetHighLow(children[i])
		end
	end

	local function resetHighLow()
		local firstChildren = scrollingFrame:GetChildren()

		for i = 1, #firstChildren do
			drillDownSetHighLow(firstChildren[i])
		end
	end

	local function recalculate()
		internalChange = true

		local percentFrame = 0
		if scrollbar.Position.Y.Scale &gt; 0 then
			if scrollbar.Visible then
				percentFrame = scrollbar.Position.Y.Scale/((scrollTrack.AbsoluteSize.Y - scrollbar.AbsoluteSize.Y)/scrollTrack.AbsoluteSize.Y)
			else
				percentFrame = 0
			end
		end
		if percentFrame &gt; 0.99 then percentFrame = 1 end

		local hiddenYAmount = (scrollingFrame.AbsoluteSize.Y - (highY - lowY)) * percentFrame
		
		local guiChildren = scrollingFrame:GetChildren()
		for i = 1, #guiChildren do
			if guiChildren[i] ~= controlFrame then
				guiChildren[i].Position = UDim2.new(guiChildren[i].Position.X.Scale,guiChildren[i].Position.X.Offset,
					0, math.ceil(guiChildren[i].AbsolutePosition.Y) - math.ceil(lowY) + hiddenYAmount)
			end
		end

		lowY = nil
		highY = nil
		resetHighLow()
		internalChange = false
	end

	local function setSliderSizeAndPosition()
		if not highY or not lowY then return end

		local totalYSpan = math.abs(highY - lowY)
		if totalYSpan == 0 then
			scrollbar.Visible = false
			scrollDownButton.Visible = false
			scrollUpButton.Visible = false

			if dragCon then dragCon:disconnect() dragCon = nil end
			if upCon then upCon:disconnect() upCon = nil end
			return
		end

		local percentShown = scrollingFrame.AbsoluteSize.Y/totalYSpan
		if percentShown &gt;= 1 then
			scrollbar.Visible = false
			scrollDownButton.Visible = false
			scrollUpButton.Visible = false
			recalculate()
		else
			scrollbar.Visible = true
			scrollDownButton.Visible = true
			scrollUpButton.Visible = true

			scrollbar.Size = UDim2.new(scrollbar.Size.X.Scale,scrollbar.Size.X.Offset,percentShown,0)
		end

		local percentPosition = (scrollingFrame.AbsolutePosition.Y - lowY)/totalYSpan
		scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,percentPosition,-scrollbar.AbsoluteSize.X/2)

		if scrollbar.AbsolutePosition.y &lt; scrollTrack.AbsolutePosition.y then
			scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,0,0)
		end

		if (scrollbar.AbsolutePosition.y + scrollbar.AbsoluteSize.Y) &gt; (scrollTrack.AbsolutePosition.y + scrollTrack.AbsoluteSize.y) then
			local relativeSize = scrollbar.AbsoluteSize.Y/scrollTrack.AbsoluteSize.Y
			scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,1 - relativeSize,0)
		end
	end
	
	local buttonScrollAmountPixels = 7
	local reentrancyGuardScrollUp = false
	local function doScrollUp()
		if reentrancyGuardScrollUp then return end
		
		reentrancyGuardScrollUp = true
			if positionScrollBar(0,scrollbar.AbsolutePosition.Y - buttonScrollAmountPixels,0) then
				recalculate()
			end
		reentrancyGuardScrollUp = false
	end
	
	local reentrancyGuardScrollDown = false
	local function doScrollDown()
		if reentrancyGuardScrollDown then return end
		
		reentrancyGuardScrollDown = true
			if positionScrollBar(0,scrollbar.AbsolutePosition.Y + buttonScrollAmountPixels,0) then
				recalculate()
			end
		reentrancyGuardScrollDown = false
	end

	local function scrollUp(mouseYPos)
		if scrollUpButton.Active then
			scrollStamp = tick()
			local current = scrollStamp
			local upCon
			upCon = mouseDrag.MouseButton1Up:connect(function()
				scrollStamp = tick()
				mouseDrag.Parent = nil
				upCon:disconnect()
			end)
			mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
			doScrollUp()
			wait(0.2)
			local t = tick()
			local w = 0.1
			while scrollStamp == current do
				doScrollUp()
				if mouseYPos and mouseYPos &gt; scrollbar.AbsolutePosition.y then
					break
				end
				if not scrollUpButton.Active then break end
				if tick()-t &gt; 5 then
					w = 0
				elseif tick()-t &gt; 2 then
					w = 0.06
				end
				wait(w)
			end
		end
	end

	local function scrollDown(mouseYPos)
		if scrollDownButton.Active then
			scrollStamp = tick()
			local current = scrollStamp
			local downCon
			downCon = mouseDrag.MouseButton1Up:connect(function()
				scrollStamp = tick()
				mouseDrag.Parent = nil
				downCon:disconnect()
			end)
			mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
			doScrollDown()
			wait(0.2)
			local t = tick()
			local w = 0.1
			while scrollStamp == current do
				doScrollDown()
				if mouseYPos and mouseYPos &lt; (scrollbar.AbsolutePosition.y + scrollbar.AbsoluteSize.x) then
					break
				end
				if not scrollDownButton.Active then break end
				if tick()-t &gt; 5 then
					w = 0
				elseif tick()-t &gt; 2 then
					w = 0.06
				end
				wait(w)
			end
		end
	end
	
	scrollbar.MouseButton1Down:connect(function(x,y)
		if scrollbar.Active then
			scrollStamp = tick()
			local mouseOffset = y - scrollbar.AbsolutePosition.y
			if dragCon then dragCon:disconnect() dragCon = nil end
			if upCon then upCon:disconnect() upCon = nil end
			local prevY = y
			local reentrancyGuardMouseScroll = false
			dragCon = mouseDrag.MouseMoved:connect(function(x,y)
				if reentrancyGuardMouseScroll then return end
				
				reentrancyGuardMouseScroll = true
					if positionScrollBar(x,y,mouseOffset) then
						recalculate()
					end
				reentrancyGuardMouseScroll = false
				
			end)
			upCon = mouseDrag.MouseButton1Up:connect(function()
				scrollStamp = tick()
				mouseDrag.Parent = nil
				dragCon:disconnect(); dragCon = nil
				upCon:disconnect(); drag = nil
			end)
			mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
		end
	end)

	local scrollMouseCount = 0

	scrollUpButton.MouseButton1Down:connect(function()
		scrollUp()
	end)
	scrollUpButton.MouseButton1Up:connect(function()
		scrollStamp = tick()
	end)

	scrollDownButton.MouseButton1Up:connect(function()
		scrollStamp = tick()
	end)
	scrollDownButton.MouseButton1Down:connect(function()
		 scrollDown()
	end)
		
	scrollbar.MouseButton1Up:connect(function()
		scrollStamp = tick()
	end)
	
	local function heightCheck(instance)
		if highY and (instance.AbsolutePosition.Y + instance.AbsoluteSize.Y) &gt; highY then
			highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
		elseif not highY then
			highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
		end
		setSliderSizeAndPosition()
	end
	
	local function highLowRecheck()
		local oldLowY = lowY
		local oldHighY = highY
		lowY = nil
		highY = nil
		resetHighLow()

		if (lowY ~= oldLowY) or (highY ~= oldHighY) then
			setSliderSizeAndPosition()
		end
	end

	local function descendantChanged(this, prop)
		if internalChange then return end
		if not this.Visible then return end

		if prop == "Size" or prop == "Position" then
			wait()
			highLowRecheck()
		end
	end

	scrollingFrame.DescendantAdded:connect(function(instance)
		if not instance:IsA("GuiObject") then return end

		if instance.Visible then
			wait() -- wait a heartbeat for sizes to reconfig
			highLowRecheck()
		end

		descendantsChangeConMap[instance] = instance.Changed:connect(function(prop) descendantChanged(instance, prop) end)
	end)

	scrollingFrame.DescendantRemoving:connect(function(instance)
		if not instance:IsA("GuiObject") then return end
		if descendantsChangeConMap[instance] then
			descendantsChangeConMap[instance]:disconnect()
			descendantsChangeConMap[instance] = nil
		end
		wait() -- wait a heartbeat for sizes to reconfig
		highLowRecheck()
	end)
	
	scrollingFrame.Changed:connect(function(prop)
		if prop == "AbsoluteSize" then
			if not highY or not lowY then return end

			highLowRecheck()
			setSliderSizeAndPosition()
		end
	end)

	return scrollingFrame, controlFrame
end

t.CreateScrollingFrame = function(orderList,scrollStyle)
	local frame = Instance.new("Frame")
	frame.Name = "ScrollingFrame"
	frame.BackgroundTransparency = 1
	frame.Size = UDim2.new(1,0,1,0)
	
	local scrollUpButton = Instance.new("ImageButton")
	scrollUpButton.Name = "ScrollUpButton"
	scrollUpButton.BackgroundTransparency = 1
	scrollUpButton.Image = "rbxasset://textures/ui/scrollbuttonUp.png"
	scrollUpButton.Size = UDim2.new(0,17,0,17) 

	
	local scrollDownButton = Instance.new("ImageButton")
	scrollDownButton.Name = "ScrollDownButton"
	scrollDownButton.BackgroundTransparency = 1
	scrollDownButton.Image = "rbxasset://textures/ui/scrollbuttonDown.png"
	scrollDownButton.Size = UDim2.new(0,17,0,17) 
	
	local scrollbar = Instance.new("ImageButton")
	scrollbar.Name = "ScrollBar"
	scrollbar.Image = "rbxasset://textures/ui/scrollbar.png"
	scrollbar.BackgroundTransparency = 1
	scrollbar.Size = UDim2.new(0, 18, 0, 150)

	local scrollStamp = 0
		
	local scrollDrag = Instance.new("ImageButton")
	scrollDrag.Image = "http://www.roblox.com/asset/?id=61367186"
	scrollDrag.Size = UDim2.new(1, 0, 0, 16)
	scrollDrag.BackgroundTransparency = 1
	scrollDrag.Name = "ScrollDrag"
	scrollDrag.Active = true
	scrollDrag.Parent = scrollbar
	
	local mouseDrag = Instance.new("ImageButton")
	mouseDrag.Active = false
	mouseDrag.Size = UDim2.new(1.5, 0, 1.5, 0)
	mouseDrag.AutoButtonColor = false
	mouseDrag.BackgroundTransparency = 1
	mouseDrag.Name = "mouseDrag"
	mouseDrag.Position = UDim2.new(-0.25, 0, -0.25, 0)
	mouseDrag.ZIndex = 10

	local style = "simple"
	if scrollStyle and tostring(scrollStyle) then
		style = scrollStyle
	end
	
	local scrollPosition = 1
	local rowSize = 0
	local howManyDisplayed = 0
		
	local layoutGridScrollBar = function()
		howManyDisplayed = 0
		local guiObjects = {}
		if orderList then
			for i, child in ipairs(orderList) do
				if child.Parent == frame then
					table.insert(guiObjects, child)
				end
			end
		else
			local children = frame:GetChildren()
			if children then
				for i, child in ipairs(children) do 
					if child:IsA("GuiObject") then
						table.insert(guiObjects, child)
					end
				end
			end
		end
		if #guiObjects == 0 then
			scrollUpButton.Active = false
			scrollDownButton.Active = false
			scrollDrag.Active = false
			scrollPosition = 1
			return
		end

		if scrollPosition &gt; #guiObjects then
			scrollPosition = #guiObjects
		end
		
		if scrollPosition &lt; 1 then scrollPosition = 1 end
		
		local totalPixelsY = frame.AbsoluteSize.Y
		local pixelsRemainingY = frame.AbsoluteSize.Y
		
		local totalPixelsX  = frame.AbsoluteSize.X
		
		local xCounter = 0
		local rowSizeCounter = 0
		local setRowSize = true

		local pixelsBelowScrollbar = 0
		local pos = #guiObjects
		
		local currentRowY = 0

		pos = scrollPosition
		--count up from current scroll position to fill out grid
		while pos &lt;= #guiObjects and pixelsBelowScrollbar &lt; totalPixelsY do
			xCounter = xCounter + guiObjects[pos].AbsoluteSize.X
			--previous pos was the end of a row
			if xCounter &gt;= totalPixelsX then
				pixelsBelowScrollbar = pixelsBelowScrollbar + currentRowY
				currentRowY = 0
				xCounter = guiObjects[pos].AbsoluteSize.X
			end
			if guiObjects[pos].AbsoluteSize.Y &gt; currentRowY then
				currentRowY = guiObjects[pos].AbsoluteSize.Y
			end
			pos = pos + 1
		end
		--Count wherever current row left off
		pixelsBelowScrollbar = pixelsBelowScrollbar + currentRowY
		currentRowY = 0
		
		pos = scrollPosition - 1
		xCounter = 0
		
		--objects with varying X,Y dimensions can rarely cause minor errors
		--rechecking every new scrollPosition is necessary to avoid 100% of errors
		
		--count backwards from current scrollPosition to see if we can add more rows
		while pixelsBelowScrollbar + currentRowY &lt; totalPixelsY and pos &gt;= 1 do
			xCounter = xCounter + guiObjects[pos].AbsoluteSize.X
			rowSizeCounter = rowSizeCounter + 1
			if xCounter &gt;= totalPixelsX then
				rowSize = rowSizeCounter - 1
				rowSizeCounter = 0
				xCounter = guiObjects[pos].AbsoluteSize.X
				if pixelsBelowScrollbar + currentRowY &lt;= totalPixelsY then
					--It fits, so back up our scroll position
					pixelsBelowScrollbar = pixelsBelowScrollbar + currentRowY
					if scrollPosition &lt;= rowSize then
						scrollPosition = 1 
						break
					else
						scrollPosition = scrollPosition - rowSize
					end
					currentRowY = 0
				else
					break
				end
			end
			
			if guiObjects[pos].AbsoluteSize.Y &gt; currentRowY then
				currentRowY = guiObjects[pos].AbsoluteSize.Y
			end

			pos = pos - 1
		end
		
		--Do check last time if pos = 0
		if (pos == 0) and (pixelsBelowScrollbar + currentRowY &lt;= totalPixelsY) then
			scrollPosition = 1
		end

		xCounter = 0
		--pos = scrollPosition
		rowSizeCounter = 0
		setRowSize = true
		local lastChildSize = 0
		
		local xOffset,yOffset = 0
		if guiObjects[1] then
			yOffset = math.ceil(math.floor(math.fmod(totalPixelsY,guiObjects[1].AbsoluteSize.X))/2)
			xOffset = math.ceil(math.floor(math.fmod(totalPixelsX,guiObjects[1].AbsoluteSize.Y))/2)
		end
		
		for i, child in ipairs(guiObjects) do
			if i &lt; scrollPosition then
				--print("Hiding " .. child.Name)
				child.Visible = false
			else
				if pixelsRemainingY &lt; 0 then
					--print("Out of Space " .. child.Name)
					child.Visible = false
				else
					--print("Laying out " .. child.Name)
					--GuiObject
					if setRowSize then rowSizeCounter = rowSizeCounter + 1 end
					if xCounter + child.AbsoluteSize.X &gt;= totalPixelsX then
						if setRowSize then
							rowSize = rowSizeCounter - 1
							setRowSize = false
						end
						xCounter = 0
						pixelsRemainingY = pixelsRemainingY - child.AbsoluteSize.Y
					end
					child.Position = UDim2.new(child.Position.X.Scale,xCounter + xOffset, 0, totalPixelsY - pixelsRemainingY + yOffset)
					xCounter = xCounter + child.AbsoluteSize.X
					child.Visible = ((pixelsRemainingY - child.AbsoluteSize.Y) &gt;= 0)
					if child.Visible then
						howManyDisplayed = howManyDisplayed + 1
					end
					lastChildSize = child.AbsoluteSize				
				end
			end
		end

		scrollUpButton.Active = (scrollPosition &gt; 1)
		if lastChildSize == 0 then 
			scrollDownButton.Active = false
		else
			scrollDownButton.Active = ((pixelsRemainingY - lastChildSize.Y) &lt; 0)
		end
		scrollDrag.Active = #guiObjects &gt; howManyDisplayed
		scrollDrag.Visible = scrollDrag.Active
	end



	local layoutSimpleScrollBar = function()
		local guiObjects = {}	
		howManyDisplayed = 0
		
		if orderList then
			for i, child in ipairs(orderList) do
				if child.Parent == frame then
					table.insert(guiObjects, child)
				end
			end
		else
			local children = frame:GetChildren()
			if children then
				for i, child in ipairs(children) do 
					if child:IsA("GuiObject") then
						table.insert(guiObjects, child)
					end
				end
			end
		end
		if #guiObjects == 0 then
			scrollUpButton.Active = false
			scrollDownButton.Active = false
			scrollDrag.Active = false
			scrollPosition = 1
			return
		end

		if scrollPosition &gt; #guiObjects then
			scrollPosition = #guiObjects
		end
		
		local totalPixels = frame.AbsoluteSize.Y
		local pixelsRemaining = frame.AbsoluteSize.Y

		local pixelsBelowScrollbar = 0
		local pos = #guiObjects
		while pixelsBelowScrollbar &lt; totalPixels and pos &gt;= 1 do
			if pos &gt;= scrollPosition then
				pixelsBelowScrollbar = pixelsBelowScrollbar + guiObjects[pos].AbsoluteSize.Y
			else
				if pixelsBelowScrollbar + guiObjects[pos].AbsoluteSize.Y &lt;= totalPixels then
					--It fits, so back up our scroll position
					pixelsBelowScrollbar = pixelsBelowScrollbar + guiObjects[pos].AbsoluteSize.Y
					if scrollPosition &lt;= 1 then
						scrollPosition = 1
						break
					else
						--local ("Backing up ScrollPosition from -- " ..scrollPosition)
						scrollPosition = scrollPosition - 1
					end
				else
					break
				end
			end
			pos = pos - 1
		end

		pos = scrollPosition
		for i, child in ipairs(guiObjects) do
			if i &lt; scrollPosition then
				--print("Hiding " .. child.Name)
				child.Visible = false
			else
				if pixelsRemaining &lt; 0 then
					--print("Out of Space " .. child.Name)
					child.Visible = false
				else
					--print("Laying out " .. child.Name)
					--GuiObject
					child.Position = UDim2.new(child.Position.X.Scale, child.Position.X.Offset, 0, totalPixels - pixelsRemaining)
					pixelsRemaining = pixelsRemaining - child.AbsoluteSize.Y
					if  (pixelsRemaining &gt;= 0) then
						child.Visible = true
						howManyDisplayed = howManyDisplayed + 1
					else
						child.Visible = false
					end		
				end
			end
		end
		scrollUpButton.Active = (scrollPosition &gt; 1)
		scrollDownButton.Active = (pixelsRemaining &lt; 0)
		scrollDrag.Active = #guiObjects &gt; howManyDisplayed
		scrollDrag.Visible = scrollDrag.Active
	end
	
		
	local moveDragger = function()	
		local guiObjects = 0
		local children = frame:GetChildren()
		if children then
			for i, child in ipairs(children) do 
				if child:IsA("GuiObject") then
					guiObjects = guiObjects + 1
				end
			end
		end
		
		if not scrollDrag.Parent then return end
		
		local dragSizeY = scrollDrag.Parent.AbsoluteSize.y * (1/(guiObjects - howManyDisplayed + 1))
		if dragSizeY &lt; 16 then dragSizeY = 16 end
		scrollDrag.Size = UDim2.new(scrollDrag.Size.X.Scale,scrollDrag.Size.X.Offset,scrollDrag.Size.Y.Scale,dragSizeY)

		local relativeYPos = (scrollPosition - 1)/(guiObjects - (howManyDisplayed))
		if relativeYPos &gt; 1 then relativeYPos = 1
		elseif relativeYPos &lt; 0 then relativeYPos = 0 end
		local absYPos = 0
		
		if relativeYPos ~= 0 then
			absYPos = (relativeYPos * scrollbar.AbsoluteSize.y) - (relativeYPos * scrollDrag.AbsoluteSize.y)
		end
		
		scrollDrag.Position = UDim2.new(scrollDrag.Position.X.Scale,scrollDrag.Position.X.Offset,scrollDrag.Position.Y.Scale,absYPos)
	end

	local reentrancyGuard = false
	local recalculate = function()
		if reentrancyGuard then
			return
		end
		reentrancyGuard = true
		wait()
		local success, err = nil
		if style == "grid" then
			success, err = pcall(function() layoutGridScrollBar() end)
		elseif style == "simple" then
			success, err = pcall(function() layoutSimpleScrollBar() end)
		end
		if not success then print(err) end
		moveDragger()
		reentrancyGuard = false
	end
	
	local doScrollUp = function()
		scrollPosition = (scrollPosition) - rowSize
		if scrollPosition &lt; 1 then scrollPosition = 1 end
		recalculate(nil)
	end
	
	local doScrollDown = function()
		scrollPosition = (scrollPosition) + rowSize
		recalculate(nil)
	end

	local scrollUp = function(mouseYPos)
		if scrollUpButton.Active then
			scrollStamp = tick()
			local current = scrollStamp
			local upCon
			upCon = mouseDrag.MouseButton1Up:connect(function()
				scrollStamp = tick()
				mouseDrag.Parent = nil
				upCon:disconnect()
			end)
			mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
			doScrollUp()
			wait(0.2)
			local t = tick()
			local w = 0.1
			while scrollStamp == current do
				doScrollUp()
				if mouseYPos and mouseYPos &gt; scrollDrag.AbsolutePosition.y then
					break
				end
				if not scrollUpButton.Active then break end
				if tick()-t &gt; 5 then
					w = 0
				elseif tick()-t &gt; 2 then
					w = 0.06
				end
				wait(w)
			end
		end
	end

	local scrollDown = function(mouseYPos)
		if scrollDownButton.Active then
			scrollStamp = tick()
			local current = scrollStamp
			local downCon
			downCon = mouseDrag.MouseButton1Up:connect(function()
				scrollStamp = tick()
				mouseDrag.Parent = nil
				downCon:disconnect()
			end)
			mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
			doScrollDown()
			wait(0.2)
			local t = tick()
			local w = 0.1
			while scrollStamp == current do
				doScrollDown()
				if mouseYPos and mouseYPos &lt; (scrollDrag.AbsolutePosition.y + scrollDrag.AbsoluteSize.x) then
					break
				end
				if not scrollDownButton.Active then break end
				if tick()-t &gt; 5 then
					w = 0
				elseif tick()-t &gt; 2 then
					w = 0.06
				end
				wait(w)
			end
		end
	end
	
	local y = 0
	scrollDrag.MouseButton1Down:connect(function(x,y)
		if scrollDrag.Active then
			scrollStamp = tick()
			local mouseOffset = y - scrollDrag.AbsolutePosition.y
			local dragCon
			local upCon
			dragCon = mouseDrag.MouseMoved:connect(function(x,y)
				local barAbsPos = scrollbar.AbsolutePosition.y
				local barAbsSize = scrollbar.AbsoluteSize.y
				
				local dragAbsSize = scrollDrag.AbsoluteSize.y
				local barAbsOne = barAbsPos + barAbsSize - dragAbsSize
				y = y - mouseOffset
				y = y &lt; barAbsPos and barAbsPos or y &gt; barAbsOne and barAbsOne or y
				y = y - barAbsPos
				
				local guiObjects = 0
				local children = frame:GetChildren()
				if children then
					for i, child in ipairs(children) do 
						if child:IsA("GuiObject") then
							guiObjects = guiObjects + 1
						end
					end
				end
				
				local doublePercent = y/(barAbsSize-dragAbsSize)
				local rowDiff = rowSize
				local totalScrollCount = guiObjects - (howManyDisplayed - 1)
				local newScrollPosition = math.floor((doublePercent * totalScrollCount) + 0.5) + rowDiff
				if newScrollPosition &lt; scrollPosition then
					rowDiff = -rowDiff
				end
				
				if newScrollPosition &lt; 1 then
					newScrollPosition = 1
				end
				
				scrollPosition = newScrollPosition
				recalculate(nil)
			end)
			upCon = mouseDrag.MouseButton1Up:connect(function()
				scrollStamp = tick()
				mouseDrag.Parent = nil
				dragCon:disconnect(); dragCon = nil
				upCon:disconnect(); drag = nil
			end)
			mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
		end
	end)

	local scrollMouseCount = 0

	scrollUpButton.MouseButton1Down:connect(
		function()
			scrollUp()
		end)
	scrollUpButton.MouseButton1Up:connect(function()
		scrollStamp = tick()
	end)


	scrollDownButton.MouseButton1Up:connect(function()
		scrollStamp = tick()
	end)
	scrollDownButton.MouseButton1Down:connect(
		function()
			scrollDown()	
		end)
		
	scrollbar.MouseButton1Up:connect(function()
		scrollStamp = tick()
	end)
	scrollbar.MouseButton1Down:connect(
		function(x,y)
			if y &gt; (scrollDrag.AbsoluteSize.y + scrollDrag.AbsolutePosition.y) then
				scrollDown(y)
			elseif y &lt; (scrollDrag.AbsolutePosition.y) then
				scrollUp(y)
			end
		end)


	frame.ChildAdded:connect(function()
		recalculate(nil)
	end)

	frame.ChildRemoved:connect(function()
		recalculate(nil)
	end)
	
	frame.Changed:connect(
		function(prop)
			if prop == "AbsoluteSize" then
				--Wait a heartbeat for it to sync in
				recalculate(nil)
			end
		end)
	frame.AncestryChanged:connect(function() recalculate(nil) end)

	return frame, scrollUpButton, scrollDownButton, recalculate, scrollbar
end
local function binaryGrow(min, max, fits)
	if min &gt; max then
		return min
	end
	local biggestLegal = min

	while min &lt;= max do
		local mid = min + math.floor((max - min) / 2)
		if fits(mid) and (biggestLegal == nil or biggestLegal &lt; mid) then
			biggestLegal = mid
			
			--Try growing
			min = mid + 1
		else
			--Doesn't fit, shrink
			max = mid - 1
		end
	end
	return biggestLegal
end


local function binaryShrink(min, max, fits)
	if min &gt; max then
		return min
	end
	local smallestLegal = max

	while min &lt;= max do
		local mid = min + math.floor((max - min) / 2)
		if fits(mid) and (smallestLegal == nil or smallestLegal &gt; mid) then
			smallestLegal = mid
			
			--It fits, shrink
			max = mid - 1			
		else
			--Doesn't fit, grow
			min = mid + 1
		end
	end
	return smallestLegal
end


local function getGuiOwner(instance)
	while instance ~= nil do
		if instance:IsA("ScreenGui") or instance:IsA("BillboardGui")  then
			return instance
		end
		instance = instance.Parent
	end
	return nil
end

t.AutoTruncateTextObject = function(textLabel)
	local text = textLabel.Text

	local fullLabel = textLabel:Clone()
	fullLabel.Name = "Full" .. textLabel.Name 
	fullLabel.BorderSizePixel = 0
	fullLabel.BackgroundTransparency = 0
	fullLabel.Text = text
	fullLabel.TextXAlignment = Enum.TextXAlignment.Center
	fullLabel.Position = UDim2.new(0,-3,0,0)
	fullLabel.Size = UDim2.new(0,100,1,0)
	fullLabel.Visible = false
	fullLabel.Parent = textLabel

	local shortText = nil
	local mouseEnterConnection = nil
	local mouseLeaveConnection= nil

	local checkForResize = function()
		if getGuiOwner(textLabel) == nil then
			return
		end
		textLabel.Text = text
		if textLabel.TextFits then 
			--Tear down the rollover if it is active
			if mouseEnterConnection then
				mouseEnterConnection:disconnect()
				mouseEnterConnection = nil
			end
			if mouseLeaveConnection then
				mouseLeaveConnection:disconnect()
				mouseLeaveConnection = nil
			end
		else
			local len = string.len(text)
			textLabel.Text = text .. "~"

			--Shrink the text
			local textSize = binaryGrow(0, len, 
				function(pos)
					if pos == 0 then
						textLabel.Text = "~"
					else
						textLabel.Text = string.sub(text, 1, pos) .. "~"
					end
					return textLabel.TextFits
				end)
			shortText = string.sub(text, 1, textSize) .. "~"
			textLabel.Text = shortText
			
			--Make sure the fullLabel fits
			if not fullLabel.TextFits then
				--Already too small, grow it really bit to start
				fullLabel.Size = UDim2.new(0, 10000, 1, 0)
			end
			
			--Okay, now try to binary shrink it back down
			local fullLabelSize = binaryShrink(textLabel.AbsoluteSize.X,fullLabel.AbsoluteSize.X, 
				function(size)
					fullLabel.Size = UDim2.new(0, size, 1, 0)
					return fullLabel.TextFits
				end)
			fullLabel.Size = UDim2.new(0,fullLabelSize+6,1,0)

			--Now setup the rollover effects, if they are currently off
			if mouseEnterConnection == nil then
				mouseEnterConnection = textLabel.MouseEnter:connect(
					function()
						fullLabel.ZIndex = textLabel.ZIndex + 1
						fullLabel.Visible = true
						--textLabel.Text = ""
					end)
			end
			if mouseLeaveConnection == nil then
				mouseLeaveConnection = textLabel.MouseLeave:connect(
					function()
						fullLabel.Visible = false
						--textLabel.Text = shortText
					end)
			end
		end
	end
	textLabel.AncestryChanged:connect(checkForResize)
	textLabel.Changed:connect(
		function(prop) 
			if prop == "AbsoluteSize" then 
				checkForResize() 	
			end 
		end)

	checkForResize()

	local function changeText(newText)
		text = newText
		fullLabel.Text = text
		checkForResize()
	end

	return textLabel, changeText
end

local function TransitionTutorialPages(fromPage, toPage, transitionFrame, currentPageValue)	
	if fromPage then
		fromPage.Visible = false
		if transitionFrame.Visible == false then
			transitionFrame.Size = fromPage.Size
			transitionFrame.Position = fromPage.Position
		end
	else
		if transitionFrame.Visible == false then
			transitionFrame.Size = UDim2.new(0.0,50,0.0,50)
			transitionFrame.Position = UDim2.new(0.5,-25,0.5,-25)
		end
	end
	transitionFrame.Visible = true
	currentPageValue.Value = nil

	local newsize, newPosition
	if toPage then
		--Make it visible so it resizes
		toPage.Visible = true

		newSize = toPage.Size
		newPosition = toPage.Position

		toPage.Visible = false
	else
		newSize = UDim2.new(0.0,50,0.0,50)
		newPosition = UDim2.new(0.5,-25,0.5,-25)
	end
	transitionFrame:TweenSizeAndPosition(newSize, newPosition, Enum.EasingDirection.InOut, Enum.EasingStyle.Quad, 0.3, true,
		function(state)
			if state == Enum.TweenStatus.Completed then
				transitionFrame.Visible = false
				if toPage then
					toPage.Visible = true
					currentPageValue.Value = toPage
				end
			end
		end)
end

t.CreateTutorial = function(name, tutorialKey, createButtons)
	local frame = Instance.new("Frame")
	frame.Name = "Tutorial-" .. name
	frame.BackgroundTransparency = 1
	frame.Size = UDim2.new(0.6, 0, 0.6, 0)
	frame.Position = UDim2.new(0.2, 0, 0.2, 0)

	local transitionFrame = Instance.new("Frame")
	transitionFrame.Name = "TransitionFrame"
	transitionFrame.Style = Enum.FrameStyle.RobloxRound
	transitionFrame.Size = UDim2.new(0.6, 0, 0.6, 0)
	transitionFrame.Position = UDim2.new(0.2, 0, 0.2, 0)
	transitionFrame.Visible = false
	transitionFrame.Parent = frame

	local currentPageValue = Instance.new("ObjectValue")
	currentPageValue.Name = "CurrentTutorialPage"
	currentPageValue.Value = nil
	currentPageValue.Parent = frame

	local boolValue = Instance.new("BoolValue")
	boolValue.Name = "Buttons"
	boolValue.Value = createButtons
	boolValue.Parent = frame

	local pages = Instance.new("Frame")
	pages.Name = "Pages"
	pages.BackgroundTransparency = 1
	pages.Size = UDim2.new(1,0,1,0)
	pages.Parent = frame

	local function getVisiblePageAndHideOthers()
		local visiblePage = nil
		local children = pages:GetChildren()
		if children then
			for i,child in ipairs(children) do
				if child.Visible then
					if visiblePage then
						child.Visible = false
					else
						visiblePage = child
					end
				end
			end
		end
		return visiblePage
	end

	local showTutorial = function(alwaysShow)
		if alwaysShow or UserSettings().GameSettings:GetTutorialState(tutorialKey) == false then
			print("Showing tutorial-",tutorialKey)
			local currentTutorialPage = getVisiblePageAndHideOthers()

			local firstPage = pages:FindFirstChild("TutorialPage1")
			if firstPage then
				TransitionTutorialPages(currentTutorialPage, firstPage, transitionFrame, currentPageValue)	
			else
				error("Could not find TutorialPage1")
			end
		end
	end

	local dismissTutorial = function()
		local currentTutorialPage = getVisiblePageAndHideOthers()

		if currentTutorialPage then
			TransitionTutorialPages(currentTutorialPage, nil, transitionFrame, currentPageValue)
		end

		UserSettings().GameSettings:SetTutorialState(tutorialKey, true)
	end

	local gotoPage = function(pageNum)
		local page = pages:FindFirstChild("TutorialPage" .. pageNum)
		local currentTutorialPage = getVisiblePageAndHideOthers()
		TransitionTutorialPages(currentTutorialPage, page, transitionFrame, currentPageValue)
	end

	return frame, showTutorial, dismissTutorial, gotoPage
end 

local function CreateBasicTutorialPage(name, handleResize, skipTutorial, giveDoneButton)
	local frame = Instance.new("Frame")
	frame.Name = "TutorialPage"
	frame.Style = Enum.FrameStyle.RobloxRound
	frame.Size = UDim2.new(0.6, 0, 0.6, 0)
	frame.Position = UDim2.new(0.2, 0, 0.2, 0)
	frame.Visible = false
	
	local frameHeader = Instance.new("TextLabel")
	frameHeader.Name = "Header"
	frameHeader.Text = name
	frameHeader.BackgroundTransparency = 1
	frameHeader.FontSize = Enum.FontSize.Size24
	frameHeader.Font = Enum.Font.ArialBold
	frameHeader.TextColor3 = Color3.new(1,1,1)
	frameHeader.TextXAlignment = Enum.TextXAlignment.Center
	frameHeader.TextWrap = true
	frameHeader.Size = UDim2.new(1,-55, 0, 22)
	frameHeader.Position = UDim2.new(0,0,0,0)
	frameHeader.Parent = frame

	local skipButton = Instance.new("ImageButton")
	skipButton.Name = "SkipButton"
	skipButton.AutoButtonColor = false
	skipButton.BackgroundTransparency = 1
	skipButton.Image = "rbxasset://textures/ui/closeButton.png"
	skipButton.MouseButton1Click:connect(function()
		skipTutorial()
	end)
	skipButton.MouseEnter:connect(function()
		skipButton.Image = "rbxasset://textures/ui/closeButton_dn.png"
	end)
	skipButton.MouseLeave:connect(function()
		skipButton.Image = "rbxasset://textures/ui/closeButton.png"
	end)
	skipButton.Size = UDim2.new(0, 25, 0, 25)
	skipButton.Position = UDim2.new(1, -25, 0, 0)
	skipButton.Parent = frame
	
	
	if giveDoneButton then
		local doneButton = Instance.new("TextButton")
		doneButton.Name = "DoneButton"
		doneButton.Style = Enum.ButtonStyle.RobloxButtonDefault
		doneButton.Text = "Done"
		doneButton.TextColor3 = Color3.new(1,1,1)
		doneButton.Font = Enum.Font.ArialBold
		doneButton.FontSize = Enum.FontSize.Size18
		doneButton.Size = UDim2.new(0,100,0,50)
		doneButton.Position = UDim2.new(0.5,-50,1,-50)
		
		if skipTutorial then
			doneButton.MouseButton1Click:connect(function() skipTutorial() end)
		end
		
		doneButton.Parent = frame
	end

	local innerFrame = Instance.new("Frame")
	innerFrame.Name = "ContentFrame"
	innerFrame.BackgroundTransparency = 1
	innerFrame.Position = UDim2.new(0,0,0,25)
	innerFrame.Parent = frame

	local nextButton = Instance.new("TextButton")
	nextButton.Name = "NextButton"
	nextButton.Text = "Next"
	nextButton.TextColor3 = Color3.new(1,1,1)
	nextButton.Font = Enum.Font.Arial
	nextButton.FontSize = Enum.FontSize.Size18
	nextButton.Style = Enum.ButtonStyle.RobloxButtonDefault
	nextButton.Size = UDim2.new(0,80, 0, 32)
	nextButton.Position = UDim2.new(0.5, 5, 1, -32)
	nextButton.Active = false
	nextButton.Visible = false
	nextButton.Parent = frame

	local prevButton = Instance.new("TextButton")
	prevButton.Name = "PrevButton"
	prevButton.Text = "Previous"
	prevButton.TextColor3 = Color3.new(1,1,1)
	prevButton.Font = Enum.Font.Arial
	prevButton.FontSize = Enum.FontSize.Size18
	prevButton.Style = Enum.ButtonStyle.RobloxButton
	prevButton.Size = UDim2.new(0,80, 0, 32)
	prevButton.Position = UDim2.new(0.5, -85, 1, -32)
	prevButton.Active = false
	prevButton.Visible = false
	prevButton.Parent = frame

	if giveDoneButton then
		innerFrame.Size = UDim2.new(1,0,1,-75)
	else
		innerFrame.Size = UDim2.new(1,0,1,-22)
	end

	local parentConnection = nil

	local function basicHandleResize()
		if frame.Visible and frame.Parent then
			local maxSize = math.min(frame.Parent.AbsoluteSize.X, frame.Parent.AbsoluteSize.Y)
			handleResize(200,maxSize)
		end
	end

	frame.Changed:connect(
		function(prop)
			if prop == "Parent" then
				if parentConnection ~= nil then
					parentConnection:disconnect()
					parentConnection = nil
				end
				if frame.Parent and frame.Parent:IsA("GuiObject") then
					parentConnection = frame.Parent.Changed:connect(
						function(parentProp)
							if parentProp == "AbsoluteSize" then
								wait()
								basicHandleResize()
							end
						end)
					basicHandleResize()
				end
			end

			if prop == "Visible" then 
				basicHandleResize()
			end
		end)

	return frame, innerFrame
end

t.CreateTextTutorialPage = function(name, text, skipTutorialFunc)
	local frame = nil
	local contentFrame = nil

	local textLabel = Instance.new("TextLabel")
	textLabel.BackgroundTransparency = 1
	textLabel.TextColor3 = Color3.new(1,1,1)
	textLabel.Text = text
	textLabel.TextWrap = true
	textLabel.TextXAlignment = Enum.TextXAlignment.Left
	textLabel.TextYAlignment = Enum.TextYAlignment.Center
	textLabel.Font = Enum.Font.Arial
	textLabel.FontSize = Enum.FontSize.Size14
	textLabel.Size = UDim2.new(1,0,1,0)

	local function handleResize(minSize, maxSize)
		size = binaryShrink(minSize, maxSize,
			function(size)
				frame.Size = UDim2.new(0, size, 0, size)
				return textLabel.TextFits
			end)
		frame.Size = UDim2.new(0, size, 0, size)
		frame.Position = UDim2.new(0.5, -size/2, 0.5, -size/2)
	end

	frame, contentFrame = CreateBasicTutorialPage(name, handleResize, skipTutorialFunc)
	textLabel.Parent = contentFrame

	return frame
end

t.CreateImageTutorialPage = function(name, imageAsset, x, y, skipTutorialFunc, giveDoneButton)
	local frame = nil
	local contentFrame = nil

	local imageLabel = Instance.new("ImageLabel")
	imageLabel.BackgroundTransparency = 1
	imageLabel.Image = imageAsset
	imageLabel.Size = UDim2.new(0,x,0,y)
	imageLabel.Position = UDim2.new(0.5,-x/2,0.5,-y/2)

	local function handleResize(minSize, maxSize)
		size = binaryShrink(minSize, maxSize,
			function(size)
				return size &gt;= x and size &gt;= y
			end)
		if size &gt;= x and size &gt;= y then
			imageLabel.Size = UDim2.new(0,x, 0,y)
			imageLabel.Position = UDim2.new(0.5,-x/2, 0.5, -y/2)
		else
			if x &gt; y then
				--X is limiter, so 
				imageLabel.Size = UDim2.new(1,0,y/x,0)
				imageLabel.Position = UDim2.new(0,0, 0.5 - (y/x)/2, 0)
			else
				--Y is limiter
				imageLabel.Size = UDim2.new(x/y,0,1, 0)
				imageLabel.Position = UDim2.new(0.5-(x/y)/2, 0, 0, 0)
			end
		end
		size = size + 50
		frame.Size = UDim2.new(0, size, 0, size)
		frame.Position = UDim2.new(0.5, -size/2, 0.5, -size/2)
	end

	frame, contentFrame = CreateBasicTutorialPage(name, handleResize, skipTutorialFunc, giveDoneButton)
	imageLabel.Parent = contentFrame

	return frame
end

t.AddTutorialPage = function(tutorial, tutorialPage)
	local transitionFrame = tutorial.TransitionFrame
	local currentPageValue = tutorial.CurrentTutorialPage

	if not tutorial.Buttons.Value then
		tutorialPage.NextButton.Parent = nil
		tutorialPage.PrevButton.Parent = nil
	end

	local children = tutorial.Pages:GetChildren()
	if children and #children &gt; 0 then
		tutorialPage.Name = "TutorialPage" .. (#children+1)
		local previousPage = children[#children]
		if not previousPage:IsA("GuiObject") then
			error("All elements under Pages must be GuiObjects")
		end

		if tutorial.Buttons.Value then
			if previousPage.NextButton.Active then
				error("NextButton already Active on previousPage, please only add pages with RbxGui.AddTutorialPage function")
			end
			previousPage.NextButton.MouseButton1Click:connect(
				function()
					TransitionTutorialPages(previousPage, tutorialPage, transitionFrame, currentPageValue)
				end)
			previousPage.NextButton.Active = true
			previousPage.NextButton.Visible = true

			if tutorialPage.PrevButton.Active then
				error("PrevButton already Active on tutorialPage, please only add pages with RbxGui.AddTutorialPage function")
			end
			tutorialPage.PrevButton.MouseButton1Click:connect(
				function()
					TransitionTutorialPages(tutorialPage, previousPage, transitionFrame, currentPageValue)
				end)
			tutorialPage.PrevButton.Active = true
			tutorialPage.PrevButton.Visible = true
		end

		tutorialPage.Parent = tutorial.Pages
	else
		--First child
		tutorialPage.Name = "TutorialPage1"
		tutorialPage.Parent = tutorial.Pages
	end
end 

t.CreateSetPanel = function(userIdsForSets, objectSelected, dialogClosed, size, position, showAdminCategories, useAssetVersionId)

	if not userIdsForSets then
		error("CreateSetPanel: userIdsForSets (first arg) is nil, should be a table of number ids")
	end
	if type(userIdsForSets) ~= "table" and type(userIdsForSets) ~= "userdata" then
		error("CreateSetPanel: userIdsForSets (first arg) is of type " ..type(userIdsForSets) .. ", should be of type table or userdata")
	end
	if not objectSelected then
		error("CreateSetPanel: objectSelected (second arg) is nil, should be a callback function!")
	end
	if type(objectSelected) ~= "function" then
		error("CreateSetPanel: objectSelected (second arg) is of type " .. type(objectSelected) .. ", should be of type function!")
	end
	if dialogClosed and type(dialogClosed) ~= "function" then
		error("CreateSetPanel: dialogClosed (third arg) is of type " .. type(dialogClosed) .. ", should be of type function!")
	end
	
	if showAdminCategories == nil then -- by default, don't show beta sets
		showAdminCategories = false
	end

	local arrayPosition = 1
	local insertButtons = {}
	local insertButtonCons = {}
	local contents = nil
	local setGui = nil

	-- used for water selections
	local waterForceDirection = "NegX"
	local waterForce = "None"
	local waterGui, waterTypeChangedEvent = nil
	
	local Data = {}
	Data.CurrentCategory = nil
	Data.Category = {}
	local SetCache = {}
	
	local userCategoryButtons = nil
	
	local buttonWidth = 64
	local buttonHeight = buttonWidth
	
	local SmallThumbnailUrl = nil
	local LargeThumbnailUrl = nil
	local BaseUrl = game:GetService("ContentProvider").BaseUrl:lower()
	
	if useAssetVersionId then
		LargeThumbnailUrl = BaseUrl .. "Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=420&amp;ht=420&amp;assetversionid="
		SmallThumbnailUrl = BaseUrl .. "Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=75&amp;ht=75&amp;assetversionid="
	else
		LargeThumbnailUrl = BaseUrl .. "Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=420&amp;ht=420&amp;aid="
		SmallThumbnailUrl = BaseUrl .. "Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=75&amp;ht=75&amp;aid="
	end
		
	local function drillDownSetZIndex(parent, index)
		local children = parent:GetChildren()
		for i = 1, #children do
			if children[i]:IsA("GuiObject") then
				children[i].ZIndex = index
			end
			drillDownSetZIndex(children[i], index)
		end
	end
	
	-- for terrain stamping
	local currTerrainDropDownFrame = nil
	local terrainShapes = {"Block","Vertical Ramp","Corner Wedge","Inverse Corner Wedge","Horizontal Ramp","Auto-Wedge"}
	local terrainShapeMap = {}
	for i = 1, #terrainShapes do
		terrainShapeMap[terrainShapes[i]] = i - 1
	end	
	terrainShapeMap[terrainShapes[#terrainShapes]] = 6

	local function createWaterGui()
		local waterForceDirections = {"NegX","X","NegY","Y","NegZ","Z"}
		local waterForces = {"None", "Small", "Medium", "Strong", "Max"}

		local waterFrame = Instance.new("Frame")
		waterFrame.Name = "WaterFrame"
		waterFrame.Style = Enum.FrameStyle.RobloxSquare
		waterFrame.Size = UDim2.new(0,150,0,110)
		waterFrame.Visible = false

		local waterForceLabel = Instance.new("TextLabel")
		waterForceLabel.Name = "WaterForceLabel"
		waterForceLabel.BackgroundTransparency = 1
		waterForceLabel.Size = UDim2.new(1,0,0,12)
		waterForceLabel.Font = Enum.Font.ArialBold
		waterForceLabel.FontSize = Enum.FontSize.Size12
		waterForceLabel.TextColor3 = Color3.new(1,1,1)
		waterForceLabel.TextXAlignment = Enum.TextXAlignment.Left
		waterForceLabel.Text = "Water Force"
		waterForceLabel.Parent = waterFrame

		local waterForceDirLabel = waterForceLabel:Clone()
		waterForceDirLabel.Name = "WaterForceDirectionLabel"
		waterForceDirLabel.Text = "Water Force Direction"
		waterForceDirLabel.Position = UDim2.new(0,0,0,50)
		waterForceDirLabel.Parent = waterFrame

		local waterTypeChangedEvent = Instance.new("BindableEvent",waterFrame)
		waterTypeChangedEvent.Name = "WaterTypeChangedEvent"

		local waterForceDirectionSelectedFunc = function(newForceDirection)
			waterForceDirection = newForceDirection
			waterTypeChangedEvent:Fire({waterForce, waterForceDirection})
		end
		local waterForceSelectedFunc = function(newForce)
			waterForce = newForce
			waterTypeChangedEvent:Fire({waterForce, waterForceDirection})
		end

		local waterForceDirectionDropDown, forceWaterDirectionSelection = t.CreateDropDownMenu(waterForceDirections, waterForceDirectionSelectedFunc)
		waterForceDirectionDropDown.Size = UDim2.new(1,0,0,25)
		waterForceDirectionDropDown.Position = UDim2.new(0,0,1,3)
		forceWaterDirectionSelection("NegX")
		waterForceDirectionDropDown.Parent = waterForceDirLabel

		local waterForceDropDown, forceWaterForceSelection = t.CreateDropDownMenu(waterForces, waterForceSelectedFunc)
		forceWaterForceSelection("None")
		waterForceDropDown.Size = UDim2.new(1,0,0,25)
		waterForceDropDown.Position = UDim2.new(0,0,1,3)
		waterForceDropDown.Parent = waterForceLabel

		return waterFrame, waterTypeChangedEvent
	end

	-- Helper Function that contructs gui elements
	local function createSetGui()
	
		local setGui = Instance.new("ScreenGui")
		setGui.Name = "SetGui"
		
		local setPanel = Instance.new("Frame")
		setPanel.Name = "SetPanel"
		setPanel.Active = true
		setPanel.BackgroundTransparency = 1
		if position then
			setPanel.Position = position
		else
			setPanel.Position = UDim2.new(0.2, 29, 0.1, 24)
		end
		if size then
			setPanel.Size = size
		else
			setPanel.Size = UDim2.new(0.6, -58, 0.64, 0)
		end
		setPanel.Style = Enum.FrameStyle.RobloxRound
		setPanel.ZIndex = 6
		setPanel.Parent = setGui
		
			-- Children of SetPanel
			local itemPreview = Instance.new("Frame")
			itemPreview.Name = "ItemPreview"
			itemPreview.BackgroundTransparency = 1
			itemPreview.Position = UDim2.new(0.8,5,0.085,0)
			itemPreview.Size = UDim2.new(0.21,0,0.9,0)
			itemPreview.ZIndex = 6
			itemPreview.Parent = setPanel
			
				-- Children of ItemPreview
				local textPanel = Instance.new("Frame")
				textPanel.Name = "TextPanel"
				textPanel.BackgroundTransparency = 1
				textPanel.Position = UDim2.new(0,0,0.45,0)
				textPanel.Size = UDim2.new(1,0,0.55,0)
				textPanel.ZIndex = 6
				textPanel.Parent = itemPreview
					
					-- Children of TextPanel
					local rolloverText = Instance.new("TextLabel")
					rolloverText.Name = "RolloverText"
					rolloverText.BackgroundTransparency = 1
					rolloverText.Size = UDim2.new(1,0,0,48)
					rolloverText.ZIndex = 6
					rolloverText.Font = Enum.Font.ArialBold
					rolloverText.FontSize = Enum.FontSize.Size24
					rolloverText.Text = ""
					rolloverText.TextColor3 = Color3.new(1,1,1)
					rolloverText.TextWrap = true
					rolloverText.TextXAlignment = Enum.TextXAlignment.Left
					rolloverText.TextYAlignment = Enum.TextYAlignment.Top
					rolloverText.Parent = textPanel
					
				local largePreview = Instance.new("ImageLabel")
				largePreview.Name = "LargePreview"
				largePreview.BackgroundTransparency = 1
				largePreview.Image = ""
				largePreview.Size = UDim2.new(1,0,0,170)
				largePreview.ZIndex = 6
				largePreview.Parent = itemPreview
				
			local sets = Instance.new("Frame")
			sets.Name = "Sets"
			sets.BackgroundTransparency = 1
			sets.Position = UDim2.new(0,0,0,5)
			sets.Size = UDim2.new(0.23,0,1,-5)
			sets.ZIndex = 6
			sets.Parent = setPanel
			
				-- Children of Sets
				local line = Instance.new("Frame")
				line.Name = "Line"
				line.BackgroundColor3 = Color3.new(1,1,1)
				line.BackgroundTransparency = 0.7
				line.BorderSizePixel = 0
				line.Position = UDim2.new(1,-3,0.06,0)
				line.Size = UDim2.new(0,3,0.9,0)
				line.ZIndex = 6
				line.Parent = sets
				
				local setsLists, controlFrame = t.CreateTrueScrollingFrame()
				setsLists.Size = UDim2.new(1,-6,0.94,0)
				setsLists.Position = UDim2.new(0,0,0.06,0)
				setsLists.BackgroundTransparency = 1
				setsLists.Name = "SetsLists"
				setsLists.ZIndex = 6
				setsLists.Parent = sets
				drillDownSetZIndex(controlFrame, 7)
					
				local setsHeader = Instance.new("TextLabel")
				setsHeader.Name = "SetsHeader"
				setsHeader.BackgroundTransparency = 1
				setsHeader.Size = UDim2.new(0,47,0,24)
				setsHeader.ZIndex = 6
				setsHeader.Font = Enum.Font.ArialBold
				setsHeader.FontSize = Enum.FontSize.Size24
				setsHeader.Text = "Sets"
				setsHeader.TextColor3 = Color3.new(1,1,1)
				setsHeader.TextXAlignment = Enum.TextXAlignment.Left
				setsHeader.TextYAlignment = Enum.TextYAlignment.Top
				setsHeader.Parent = sets
			
			local cancelButton = Instance.new("TextButton")
			cancelButton.Name = "CancelButton"
			cancelButton.Position = UDim2.new(1,-32,0,-2)
			cancelButton.Size = UDim2.new(0,34,0,34)
			cancelButton.Style = Enum.ButtonStyle.RobloxButtonDefault
			cancelButton.ZIndex = 6
			cancelButton.Text = ""
			cancelButton.Modal = true
			cancelButton.Parent = setPanel
			
				-- Children of Cancel Button
				local cancelImage = Instance.new("ImageLabel")
				cancelImage.Name = "CancelImage"
				cancelImage.BackgroundTransparency = 1
				cancelImage.Image = "http://www.roblox.com/asset/?id=54135717"
				cancelImage.Position = UDim2.new(0,-2,0,-2)
				cancelImage.Size = UDim2.new(0,16,0,16)
				cancelImage.ZIndex = 6
				cancelImage.Parent = cancelButton
					
		return setGui
	end
	
	local function createSetButton(text)
		local setButton = Instance.new("TextButton")
		
		if text then setButton.Text = text
		else setButton.Text = "" end
		
		setButton.AutoButtonColor = false
		setButton.BackgroundTransparency = 1
		setButton.BackgroundColor3 = Color3.new(1,1,1)
		setButton.BorderSizePixel = 0
		setButton.Size = UDim2.new(1,-5,0,18)
		setButton.ZIndex = 6
		setButton.Visible = false
		setButton.Font = Enum.Font.Arial
		setButton.FontSize = Enum.FontSize.Size18
		setButton.TextColor3 = Color3.new(1,1,1)
		setButton.TextXAlignment = Enum.TextXAlignment.Left
		
		return setButton
	end
	
	local function buildSetButton(name, setId, setImageId, i,  count)
		local button = createSetButton(name)
		button.Text = name
		button.Name = "SetButton"
		button.Visible = true
		
		local setValue = Instance.new("IntValue")
		setValue.Name = "SetId"
		setValue.Value = setId
		setValue.Parent = button

		local setName = Instance.new("StringValue")
		setName.Name = "SetName"
		setName.Value = name
		setName.Parent = button

		return button
	end
	
	local function processCategory(sets)
		local setButtons = {}
		local numSkipped = 0
		for i = 1, #sets do
			if not showAdminCategories and sets[i].Name == "Beta" then
				numSkipped = numSkipped + 1
			else
				setButtons[i - numSkipped] = buildSetButton(sets[i].Name, sets[i].CategoryId, sets[i].ImageAssetId, i - numSkipped, #sets)
			end
		end
		return setButtons
	end
	
	local function handleResize()
		wait() -- neccessary to insure heartbeat happened
		
		local itemPreview = setGui.SetPanel.ItemPreview
		
		itemPreview.LargePreview.Size = UDim2.new(1,0,0,itemPreview.AbsoluteSize.X)
		itemPreview.LargePreview.Position = UDim2.new(0.5,-itemPreview.LargePreview.AbsoluteSize.X/2,0,0)
		itemPreview.TextPanel.Position = UDim2.new(0,0,0,itemPreview.LargePreview.AbsoluteSize.Y)
		itemPreview.TextPanel.Size = UDim2.new(1,0,0,itemPreview.AbsoluteSize.Y - itemPreview.LargePreview.AbsoluteSize.Y)
	end
	
	local function makeInsertAssetButton()
		local insertAssetButtonExample = Instance.new("Frame")
		insertAssetButtonExample.Name = "InsertAssetButtonExample"
		insertAssetButtonExample.Position = UDim2.new(0,128,0,64)
		insertAssetButtonExample.Size = UDim2.new(0,64,0,64)
		insertAssetButtonExample.BackgroundTransparency = 1
		insertAssetButtonExample.ZIndex = 6
		insertAssetButtonExample.Visible = false

		local assetId = Instance.new("IntValue")
		assetId.Name = "AssetId"
		assetId.Value = 0
		assetId.Parent = insertAssetButtonExample
		
		local assetName = Instance.new("StringValue")
		assetName.Name = "AssetName"
		assetName.Value = ""
		assetName.Parent = insertAssetButtonExample

		local button = Instance.new("TextButton")
		button.Name = "Button"
		button.Text = ""
		button.Style = Enum.ButtonStyle.RobloxButton
		button.Position = UDim2.new(0.025,0,0.025,0)
		button.Size = UDim2.new(0.95,0,0.95,0)
		button.ZIndex = 6
		button.Parent = insertAssetButtonExample

		local buttonImage = Instance.new("ImageLabel")
		buttonImage.Name = "ButtonImage"
		buttonImage.Image = ""
		buttonImage.Position = UDim2.new(0,-7,0,-7)
		buttonImage.Size = UDim2.new(1,14,1,14)
		buttonImage.BackgroundTransparency = 1
		buttonImage.ZIndex = 7
		buttonImage.Parent = button

		local configIcon = buttonImage:clone()
		configIcon.Name = "ConfigIcon"
		configIcon.Visible = false
		configIcon.Position = UDim2.new(1,-23,1,-24)
		configIcon.Size = UDim2.new(0,16,0,16)
		configIcon.Image = ""
		configIcon.ZIndex = 6
		configIcon.Parent = insertAssetButtonExample
		
		return insertAssetButtonExample
	end
	
	local function showLargePreview(insertButton)
		if insertButton:FindFirstChild("AssetId") then
			delay(0,function()
				game:GetService("ContentProvider"):Preload(LargeThumbnailUrl .. tostring(insertButton.AssetId.Value))
				setGui.SetPanel.ItemPreview.LargePreview.Image = LargeThumbnailUrl .. tostring(insertButton.AssetId.Value)
			end)
		end
		if insertButton:FindFirstChild("AssetName") then
			setGui.SetPanel.ItemPreview.TextPanel.RolloverText.Text = insertButton.AssetName.Value
		end
	end
	
	local function selectTerrainShape(shape)
		if currTerrainDropDownFrame then
			objectSelected(tostring(currTerrainDropDownFrame.AssetName.Value), tonumber(currTerrainDropDownFrame.AssetId.Value), shape)
		end
	end
	
	local function createTerrainTypeButton(name, parent)
		local dropDownTextButton = Instance.new("TextButton")
		dropDownTextButton.Name = name .. "Button"
		dropDownTextButton.Font = Enum.Font.ArialBold
		dropDownTextButton.FontSize = Enum.FontSize.Size14
		dropDownTextButton.BorderSizePixel = 0
		dropDownTextButton.TextColor3 = Color3.new(1,1,1)
		dropDownTextButton.Text = name
		dropDownTextButton.TextXAlignment = Enum.TextXAlignment.Left
		dropDownTextButton.BackgroundTransparency = 1
		dropDownTextButton.ZIndex = parent.ZIndex + 1
		dropDownTextButton.Size = UDim2.new(0,parent.Size.X.Offset - 2,0,16)
		dropDownTextButton.Position = UDim2.new(0,1,0,0)

		dropDownTextButton.MouseEnter:connect(function()
			dropDownTextButton.BackgroundTransparency = 0
			dropDownTextButton.TextColor3 = Color3.new(0,0,0)
		end)

		dropDownTextButton.MouseLeave:connect(function()
			dropDownTextButton.BackgroundTransparency = 1
			dropDownTextButton.TextColor3 = Color3.new(1,1,1)
		end)

		dropDownTextButton.MouseButton1Click:connect(function()
			dropDownTextButton.BackgroundTransparency = 1
			dropDownTextButton.TextColor3 = Color3.new(1,1,1)
			if dropDownTextButton.Parent and dropDownTextButton.Parent:IsA("GuiObject") then
				dropDownTextButton.Parent.Visible = false
			end
			selectTerrainShape(terrainShapeMap[dropDownTextButton.Text])
		end)

		return dropDownTextButton
	end
	
	local function createTerrainDropDownMenu(zIndex)
		local dropDown = Instance.new("Frame")
		dropDown.Name = "TerrainDropDown"
		dropDown.BackgroundColor3 = Color3.new(0,0,0)
		dropDown.BorderColor3 = Color3.new(1,0,0)
		dropDown.Size = UDim2.new(0,200,0,0)
		dropDown.Visible = false
		dropDown.ZIndex = zIndex
		dropDown.Parent = setGui

		for i = 1, #terrainShapes do
			local shapeButton = createTerrainTypeButton(terrainShapes[i],dropDown)
			shapeButton.Position = UDim2.new(0,1,0,(i - 1) * (shapeButton.Size.Y.Offset))
			shapeButton.Parent = dropDown
			dropDown.Size = UDim2.new(0,200,0,dropDown.Size.Y.Offset + (shapeButton.Size.Y.Offset))
		end

		dropDown.MouseLeave:connect(function()
			dropDown.Visible = false
		end)
	end

	
	local function createDropDownMenuButton(parent)
		local dropDownButton = Instance.new("ImageButton")
		dropDownButton.Name = "DropDownButton"
		dropDownButton.Image = "http://www.roblox.com/asset/?id=67581509"
		dropDownButton.BackgroundTransparency = 1
		dropDownButton.Size = UDim2.new(0,16,0,16)
		dropDownButton.Position = UDim2.new(1,-24,0,6)
		dropDownButton.ZIndex = parent.ZIndex + 2
		dropDownButton.Parent = parent
		
		if not setGui:FindFirstChild("TerrainDropDown") then
			createTerrainDropDownMenu(8)
		end
		
		dropDownButton.MouseButton1Click:connect(function()
			setGui.TerrainDropDown.Visible = true
			setGui.TerrainDropDown.Position = UDim2.new(0,parent.AbsolutePosition.X,0,parent.AbsolutePosition.Y)
			currTerrainDropDownFrame = parent
		end)
	end
	
	local function buildInsertButton()
		local insertButton = makeInsertAssetButton()
		insertButton.Name = "InsertAssetButton"
		insertButton.Visible = true

		if Data.Category[Data.CurrentCategory].SetName == "High Scalability" then
			createDropDownMenuButton(insertButton)
		end

		local lastEnter = nil
		local mouseEnterCon = insertButton.MouseEnter:connect(function()
			lastEnter = insertButton
			delay(0.1,function()
				if lastEnter == insertButton then
					showLargePreview(insertButton)
				end
			end)
		end)
		return insertButton, mouseEnterCon
	end
	
	local function realignButtonGrid(columns)
		local x = 0
		local y = 0 
		for i = 1, #insertButtons do
			insertButtons[i].Position = UDim2.new(0, buttonWidth * x, 0, buttonHeight * y)
			x = x + 1
			if x &gt;= columns then
				x = 0
				y = y + 1
			end
		end
	end

	local function setInsertButtonImageBehavior(insertFrame, visible, name, assetId)
		if visible then
			insertFrame.AssetName.Value = name
			insertFrame.AssetId.Value = assetId
			local newImageUrl = SmallThumbnailUrl  .. assetId
			if newImageUrl ~= insertFrame.Button.ButtonImage.Image then
				delay(0,function()
					game:GetService("ContentProvider"):Preload(SmallThumbnailUrl  .. assetId)
					if insertFrame:findFirstChild("Button") then
						insertFrame.Button.ButtonImage.Image = SmallThumbnailUrl  .. assetId
					end
				end)
			end
			table.insert(insertButtonCons,
				insertFrame.Button.MouseButton1Click:connect(function()
					-- special case for water, show water selection gui
					local isWaterSelected = (name == "Water") and (Data.Category[Data.CurrentCategory].SetName == "High Scalability")
					waterGui.Visible = isWaterSelected
					if isWaterSelected then
						objectSelected(name, tonumber(assetId), nil)
					else
						objectSelected(name, tonumber(assetId))
					end
				end)
			)
			insertFrame.Visible = true
		else
			insertFrame.Visible = false
		end
	end
	
	local function loadSectionOfItems(setGui, rows, columns)
		local pageSize = rows * columns

		if arrayPosition &gt; #contents then return end

		local origArrayPos = arrayPosition

		local yCopy = 0
		for i = 1, pageSize + 1 do 
			if arrayPosition &gt;= #contents + 1 then
				break
			end

			local buttonCon
			insertButtons[arrayPosition], buttonCon = buildInsertButton()
			table.insert(insertButtonCons,buttonCon)
			insertButtons[arrayPosition].Parent = setGui.SetPanel.ItemsFrame
			arrayPosition = arrayPosition + 1
		end
		realignButtonGrid(columns)

		local indexCopy = origArrayPos
		for index = origArrayPos, arrayPosition do
			if insertButtons[index] then
				if contents[index] then

					-- we don't want water to have a drop down button
					if contents[index].Name == "Water" then
						if Data.Category[Data.CurrentCategory].SetName == "High Scalability" then
							insertButtons[index]:FindFirstChild("DropDownButton",true):Destroy()
						end
					end

					local assetId
					if useAssetVersionId then
						assetId = contents[index].AssetVersionId
					else
						assetId = contents[index].AssetId
					end
					setInsertButtonImageBehavior(insertButtons[index], true, contents[index].Name, assetId)
				else
					break
				end
			else
				break
			end
			indexCopy = index
		end
	end
	
	local function setSetIndex()
		Data.Category[Data.CurrentCategory].Index = 0

		rows = 7
		columns = math.floor(setGui.SetPanel.ItemsFrame.AbsoluteSize.X/buttonWidth)

		contents = Data.Category[Data.CurrentCategory].Contents
		if contents then
			-- remove our buttons and their connections
			for i = 1, #insertButtons do
				insertButtons[i]:remove()
			end
			for i = 1, #insertButtonCons do
				if insertButtonCons[i] then insertButtonCons[i]:disconnect() end
			end
			insertButtonCons = {}
			insertButtons = {}

			arrayPosition = 1
			loadSectionOfItems(setGui, rows, columns)
		end
	end
	
	local function selectSet(button, setName, setId, setIndex)
		if button and Data.Category[Data.CurrentCategory] ~= nil then
			if button ~= Data.Category[Data.CurrentCategory].Button then
				Data.Category[Data.CurrentCategory].Button = button

				if SetCache[setId] == nil then
					SetCache[setId] = game:GetService("InsertService"):GetCollection(setId)
				end
				Data.Category[Data.CurrentCategory].Contents = SetCache[setId]

				Data.Category[Data.CurrentCategory].SetName = setName
				Data.Category[Data.CurrentCategory].SetId = setId
			end
			setSetIndex()
		end
	end
	
	local function selectCategoryPage(buttons, page)
		if buttons ~= Data.CurrentCategory then
			if Data.CurrentCategory then
				for key, button in pairs(Data.CurrentCategory) do
					button.Visible = false
				end
			end

			Data.CurrentCategory = buttons
			if Data.Category[Data.CurrentCategory] == nil then
				Data.Category[Data.CurrentCategory] = {}
				if #buttons &gt; 0 then
					selectSet(buttons[1], buttons[1].SetName.Value, buttons[1].SetId.Value, 0)
				end
			else
				Data.Category[Data.CurrentCategory].Button = nil
				selectSet(Data.Category[Data.CurrentCategory].ButtonFrame, Data.Category[Data.CurrentCategory].SetName, Data.Category[Data.CurrentCategory].SetId, Data.Category[Data.CurrentCategory].Index)
			end
		end
	end
	
	local function selectCategory(category)
		selectCategoryPage(category, 0)
	end
	
	local function resetAllSetButtonSelection()
		local setButtons = setGui.SetPanel.Sets.SetsLists:GetChildren()
		for i = 1, #setButtons do
			if setButtons[i]:IsA("TextButton") then
				setButtons[i].Selected = false
				setButtons[i].BackgroundTransparency = 1
				setButtons[i].TextColor3 = Color3.new(1,1,1)
				setButtons[i].BackgroundColor3 = Color3.new(1,1,1)
			end
		end
	end
	
	local function populateSetsFrame()
		local currRow = 0
		for i = 1, #userCategoryButtons do
			local button = userCategoryButtons[i]
			button.Visible = true
			button.Position = UDim2.new(0,5,0,currRow * button.Size.Y.Offset)
			button.Parent = setGui.SetPanel.Sets.SetsLists
			
			if i == 1 then -- we will have this selected by default, so show it
				button.Selected = true
				button.BackgroundColor3 = Color3.new(0,204/255,0)
				button.TextColor3 = Color3.new(0,0,0)
				button.BackgroundTransparency = 0
			end

			button.MouseEnter:connect(function()
				if not button.Selected then
					button.BackgroundTransparency = 0
					button.TextColor3 = Color3.new(0,0,0)
				end
			end)
			button.MouseLeave:connect(function()
				if not button.Selected then
					button.BackgroundTransparency = 1
					button.TextColor3 = Color3.new(1,1,1)
				end
			end)
			button.MouseButton1Click:connect(function()
				resetAllSetButtonSelection()
				button.Selected = not button.Selected
				button.BackgroundColor3 = Color3.new(0,204/255,0)
				button.TextColor3 = Color3.new(0,0,0)
				button.BackgroundTransparency = 0
				selectSet(button, button.Text, userCategoryButtons[i].SetId.Value, 0)
			end)

			currRow = currRow + 1
		end

		local buttons =  setGui.SetPanel.Sets.SetsLists:GetChildren()

		-- set first category as loaded for default
		if buttons then
			for i = 1, #buttons do
				if buttons[i]:IsA("TextButton") then
					selectSet(buttons[i], buttons[i].Text, userCategoryButtons[i].SetId.Value, 0)
					selectCategory(userCategoryButtons)
					break
				end
			end
		end
	end

	setGui = createSetGui()
	waterGui, waterTypeChangedEvent = createWaterGui()
	waterGui.Position = UDim2.new(0,55,0,0)
	waterGui.Parent = setGui
	setGui.Changed:connect(function(prop) -- this resizes the preview image to always be the right size
		if prop == "AbsoluteSize" then
			handleResize()
			setSetIndex()
		end
	end)
	
	local scrollFrame, controlFrame = t.CreateTrueScrollingFrame()
	scrollFrame.Size = UDim2.new(0.54,0,0.85,0)
	scrollFrame.Position = UDim2.new(0.24,0,0.085,0)
	scrollFrame.Name = "ItemsFrame"
	scrollFrame.ZIndex = 6
	scrollFrame.Parent = setGui.SetPanel
	scrollFrame.BackgroundTransparency = 1

	drillDownSetZIndex(controlFrame,7)

	controlFrame.Parent = setGui.SetPanel
	controlFrame.Position = UDim2.new(0.76, 5, 0, 0)

	local debounce = false
	controlFrame.ScrollBottom.Changed:connect(function(prop)
		if controlFrame.ScrollBottom.Value == true then
			if debounce then return end
			debounce = true
				loadSectionOfItems(setGui, rows, columns)
			debounce = false
		end
	end)

	local userData = {}
	for id = 1, #userIdsForSets do
		local newUserData = game:GetService("InsertService"):GetUserSets(userIdsForSets[id])
		if newUserData and #newUserData &gt; 2 then
			-- start at #3 to skip over My Decals and My Models for each account
			for category = 3, #newUserData do
				if newUserData[category].Name == "High Scalability" then -- we want high scalability parts to show first
					table.insert(userData,1,newUserData[category])
				else
					table.insert(userData, newUserData[category])
				end
			end
		end
	
	end
	if userData then
		userCategoryButtons = processCategory(userData)
	end

	rows = math.floor(setGui.SetPanel.ItemsFrame.AbsoluteSize.Y/buttonHeight)
	columns = math.floor(setGui.SetPanel.ItemsFrame.AbsoluteSize.X/buttonWidth)

	populateSetsFrame()

	insertPanelCloseCon = setGui.SetPanel.CancelButton.MouseButton1Click:connect(function()
		setGui.SetPanel.Visible = false
		if dialogClosed then dialogClosed() end
	end)
	
	local setVisibilityFunction = function(visible)
		if visible then
			setGui.SetPanel.Visible = true
		else
			setGui.SetPanel.Visible = false
		end
	end
	
	local getVisibilityFunction = function()
		if setGui then
			if setGui:FindFirstChild("SetPanel") then
				return setGui.SetPanel.Visible
			end
		end
		
		return false
	end
	
	return setGui, setVisibilityFunction, getVisibilityFunction, waterTypeChangedEvent
end

t.CreateTerrainMaterialSelector = function(size,position)
	local terrainMaterialSelectionChanged = Instance.new("BindableEvent")
	terrainMaterialSelectionChanged.Name = "TerrainMaterialSelectionChanged"

	local selectedButton = nil

	local frame = Instance.new("Frame")
	frame.Name = "TerrainMaterialSelector"
	if size then
		frame.Size = size
	else
		frame.Size = UDim2.new(0, 245, 0, 230)
	end
	if position then
		frame.Position = position
	end
	frame.BorderSizePixel = 0
	frame.BackgroundColor3 = Color3.new(0,0,0)
	frame.Active = true

	terrainMaterialSelectionChanged.Parent = frame

	local waterEnabled = true -- todo: turn this on when water is ready

	local materialToImageMap = {}
	local materialNames = {"Grass", "Sand", "Brick", "Granite", "Asphalt", "Iron", "Aluminum", "Gold", "Plank", "Log", "Gravel", "Cinder Block", "Stone Wall", "Concrete", "Plastic (red)", "Plastic (blue)"}
	if waterEnabled then
		table.insert(materialNames,"Water")
	end
	local currentMaterial = 1

	function getEnumFromName(choice)
		if choice == "Grass" then return 1 end
		if choice == "Sand" then return 2 end 
		if choice == "Erase" then return 0 end
		if choice == "Brick" then return 3 end
		if choice == "Granite" then return 4 end
		if choice == "Asphalt" then return 5 end
		if choice == "Iron" then return 6 end
		if choice == "Aluminum" then return 7 end
		if choice == "Gold" then return 8 end
		if choice == "Plank" then return 9 end
		if choice == "Log" then return 10 end
		if choice == "Gravel" then return 11 end
		if choice == "Cinder Block" then return 12 end
		if choice == "Stone Wall" then return 13 end
		if choice == "Concrete" then return 14 end
		if choice == "Plastic (red)" then return 15 end
		if choice == "Plastic (blue)" then return 16 end
		if choice == "Water" then return 17 end
	end

	function getNameFromEnum(choice)
		if choice == Enum.CellMaterial.Grass or choice == 1 then return "Grass"end
		if choice == Enum.CellMaterial.Sand or choice == 2 then return "Sand" end 
		if choice == Enum.CellMaterial.Empty or choice == 0 then return "Erase" end
		if choice == Enum.CellMaterial.Brick or choice == 3 then return "Brick" end
		if choice == Enum.CellMaterial.Granite or choice == 4 then return "Granite" end
		if choice == Enum.CellMaterial.Asphalt or choice == 5 then return "Asphalt" end
		if choice == Enum.CellMaterial.Iron or choice == 6 then return "Iron" end
		if choice == Enum.CellMaterial.Aluminum or choice == 7 then return "Aluminum" end
		if choice == Enum.CellMaterial.Gold or choice == 8 then return "Gold" end
		if choice == Enum.CellMaterial.WoodPlank or choice == 9 then return "Plank" end
		if choice == Enum.CellMaterial.WoodLog or choice == 10 then return "Log" end
		if choice == Enum.CellMaterial.Gravel or choice == 11 then return "Gravel" end
		if choice == Enum.CellMaterial.CinderBlock or choice == 12 then return "Cinder Block" end
		if choice == Enum.CellMaterial.MossyStone or choice == 13 then return "Stone Wall" end
		if choice == Enum.CellMaterial.Cement or choice == 14 then return "Concrete" end
		if choice == Enum.CellMaterial.RedPlastic or choice == 15 then return "Plastic (red)" end
		if choice == Enum.CellMaterial.BluePlastic or choice == 16 then return "Plastic (blue)" end

		if waterEnabled then
			if choice == Enum.CellMaterial.Water or choice == 17 then return "Water" end
		end
	end


	local function updateMaterialChoice(choice)
		currentMaterial = getEnumFromName(choice)
		terrainMaterialSelectionChanged:Fire(currentMaterial)
	end

	-- we so need a better way to do this
	for i,v in pairs(materialNames) do
		materialToImageMap[v] = {}
		if v == "Grass" then materialToImageMap[v].Regular = "http://www.roblox.com/asset/?id=56563112"
		elseif v == "Sand" then materialToImageMap[v].Regular = "http://www.roblox.com/asset/?id=62356652"
		elseif v == "Brick" then materialToImageMap[v].Regular = "http://www.roblox.com/asset/?id=65961537"
		elseif v == "Granite" then materialToImageMap[v].Regular = "http://www.roblox.com/asset/?id=67532153"
		elseif v == "Asphalt" then materialToImageMap[v].Regular = "http://www.roblox.com/asset/?id=67532038"
		elseif v == "Iron" then materialToImageMap[v].Regular = "http://www.roblox.com/asset/?id=67532093"
		elseif v == "Aluminum" then materialToImageMap[v].Regular = "http://www.roblox.com/asset/?id=67531995"
		elseif v == "Gold" then materialToImageMap[v].Regular = "http://www.roblox.com/asset/?id=67532118"
		elseif v == "Plastic (red)" then materialToImageMap[v].Regular = "http://www.roblox.com/asset/?id=67531848"
		elseif v == "Plastic (blue)" then materialToImageMap[v].Regular = "http://www.roblox.com/asset/?id=67531924"
		elseif v == "Plank" then materialToImageMap[v].Regular = "http://www.roblox.com/asset/?id=67532015"
		elseif v == "Log" then materialToImageMap[v].Regular = "http://www.roblox.com/asset/?id=67532051"
		elseif v == "Gravel" then materialToImageMap[v].Regular = "http://www.roblox.com/asset/?id=67532206"
		elseif v == "Cinder Block" then materialToImageMap[v].Regular = "http://www.roblox.com/asset/?id=67532103"
		elseif v == "Stone Wall" then materialToImageMap[v].Regular = "http://www.roblox.com/asset/?id=67531804"
		elseif v == "Concrete" then materialToImageMap[v].Regular = "http://www.roblox.com/asset/?id=67532059"
		elseif v == "Water" then materialToImageMap[v].Regular = "http://www.roblox.com/asset/?id=81407474"
		else materialToImageMap[v].Regular = "http://www.roblox.com/asset/?id=66887593" -- fill in the rest here!!
		end
	end

	local scrollFrame, scrollUp, scrollDown, recalculateScroll = t.CreateScrollingFrame(nil,"grid")
	scrollFrame.Size = UDim2.new(0.85,0,1,0)
	scrollFrame.Position = UDim2.new(0,0,0,0)
	scrollFrame.Parent = frame

	scrollUp.Parent = frame
	scrollUp.Visible = true
	scrollUp.Position = UDim2.new(1,-19,0,0)

	scrollDown.Parent = frame
	scrollDown.Visible = true
	scrollDown.Position = UDim2.new(1,-19,1,-17)

	local function goToNewMaterial(buttonWrap, materialName)
		updateMaterialChoice(materialName)
		buttonWrap.BackgroundTransparency = 0
		selectedButton.BackgroundTransparency = 1
		selectedButton = buttonWrap
	end

	local function createMaterialButton(name)	
		local buttonWrap = Instance.new("TextButton")
		buttonWrap.Text = ""
		buttonWrap.Size = UDim2.new(0,32,0,32)
		buttonWrap.BackgroundColor3 = Color3.new(1,1,1)
		buttonWrap.BorderSizePixel = 0
		buttonWrap.BackgroundTransparency = 1
		buttonWrap.AutoButtonColor = false
		buttonWrap.Name = tostring(name)
		
		local imageButton = Instance.new("ImageButton")
		imageButton.AutoButtonColor = false
		imageButton.BackgroundTransparency = 1
		imageButton.Size = UDim2.new(0,30,0,30)
		imageButton.Position = UDim2.new(0,1,0,1)
		imageButton.Name = tostring(name)
		imageButton.Parent = buttonWrap
		imageButton.Image = materialToImageMap[name].Regular

		local enumType = Instance.new("NumberValue")
		enumType.Name = "EnumType"
		enumType.Parent = buttonWrap
		enumType.Value = 0
		
		imageButton.MouseEnter:connect(function()
			buttonWrap.BackgroundTransparency = 0
		end)
		imageButton.MouseLeave:connect(function()
			if selectedButton ~= buttonWrap then
				buttonWrap.BackgroundTransparency = 1
			end
		end)
		imageButton.MouseButton1Click:connect(function()
			if selectedButton ~= buttonWrap then
				goToNewMaterial(buttonWrap, tostring(name))
			end
		end)
		
		return buttonWrap 
	end

	for i = 1, #materialNames do
		local imageButton = createMaterialButton(materialNames[i])
		
		if materialNames[i] == "Grass" then -- always start with grass as the default
			selectedButton = imageButton
			imageButton.BackgroundTransparency = 0
		end
		
		imageButton.Parent = scrollFrame
	end

	local forceTerrainMaterialSelection = function(newMaterialType)
		if not newMaterialType then return end
		if currentMaterial == newMaterialType then return end

		local matName = getNameFromEnum(newMaterialType)
		local buttons = scrollFrame:GetChildren()
		for i = 1, #buttons do
			if buttons[i].Name == "Plastic (blue)" and matName == "Plastic (blue)" then goToNewMaterial(buttons[i],matName) return end
			if buttons[i].Name == "Plastic (red)" and matName == "Plastic (red)" then goToNewMaterial(buttons[i],matName) return end
			if string.find(buttons[i].Name, matName) then
				goToNewMaterial(buttons[i],matName)
				return
			end
		end
	end

	frame.Changed:connect(function ( prop )
		if prop == "AbsoluteSize" then
			recalculateScroll()
		end
	end)

	recalculateScroll()
	return frame, terrainMaterialSelectionChanged, forceTerrainMaterialSelection
end

t.CreateLoadingFrame = function(name,size,position)
	game:GetService("ContentProvider"):Preload("http://www.roblox.com/asset/?id=35238053")

	local loadingFrame = Instance.new("Frame")
	loadingFrame.Name = "LoadingFrame"
	loadingFrame.Style = Enum.FrameStyle.RobloxRound

	if size then loadingFrame.Size = size
	else loadingFrame.Size = UDim2.new(0,300,0,160) end
	if position then loadingFrame.Position = position 
	else loadingFrame.Position = UDim2.new(0.5, -150, 0.5,-80) end

	local loadingBar = Instance.new("Frame")
	loadingBar.Name = "LoadingBar"
	loadingBar.BackgroundColor3 = Color3.new(0,0,0)
	loadingBar.BorderColor3 = Color3.new(79/255,79/255,79/255)
	loadingBar.Position = UDim2.new(0,0,0,41)
	loadingBar.Size = UDim2.new(1,0,0,30)
	loadingBar.Parent = loadingFrame

		local loadingGreenBar = Instance.new("ImageLabel")
		loadingGreenBar.Name = "LoadingGreenBar"
		loadingGreenBar.Image = "http://www.roblox.com/asset/?id=35238053"
		loadingGreenBar.Position = UDim2.new(0,0,0,0)
		loadingGreenBar.Size = UDim2.new(0,0,1,0)
		loadingGreenBar.Visible = false
		loadingGreenBar.Parent = loadingBar

		local loadingPercent = Instance.new("TextLabel")
		loadingPercent.Name = "LoadingPercent"
		loadingPercent.BackgroundTransparency = 1
		loadingPercent.Position = UDim2.new(0,0,1,0)
		loadingPercent.Size = UDim2.new(1,0,0,14)
		loadingPercent.Font = Enum.Font.Arial
		loadingPercent.Text = "0%"
		loadingPercent.FontSize = Enum.FontSize.Size14
		loadingPercent.TextColor3 = Color3.new(1,1,1)
		loadingPercent.Parent = loadingBar

	local cancelButton = Instance.new("TextButton")
	cancelButton.Name = "CancelButton"
	cancelButton.Position = UDim2.new(0.5,-60,1,-40)
	cancelButton.Size = UDim2.new(0,120,0,40)
	cancelButton.Font = Enum.Font.Arial
	cancelButton.FontSize = Enum.FontSize.Size18
	cancelButton.TextColor3 = Color3.new(1,1,1)
	cancelButton.Text = "Cancel"
	cancelButton.Style = Enum.ButtonStyle.RobloxButton
	cancelButton.Parent = loadingFrame

	local loadingName = Instance.new("TextLabel")
	loadingName.Name = "loadingName"
	loadingName.BackgroundTransparency = 1
	loadingName.Size = UDim2.new(1,0,0,18)
	loadingName.Position = UDim2.new(0,0,0,2)
	loadingName.Font = Enum.Font.Arial
	loadingName.Text = name
	loadingName.TextColor3 = Color3.new(1,1,1)
	loadingName.TextStrokeTransparency = 1
	loadingName.FontSize = Enum.FontSize.Size18
	loadingName.Parent = loadingFrame

	local cancelButtonClicked = Instance.new("BindableEvent")
	cancelButtonClicked.Name = "CancelButtonClicked"
	cancelButtonClicked.Parent = cancelButton
	cancelButton.MouseButton1Click:connect(function()
		cancelButtonClicked:Fire()
	end)

	local updateLoadingGuiPercent = function(percent, tweenAction, tweenLength)
		if percent and type(percent) ~= "number" then
			error("updateLoadingGuiPercent expects number as argument, got",type(percent),"instead")
		end

		local newSize = nil
		if percent &lt; 0 then
			newSize = UDim2.new(0,0,1,0)
		elseif percent &gt; 1 then
			newSize = UDim2.new(1,0,1,0)
		else
			newSize = UDim2.new(percent,0,1,0)
		end

		if tweenAction then
			if not tweenLength then
				error("updateLoadingGuiPercent is set to tween new percentage, but got no tween time length! Please pass this in as third argument")
			end

			if (newSize.X.Scale &gt; 0) then
				loadingGreenBar.Visible = true
				loadingGreenBar:TweenSize(	newSize,
											Enum.EasingDirection.Out,
											Enum.EasingStyle.Quad,
											tweenLength,
											true)
			else
				loadingGreenBar:TweenSize(	newSize,
											Enum.EasingDirection.Out,
											Enum.EasingStyle.Quad,
											tweenLength,
											true,
											function() 
												if (newSize.X.Scale &lt; 0) then
													loadingGreenBar.Visible = false
												end
											end)
			end

		else
			loadingGreenBar.Size = newSize
			loadingGreenBar.Visible = (newSize.X.Scale &gt; 0)
		end
	end

	loadingGreenBar.Changed:connect(function(prop)
		if prop == "Size" then
			loadingPercent.Text = tostring( math.ceil(loadingGreenBar.Size.X.Scale * 100) ) .. "%"
		end
	end)

	return loadingFrame, updateLoadingGuiPercent, cancelButtonClicked
end

t.CreatePluginFrame = function (name,size,position,scrollable,parent)
	function createMenuButton(size,position,text,fontsize,name,parent)
		local button = Instance.new("TextButton",parent)
		button.AutoButtonColor = false
		button.Name = name
		button.BackgroundTransparency = 1
		button.Position = position
		button.Size = size
		button.Font = Enum.Font.ArialBold
		button.FontSize = fontsize
		button.Text =  text
		button.TextColor3 = Color3.new(1,1,1)
		button.BorderSizePixel = 0
		button.BackgroundColor3 = Color3.new(20/255,20/255,20/255)

		button.MouseEnter:connect(function ( )
			if button.Selected then return end
			button.BackgroundTransparency = 0
		end)
		button.MouseLeave:connect(function ( )
			if button.Selected then return end
			button.BackgroundTransparency = 1
		end)

		return button

	end

	local dragBar = Instance.new("Frame",parent)
	dragBar.Name = tostring(name) .. "DragBar"
	dragBar.BackgroundColor3 = Color3.new(39/255,39/255,39/255)
	dragBar.BorderColor3 = Color3.new(0,0,0)
	if size then
		dragBar.Size =  UDim2.new(size.X.Scale,size.X.Offset,0,20)  + UDim2.new(0,20,0,0)
	else
		dragBar.Size = UDim2.new(0,183,0,20)
	end
	if position then
		dragBar.Position = position
	end
	dragBar.Active = true
	dragBar.Draggable = true
	--dragBar.Visible = false
	dragBar.MouseEnter:connect(function (  )
		dragBar.BackgroundColor3 = Color3.new(49/255,49/255,49/255)
	end)
	dragBar.MouseLeave:connect(function (  )
		dragBar.BackgroundColor3 = Color3.new(39/255,39/255,39/255)
	end)

	-- plugin name label
	local pluginNameLabel = Instance.new("TextLabel",dragBar)
	pluginNameLabel.Name = "BarNameLabel"
	pluginNameLabel.Text = " " .. tostring(name)
	pluginNameLabel.TextColor3 = Color3.new(1,1,1)
	pluginNameLabel.TextStrokeTransparency = 0
	pluginNameLabel.Size = UDim2.new(1,0,1,0)
	pluginNameLabel.Font = Enum.Font.ArialBold
	pluginNameLabel.FontSize = Enum.FontSize.Size18
	pluginNameLabel.TextXAlignment = Enum.TextXAlignment.Left
	pluginNameLabel.BackgroundTransparency = 1

	-- close button
	local closeButton = createMenuButton(UDim2.new(0,15,0,17),UDim2.new(1,-16,0.5,-8),"X",Enum.FontSize.Size14,"CloseButton",dragBar)
	local closeEvent = Instance.new("BindableEvent")
	closeEvent.Name = "CloseEvent"
	closeEvent.Parent = closeButton
	closeButton.MouseButton1Click:connect(function ()
		closeEvent:Fire()
		closeButton.BackgroundTransparency = 1
	end)

	-- help button
	local helpButton = createMenuButton(UDim2.new(0,15,0,17),UDim2.new(1,-51,0.5,-8),"?",Enum.FontSize.Size14,"HelpButton",dragBar)
	local helpFrame = Instance.new("Frame",dragBar)
	helpFrame.Name = "HelpFrame"
	helpFrame.BackgroundColor3 = Color3.new(0,0,0)
	helpFrame.Size = UDim2.new(0,300,0,552)
	helpFrame.Position = UDim2.new(1,5,0,0)
	helpFrame.Active = true
	helpFrame.BorderSizePixel = 0
	helpFrame.Visible = false

	helpButton.MouseButton1Click:connect(function(  )
		helpFrame.Visible = not helpFrame.Visible
		if helpFrame.Visible then
			helpButton.Selected = true
			helpButton.BackgroundTransparency = 0
			local screenGui = getScreenGuiAncestor(helpFrame)
			if screenGui then
				if helpFrame.AbsolutePosition.X + helpFrame.AbsoluteSize.X &gt; screenGui.AbsoluteSize.X then --position on left hand side
					helpFrame.Position = UDim2.new(0,-5 - helpFrame.AbsoluteSize.X,0,0)
				else -- position on right hand side
					helpFrame.Position = UDim2.new(1,5,0,0)
				end
			else
				helpFrame.Position = UDim2.new(1,5,0,0)
			end
		else
			helpButton.Selected = false
			helpButton.BackgroundTransparency = 1
		end
	end)

	local minimizeButton = createMenuButton(UDim2.new(0,16,0,17),UDim2.new(1,-34,0.5,-8),"-",Enum.FontSize.Size14,"MinimizeButton",dragBar)
	minimizeButton.TextYAlignment = Enum.TextYAlignment.Top

	local minimizeFrame = Instance.new("Frame",dragBar)
	minimizeFrame.Name = "MinimizeFrame"
	minimizeFrame.BackgroundColor3 = Color3.new(73/255,73/255,73/255)
	minimizeFrame.BorderColor3 = Color3.new(0,0,0)
	minimizeFrame.Position = UDim2.new(0,0,1,0)
	if size then
		minimizeFrame.Size =  UDim2.new(size.X.Scale,size.X.Offset,0,50) + UDim2.new(0,20,0,0)
	else
		minimizeFrame.Size = UDim2.new(0,183,0,50)
	end
	minimizeFrame.Visible = false

	local minimizeBigButton = Instance.new("TextButton",minimizeFrame)
	minimizeBigButton.Position = UDim2.new(0.5,-50,0.5,-20)
	minimizeBigButton.Name = "MinimizeButton"
	minimizeBigButton.Size = UDim2.new(0,100,0,40)
	minimizeBigButton.Style = Enum.ButtonStyle.RobloxButton
	minimizeBigButton.Font = Enum.Font.ArialBold
	minimizeBigButton.FontSize = Enum.FontSize.Size18
	minimizeBigButton.TextColor3 = Color3.new(1,1,1)
	minimizeBigButton.Text = "Show"

	local separatingLine = Instance.new("Frame",dragBar)
	separatingLine.Name = "SeparatingLine"
	separatingLine.BackgroundColor3 = Color3.new(115/255,115/255,115/255)
	separatingLine.BorderSizePixel = 0
	separatingLine.Position = UDim2.new(1,-18,0.5,-7)
	separatingLine.Size = UDim2.new(0,1,0,14)

	local otherSeparatingLine = separatingLine:clone()
	otherSeparatingLine.Position = UDim2.new(1,-35,0.5,-7)
	otherSeparatingLine.Parent = dragBar

	local widgetContainer = Instance.new("Frame",dragBar)
	widgetContainer.Name = "WidgetContainer"
	widgetContainer.BackgroundTransparency = 1
	widgetContainer.Position = UDim2.new(0,0,1,0)
	widgetContainer.BorderColor3 = Color3.new(0,0,0)
	if not scrollable then
		widgetContainer.BackgroundTransparency = 0
		widgetContainer.BackgroundColor3 = Color3.new(72/255,72/255,72/255)
	end

	if size then
		if scrollable then
			widgetContainer.Size = size
		else
			widgetContainer.Size = UDim2.new(0,dragBar.AbsoluteSize.X,size.Y.Scale,size.Y.Offset)
		end
	else
		if scrollable then
			widgetContainer.Size = UDim2.new(0,163,0,400)
		else
			widgetContainer.Size = UDim2.new(0,dragBar.AbsoluteSize.X,0,400)
		end
	end
	if position then
		widgetContainer.Position = position + UDim2.new(0,0,0,20)
	end

	local frame,control,verticalDragger = nil
	if scrollable then
		--frame for widgets
		frame,control = t.CreateTrueScrollingFrame()
		frame.Size = UDim2.new(1, 0, 1, 0)
		frame.BackgroundColor3 = Color3.new(72/255,72/255,72/255)
		frame.BorderColor3 = Color3.new(0,0,0)
		frame.Active = true
		frame.Parent = widgetContainer
		control.Parent = dragBar
		control.BackgroundColor3 = Color3.new(72/255,72/255,72/255)
		control.BorderSizePixel = 0
		control.BackgroundTransparency = 0
		control.Position = UDim2.new(1,-21,1,1)
		if size then
			control.Size = UDim2.new(0,21,size.Y.Scale,size.Y.Offset)
		else
			control.Size = UDim2.new(0,21,0,400)
		end
		control:FindFirstChild("ScrollDownButton").Position = UDim2.new(0,0,1,-20)

		local fakeLine = Instance.new("Frame",control)
		fakeLine.Name = "FakeLine"
		fakeLine.BorderSizePixel = 0
		fakeLine.BackgroundColor3 = Color3.new(0,0,0)
		fakeLine.Size = UDim2.new(0,1,1,1)
		fakeLine.Position = UDim2.new(1,0,0,0)

		verticalDragger = Instance.new("TextButton",widgetContainer)
		verticalDragger.ZIndex = 2
		verticalDragger.AutoButtonColor = false
		verticalDragger.Name = "VerticalDragger"
		verticalDragger.BackgroundColor3 = Color3.new(50/255,50/255,50/255)
		verticalDragger.BorderColor3 = Color3.new(0,0,0)
		verticalDragger.Size = UDim2.new(1,20,0,20)
		verticalDragger.Position = UDim2.new(0,0,1,0)
		verticalDragger.Active = true
		verticalDragger.Text = ""

		local scrubFrame = Instance.new("Frame",verticalDragger)
		scrubFrame.Name = "ScrubFrame"
		scrubFrame.BackgroundColor3 = Color3.new(1,1,1)
		scrubFrame.BorderSizePixel = 0
		scrubFrame.Position = UDim2.new(0.5,-5,0.5,0)
		scrubFrame.Size = UDim2.new(0,10,0,1)
		scrubFrame.ZIndex = 5
		local scrubTwo = scrubFrame:clone()
		scrubTwo.Position = UDim2.new(0.5,-5,0.5,-2)
		scrubTwo.Parent = verticalDragger
		local scrubThree = scrubFrame:clone()
		scrubThree.Position = UDim2.new(0.5,-5,0.5,2)
		scrubThree.Parent = verticalDragger

		local areaSoak = Instance.new("TextButton",getScreenGuiAncestor(parent))
		areaSoak.Name = "AreaSoak"
		areaSoak.Size = UDim2.new(1,0,1,0)
		areaSoak.BackgroundTransparency = 1
		areaSoak.BorderSizePixel = 0
		areaSoak.Text = ""
		areaSoak.ZIndex = 10
		areaSoak.Visible = false
		areaSoak.Active = true

		local draggingVertical = false
		local startYPos = nil
		verticalDragger.MouseEnter:connect(function ()
			verticalDragger.BackgroundColor3 = Color3.new(60/255,60/255,60/255)
		end)
		verticalDragger.MouseLeave:connect(function ()
			verticalDragger.BackgroundColor3 = Color3.new(50/255,50/255,50/255)
		end)
		verticalDragger.MouseButton1Down:connect(function(x,y)
			draggingVertical = true
			areaSoak.Visible = true
			startYPos = y
		end)
		areaSoak.MouseButton1Up:connect(function (  )
			draggingVertical = false
			areaSoak.Visible = false
		end)
		areaSoak.MouseMoved:connect(function(x,y)
			if not draggingVertical then return end

			local yDelta = y - startYPos
			if not control.ScrollDownButton.Visible and yDelta &gt; 0 then
				return
			end

			if (widgetContainer.Size.Y.Offset + yDelta) &lt; 150 then
				widgetContainer.Size = UDim2.new(widgetContainer.Size.X.Scale, widgetContainer.Size.X.Offset,widgetContainer.Size.Y.Scale,150)
				control.Size = UDim2.new (0,21,0,150)
				return 
			end 

			startYPos = y

			if widgetContainer.Size.Y.Offset + yDelta &gt;= 0 then
				widgetContainer.Size = UDim2.new(widgetContainer.Size.X.Scale, widgetContainer.Size.X.Offset,widgetContainer.Size.Y.Scale,widgetContainer.Size.Y.Offset + yDelta)
				control.Size = UDim2.new(0,21,0,control.Size.Y.Offset + yDelta )
			end
		end)
	end

	local function switchMinimize()
		minimizeFrame.Visible = not minimizeFrame.Visible
		if scrollable then
			frame.Visible = not frame.Visible
			verticalDragger.Visible = not verticalDragger.Visible
			control.Visible = not control.Visible
		else
			widgetContainer.Visible = not widgetContainer.Visible
		end

		if minimizeFrame.Visible then
			minimizeButton.Text = "+"
		else
			minimizeButton.Text = "-"
		end
	end

	minimizeBigButton.MouseButton1Click:connect(function (  )
		switchMinimize()
	end)

	minimizeButton.MouseButton1Click:connect(function(  )
		switchMinimize()
	end)

	if scrollable then
		return dragBar, frame, helpFrame, closeEvent
	else
		return dragBar, widgetContainer, helpFrame, closeEvent
	end
end

t.Help = 
	function(funcNameOrFunc) 
		--input argument can be a string or a function.  Should return a description (of arguments and expected side effects)
		if funcNameOrFunc == "CreatePropertyDropDownMenu" or funcNameOrFunc == t.CreatePropertyDropDownMenu then
			return "Function CreatePropertyDropDownMenu.  " ..
				   "Arguments: (instance, propertyName, enumType).  " .. 
				   "Side effect: returns a container with a drop-down-box that is linked to the 'property' field of 'instance' which is of type 'enumType'" 
		end 
		if funcNameOrFunc == "CreateDropDownMenu" or funcNameOrFunc == t.CreateDropDownMenu then
			return "Function CreateDropDownMenu.  " .. 
			       "Arguments: (items, onItemSelected).  " .. 
				   "Side effect: Returns 2 results, a container to the gui object and a 'updateSelection' function for external updating.  The container is a drop-down-box created around a list of items" 
		end 
		if funcNameOrFunc == "CreateMessageDialog" or funcNameOrFunc == t.CreateMessageDialog then
			return "Function CreateMessageDialog.  " .. 
			       "Arguments: (title, message, buttons). " .. 
			       "Side effect: Returns a gui object of a message box with 'title' and 'message' as passed in.  'buttons' input is an array of Tables contains a 'Text' and 'Function' field for the text/callback of each button"
		end		
		if funcNameOrFunc == "CreateStyledMessageDialog" or funcNameOrFunc == t.CreateStyledMessageDialog then
			return "Function CreateStyledMessageDialog.  " .. 
			       "Arguments: (title, message, style, buttons). " .. 
			       "Side effect: Returns a gui object of a message box with 'title' and 'message' as passed in.  'buttons' input is an array of Tables contains a 'Text' and 'Function' field for the text/callback of each button, 'style' is a string, either Error, Notify or Confirm"
		end
		if funcNameOrFunc == "GetFontHeight" or funcNameOrFunc == t.GetFontHeight then
			return "Function GetFontHeight.  " .. 
			       "Arguments: (font, fontSize). " .. 
			       "Side effect: returns the size in pixels of the given font + fontSize"
		end
		if funcNameOrFunc == "LayoutGuiObjects" or funcNameOrFunc == t.LayoutGuiObjects then
		
		end
		if funcNameOrFunc == "CreateScrollingFrame" or funcNameOrFunc == t.CreateScrollingFrame then
			return "Function CreateScrollingFrame.  " .. 
			   "Arguments: (orderList, style) " .. 
			   "Side effect: returns 4 objects, (scrollFrame, scrollUpButton, scrollDownButton, recalculateFunction).  'scrollFrame' can be filled with GuiObjects.  It will lay them out and allow scrollUpButton/scrollDownButton to interact with them.  Orderlist is optional (and specifies the order to layout the children.  Without orderlist, it uses the children order. style is also optional, and allows for a 'grid' styling if style is passed 'grid' as a string.  recalculateFunction can be called when a relayout is needed (when orderList changes)"
		end
		if funcNameOrFunc == "CreateTrueScrollingFrame" or funcNameOrFunc == t.CreateTrueScrollingFrame then
			return "Function CreateTrueScrollingFrame.  " .. 
			   "Arguments: (nil) " .. 
			   "Side effect: returns 2 objects, (scrollFrame, controlFrame).  'scrollFrame' can be filled with GuiObjects, and they will be clipped if not inside the frame's bounds. controlFrame has children scrollup and scrolldown, as well as a slider.  controlFrame can be parented to any guiobject and it will readjust itself to fit."
		end
		if funcNameOrFunc == "AutoTruncateTextObject" or funcNameOrFunc == t.AutoTruncateTextObject then
			return "Function AutoTruncateTextObject.  " .. 
			   "Arguments: (textLabel) " .. 
			   "Side effect: returns 2 objects, (textLabel, changeText).  The 'textLabel' input is modified to automatically truncate text (with ellipsis), if it gets too small to fit.  'changeText' is a function that can be used to change the text, it takes 1 string as an argument"
		end
		if funcNameOrFunc == "CreateSlider" or funcNameOrFunc == t.CreateSlider then
			return "Function CreateSlider.  " ..
				"Arguments: (steps, width, position) " ..
				"Side effect: returns 2 objects, (sliderGui, sliderPosition).  The 'steps' argument specifies how many different positions the slider can hold along the bar.  'width' specifies in pixels how wide the bar should be (modifiable afterwards if desired). 'position' argument should be a UDim2 for slider positioning. 'sliderPosition' is an IntValue whose current .Value specifies the specific step the slider is currently on."
		end
		if funcNameOrFunc == "CreateSliderNew" or funcNameOrFunc == t.CreateSliderNew then
			return "Function CreateSliderNew.  " ..
				"Arguments: (steps, width, position) " ..
				"Side effect: returns 2 objects, (sliderGui, sliderPosition).  The 'steps' argument specifies how many different positions the slider can hold along the bar.  'width' specifies in pixels how wide the bar should be (modifiable afterwards if desired). 'position' argument should be a UDim2 for slider positioning. 'sliderPosition' is an IntValue whose current .Value specifies the specific step the slider is currently on."
		end
		if funcNameOrFunc == "CreateLoadingFrame" or funcNameOrFunc == t.CreateLoadingFrame then
			return "Function CreateLoadingFrame.  " ..
				"Arguments: (name, size, position) " ..
				"Side effect: Creates a gui that can be manipulated to show progress for a particular action.  Name appears above the loading bar, and size and position are udim2 values (both size and position are optional arguments).  Returns 3 arguments, the first being the gui created. The second being updateLoadingGuiPercent, which is a bindable function.  This function takes one argument (two optionally), which should be a number between 0 and 1, representing the percentage the loading gui should be at.  The second argument to this function is a boolean value that if set to true will tween the current percentage value to the new percentage value, therefore our third argument is how long this tween should take. Our third returned argument is a BindableEvent, that when fired means that someone clicked the cancel button on the dialog."
		end
		if funcNameOrFunc == "CreateTerrainMaterialSelector" or funcNameOrFunc == t.CreateTerrainMaterialSelector then
			return "Function CreateTerrainMaterialSelector.  " ..
				"Arguments: (size, position) " ..
				"Side effect: Size and position are UDim2 values that specifies the selector's size and position.  Both size and position are optional arguments. This method returns 3 objects (terrainSelectorGui, terrainSelected, forceTerrainSelection).  terrainSelectorGui is just the gui object that we generate with this function, parent it as you like. TerrainSelected is a BindableEvent that is fired whenever a new terrain type is selected in the gui.  ForceTerrainSelection is a function that takes an argument of Enum.CellMaterial and will force the gui to show that material as currently selected."
		end
	end
	

-- general functions
function waitForProperty(instance, name)
	while not instance[name] do
		instance.Changed:wait()
	end
end
function waitForChild(instance, name)
	while not instance:FindFirstChild(name) do
		instance.ChildAdded:wait()
	end
end

local RbxGui
if LoadLibrary then
	RbxGui = t
else
	return
end

local isRestricted = (game.PlaceId == 41324860 or game.PlaceId == 129686177)
local Tool = script.Parent

enabled = true
game:GetService("ContentProvider"):Preload("http://www.roblox.com/asset/?id=59785529")
game:GetService("ContentProvider"):Preload("http://www.roblox.com/asset/?id=61423967")
game:GetService("ContentProvider"):Preload("http://www.roblox.com/asset/?id=61427382")

local configIconImage = "http://www.roblox.com/asset/?id=59785529"
local configIconOverImage = "http://www.roblox.com/asset/?id=61423967"
local configIconHoverImage = "http://www.roblox.com/asset/?id=61427382"
local highlightedImage = nil

waitForChild(Tool, "PlayerOwner")
local playerOwner = Tool.PlayerOwner

local STATIC_BASE_PLATE = nil

local ServiceConnections

local guiMain
local screen

local selectionGui

local player
local playerArea

local canTween = true
local gridRecalc
local lastPart

local lastConfig = nil
local lastVehicleSeat = nil
local origValueMap = {}

local valueConnections = {}

local objectValueSelect = {}

local adornmentTable = {}

local colorPaletteSelectMode = false

local needsIconReset = false

local textSize = 5

--Constants
local width = UDim.new(3, 0)
local height = 20 
local transparency = 0.5
local buttonColor = BrickColor.new("Mid gray")
local frameColor = BrickColor.new("Pastel yellow")


local function isInModel(part)
	if part == game.Workspace then
		return false, nil
	elseif part:IsA("Model") then
		return true, part
	else
		return isInModel(part.Parent)
	end
end


function constrained(valueObject)
	return (valueObject:IsA("IntConstrainedValue") or valueObject:IsA("DoubleConstrainedValue"))
end

function sharedProcess(name, parentFrame)
	local subFrame = Instance.new("Frame")
	subFrame.Name = name
	subFrame.Size = UDim2.new(1.0, 0, 0, height)
	subFrame.BackgroundTransparency = 1.0
	subFrame.BorderSizePixel = 0
	
	local label = Instance.new("TextLabel")
	label.Font = Enum.Font.ArialBold
	label.Position = UDim2.new(0.0, 0, 0.0, 0)
	label.Size = UDim2.new(0.5, 0, 1.0, 0)
	label.FontSize = textSize
	label.TextColor = BrickColor.White()
	label.Text = name
	label.Parent = subFrame
	label.BackgroundTransparency = 1.0
	label.BorderSizePixel = 0

	return subFrame
end

function createTextBox(size, text)
	local textBox = Instance.new("TextBox")
	textBox.Position = UDim2.new(0.5, 1, 0.0, 1)
	textBox.Size = size
	textBox.BackgroundTransparency = 1
	textBox.FontSize = textSize - 3
	textBox.TextColor3 = Color3.new(1,1,1)
	textBox.Text = text	
	textBox.ZIndex = 2

	local textBoxBacking = Instance.new("TextButton")
	textBoxBacking.Text = ""
	textBoxBacking.Style = Enum.ButtonStyle.RobloxButtonDefault
	textBoxBacking.Size = UDim2.new(1,0,1,0)
	textBoxBacking.Parent = textBox

	return textBox
end

function setCheckBoxValue(checkBox, value)
	if value then
		checkBox.Text = "X"
	else
		checkBox.Text = ""
	end
end
function createCheckBox(value)
	local checkBox = Instance.new("TextButton")
	checkBox.Position = UDim2.new(0.75, -(height-4)/2, 0.0, 2)
	checkBox.Size = UDim2.new(0.0, height-4, 0.0, height-4)
	checkBox.Style = Enum.ButtonStyle.RobloxButtonDefault
	checkBox.TextColor3 = Color3.new(1,1,1)
	checkBox.FontSize = textSize
	setCheckBoxValue(checkBox, value)
	return checkBox
end



function processBoolValue(value, guiFrame)
	local subFrame = sharedProcess(value.Name, guiFrame)
	local checkBox = createCheckBox(value.Value)
	
	--Tie the two values together... we'll need to break these connections later
	checkBox.MouseButton1Down:connect(function() value.Value = not(value.Value) end)
	valueConnections[#valueConnections+1] = value.Changed:connect(function(newValue) setCheckBoxValue(checkBox, newValue) end)	
	checkBox.Parent = subFrame
	return subFrame
end

function processConstrainedNumberValue(value, guiFrame)
	local subFrame = sharedProcess(value.Name, guiFrame)
	local textBox = createTextBox(UDim2.new(0.5,-2, 1.0, -2), value.ConstrainedValue, function(textBox) value.ConstrainedValue = textBox.Text end)
	textBox.Name = value.Name

	--Tie the two values together... we'll need to break these connections later
	textBox.Changed:connect(function(prop)
		if prop == "Text" then
			local prevValue = value.ConstrainedValue
			if textBox.Text ~= "" then
				pcall(function() value.ConstrainedValue = textBox.Text end)
			end
			textBox.Text = value.ConstrainedValue
		end
	end)
	valueConnections[#valueConnections+1] = value.Changed:connect(function(newValue) textBox.Text = newValue end)
	
	textBox.Parent = subFrame
	return subFrame;
end

function processIntValue(value, guiFrame)
	local subFrame = sharedProcess(value.Name, guiFrame)
	local textBox = createTextBox(UDim2.new(0.5,-2, 1.0, -2), value.Value, function(textBox) value.Value = textBox.Text end)
	textBox.Name = value.Name

	--Tie the two values together... we'll need to break these connections later
	textBox.Changed:connect(function(prop)
		if prop == "Text" then
			local prevValue = value.Value
			if textBox.Text ~= "" then
				pcall(function() value.Value = textBox.Text end)
			end
			textBox.Text = value.Value
		end
	end)
	valueConnections[#valueConnections+1] = value.Changed:connect(function(newValue) textBox.Text = newValue end)
	
	textBox.Parent = subFrame
	return subFrame;
end

function processPropertyValue(object, name, field, guiFrame)
	origValueMap[name] = object[field]

	local subFrame = sharedProcess(name, guiFrame)
	local textBox = createTextBox(UDim2.new(0.5,-2, 1.0, -2), object[field], function(textBox) object[field] = textBox.Text end)
	textBox.Name = name

	--Tie the two values together... we'll need to break these connections later
	textBox.Changed:connect(function(prop) 
		if prop == "Text" then
			if textBox.Text ~= "" then
				local success = pcall(function() object[field] = textBox.Text end)
			end
			textBox.Text = object[field]
		end
	end)

	valueConnections[#valueConnections+1] = object.Changed:connect(function(property) if property == field then textBox.Text = object[field] end end)
	
	textBox.Parent = subFrame
	return subFrame
end


function processEnumValue(value, guiFrame)
	local subFrame = sharedProcess(value.Name, guiFrame)

	local valueChildren = value:GetChildren()
	local enumNames = {}
	for i = 1, #valueChildren do
		if valueChildren[i]:IsA("BoolValue") and valueChildren[i].Value == true then
			table.insert(enumNames,valueChildren[i].Name)
		end
	end

	local valueToChange = value
	local enumSelect = function(item)
		valueToChange.Value = tostring(item)
	end

	local dropDownEnumMenu, updateEnumSelection = RbxGui.CreateDropDownMenu(enumNames, enumSelect)
	dropDownEnumMenu.Position = UDim2.new(0.5,0,0,0)
	dropDownEnumMenu.Size = UDim2.new(0.5,0,0,20)
	dropDownEnumMenu.Parent = subFrame

	for i = 1, #valueChildren do
		if value.Value == valueChildren[i].Name then
			dropDownEnumMenu.DropDownMenuButton.Text = valueChildren[i].Name
			break
		end
	end

	return subFrame
end



function processNumberValue(value, guiFrame)
	return processIntValue(value, guiFrame)
end


function processStringValue(value, guiFrame)
	return processIntValue(value, guiFrame)
end

function inBaseplate(instance)
	if instance == STATIC_BASE_PLATE then return true end

	local instanceCopy = instance

	while instanceCopy and (instanceCopy.Parent ~= nil or instanceCopy.Parent ~= game.Workspace) do
		if instanceCopy.Parent == STATIC_BASE_PLATE then
			return true
		end
		instanceCopy = instanceCopy.Parent
	end

	return false
end

function onMouseLeave(hoverSelection, selectedButtonTable, oldButton)
	if oldButton[0] then
		local notSelected = true;
		local selectionText = "";
		for key, value in pairs(selectedButtonTable) do
			if oldButton[0] == value then
				notSelected = false
			else
				selectionText = value.BackgroundColor.Name;
			end
		end
		if notSelected then
			hoverSelection.Text = selectionText;
			oldButton[0].Parent.BackgroundColor = BrickColor.Black();
		end
	end
	oldButton[0] = nil
end

function onMouseEnter(hoverSelection, guiButton, selectedButtonTable, oldButton)
	onMouseLeave(hoverSelection, selectedButtonTable, oldButton)
	hoverSelection.Text = guiButton.BackgroundColor.Name
	if guiButton ~= selectedButton then
		guiButton.Parent.BackgroundColor = BrickColor.White();
		oldButton[0] = guiButton
	end
end

function changeColorSelection(colorHolder, paletteFrame, guiButton, selectedButtonTable)
	if selectedButtonTable[colorHolder] ~= nil then
		selectedButtonTable[colorHolder].Parent.BackgroundColor = BrickColor.Black();
	end

	guiButton.Parent.BackgroundColor = BrickColor.Yellow();
	colorHolder.BackgroundColor = guiButton.BackgroundColor
	selectedButtonTable[colorHolder] = guiButton
end

function onMouseUp(colorHolder, paletteFrame, guiButton, selectedButtonTable)
	changeColorSelection(colorHolder, paletteFrame, guiButton, selectedButtonTable)

	onMouseLeavePalette(paletteFrame)
end

function onShowColorDialog(paletteFrame)
	paletteFrame.Visible = not(paletteFrame.Visible)
	colorPaletteSelectMode = true
end


function onMouseEnterPalette(mouse)
	colorPaletteSelectMode = true
end
function onMouseLeavePalette(paletteFrame)
	colorPaletteSelectMode = false
	paletteFrame.Visible = false
end

function processBrickColorValue(value, guiFrame)
	local subFrame = sharedProcess(value.Name, guiFrame)

	local sideBar = Instance.new("Frame")
	sideBar.Position = UDim2.new(0.5, 0, 0.0, 0)
	sideBar.Size = UDim2.new(0.5, 0, 1.0, 0)
	sideBar.BackgroundTransparency = 1.0
	sideBar.Parent = subFrame
	sideBar.BorderSizePixel = 0

	local primaryColor = Instance.new("TextButton")
	primaryColor.Position = UDim2.new(0.0, 1, 0.0, 1)
	primaryColor.Size = UDim2.new(0.0, height-2, 0, height-2)
	primaryColor.Text  = ""	
	primaryColor.FontSize = textSize
	primaryColor.BackgroundColor = value.Value
	primaryColor.BorderColor = BrickColor.Black()
	primaryColor.Parent = sideBar

	local hoverSelection = Instance.new("TextLabel")
	hoverSelection.Position = UDim2.new(0.0, height+2, 0.0, 0)
	hoverSelection.Size = UDim2.new(1.0, -height - 4, 1.0, 0)
	hoverSelection.Text = ""
	hoverSelection.Font = Enum.Font.ArialBold
	hoverSelection.FontSize = textSize
	hoverSelection.BackgroundTransparency = 1.0
	hoverSelection.BorderSizePixel = 0
	hoverSelection.TextColor = BrickColor.White()
	hoverSelection.Text = primaryColor.BackgroundColor.Name;
	hoverSelection.Parent = sideBar

	local paletteFrame = Instance.new("Frame")
	paletteFrame.Position = UDim2.new(primaryColor.Position.X.Scale, primaryColor.Position.X.Offset + height, primaryColor.Position.Y.Scale, primaryColor.Position.Y.Offset - height*7)
	paletteFrame.Size = UDim2.new(0, height*8, 0, height*8)
	paletteFrame.BackgroundColor = BrickColor.White()
	paletteFrame.BorderColor = BrickColor.White()
	paletteFrame.Visible = false;
	paletteFrame.Parent = sideBar
	paletteFrame.ZIndex = 2
	paletteFrame.MouseEnter:connect(function() onMouseEnterPalette(mouse) end)
	paletteFrame.MouseLeave:connect(function() onMouseLeavePalette(paletteFrame, mouse) end)

	primaryColor.MouseButton1Down:connect(function() onShowColorDialog(paletteFrame) end)

	local selectedButtonTable = {}
	local colorButtonTable = {}
	local oldButton = {}
	for xOffset = 0, 7 do
		for yOffset = 0,7 do
			local guiFrame = Instance.new("Frame")
			guiFrame.Position = UDim2.new(1.0/8 * xOffset, 0, 1.0/8*yOffset, 0)
			guiFrame.Size = UDim2.new(1.0/8, 0, 1.0/8, 0)
			guiFrame.BackgroundColor = BrickColor.White();
			guiFrame.BorderSizePixel = 0
			guiFrame.Parent = paletteFrame;
			guiFrame.ZIndex = 2
		
			local guiButton = Instance.new("TextButton")
			guiButton.FontSize = textSize
			guiButton.Position = UDim2.new(0.0, 1, 0.0, 1)
			guiButton.Size = UDim2.new(1.0, -2, 1.0, -2)
			guiButton.Text = ""
			guiButton.BorderSizePixel = 0
			guiButton.AutoButtonColor = false
			local color = BrickColor.palette(xOffset + yOffset*8)
			colorButtonTable[color.Number] = guiButton
			guiButton.BackgroundColor = color
			guiButton.MouseEnter:connect(function() onMouseEnter(hoverSelection, guiButton, selectedButtonTable, oldButton) end)
			guiButton.MouseButton1Up:connect(function() onMouseUp(primaryColor, paletteFrame, guiButton, selectedButtonTable, oldButton) end)
			guiButton.MouseButton1Up:connect(function() value.Value = guiButton.BackgroundColor end)
			guiButton.Parent = guiFrame
			guiButton.ZIndex = 2

			if guiButton.BackgroundColor == primaryColor.BackgroundColor then
				guiFrame.BackgroundColor = BrickColor.White()
				selectedButtonTable[primaryColor] = guiButton
			end
		end
	end

	valueConnections[#valueConnections+1] = value.Changed:connect(function(newValue) changeColorSelection(primaryColor, paletteFrame, colorButtonTable[newValue.Number], selectedButtonTable) end)	
	return subFrame
end


function onObjectValueMouseClick(guiFrame, value, objectButton)
	objectValueSelect["Value"] = value
	objectValueSelect["Frame"] = guiFrame
	objectValueSelect["Enabled"] = true

	onObjectValueMouseLeave(value, objectButton)
end

function onObjectValueMouseEnter(value, objectButton)
	objectValueSelect["HoverValue"] = value
	if value.Value then
		objectButton.BackgroundColor = BrickColor.Blue()
	else
		objectButton.BackgroundColor = BrickColor.White()
	end
end
	
function onObjectValueMouseLeave(value, objectButton)
	if objectValueSelect["HoverValue"] == value then
		objectValueSelect["HoverValue"] = nil
	end
	objectButton.BackgroundColor = buttonColor
end

function onObjectValueCancel()
	if objectValueSelect["Enabled"] then
		objectValueSelect["Enabled"] = false

		objectValueSelect["Frame"].Visible = true
		objectValueSelect["Frame"] = nil
		objectValueSelect["Value"] = nil
	end
end

function on3dObjectValueButton1Up(mouse, guiMain)
	local part = mouse.Target
	if part ~= nil then
		objectValueSelect["Value"].Value = part

		objectValueSelect["Enabled"] = false

		objectValueSelect["Frame"].Visible = true

		objectValueSelect["Frame"] = nil
		objectValueSelect["Value"] = nil
	end
end

function on3dObjectValueMouseMove(mouse, guiMain)
end

function setObjectButtonText(guiFrame, objectButton, objectValue)
	if objectValueSelect["Enabled"] and objectValue == objectValueSelect["Value"] then
		guiFrame.Visible = true
		objectValueSelect["Enabled"] = false
		objectValueSelect["Value"] = nil
	end

	if  objectValue.Value ~= nil then
		objectButton.Text = objectValue.Value.Name
	else
		objectButton.Text = "[nil]"
	end
	objectButton.BackgroundColor = buttonColor
end

function processObjectValue(value, playerGui, guiFrame)
	local subFrame = sharedProcess(value.Name, guiFrame)
	local objectButton = Instance.new("TextButton")
	objectButton.FontSize = textSize
	objectButton.Position = UDim2.new(0.5, 2, 0.0, 2)
	objectButton.Size = UDim2.new(0.5, -4, 1.0, -4)
	objectButton.BackgroundColor = BrickColor.White()
	objectButton.TextColor = BrickColor.Black()
	objectButton.Parent = subFrame
	objectButton.AutoButtonColor = false

	objectButton.MouseButton1Click:connect(function() onObjectValueMouseClick(guiFrame, value, objectButton) end)
	objectButton.MouseEnter:connect(function() onObjectValueMouseEnter(value, objectButton) end)
	objectButton.MouseLeave:connect(function() onObjectValueMouseLeave(value, objectButton) end)

	valueConnections[#valueConnections+1] = value.Changed:connect(function(newObjectValue) setObjectButtonText(guiFrame, objectButton, value) end)	

	setObjectButtonText(guiFrame, objectButton, value)
	return subFrame
end


function processValue(value, playerGui, guiFrame)
	if constrained(value) then origValueMap[value.Name] = value.ConstrainedValue
	else origValueMap[value.Name] = value.Value end

	if #value:GetChildren() &gt; 0 and value:IsA("StringValue") then
		return processEnumValue(value, guiFrame)
	else
		if value.className == "BoolValue" then
			return processBoolValue(value, guiFrame)
		elseif value.className == "IntValue" then
			return processIntValue(value, guiFrame)
		elseif value.className == "NumberValue" then
			return processNumberValue(value, guiFrame)
		elseif value.className == "StringValue" then
			return processStringValue(value, guiFrame)
		elseif value.className == "ObjectValue" then
			return processObjectValue(value, playerGui, guiFrame)
		elseif value.className == "BrickColorValue" then
			return processBrickColorValue(value, guiFrame)
		elseif value.className == "IntConstrainedValue" or value.className == "DoubleConstrainedValue" then
			return processConstrainedNumberValue(value, guiFrame)
		else
			return nil
		end
	end
end

function killFrame(frame)
	screen.Enabled = false
	frame:remove()
end

function closeFrame(frame)
	lastPart = nil
	if frame.Parent == nil then return end
	frame:TweenSizeAndPosition(UDim2.new(0,0,0,0),UDim2.new(0.5,0,0.5,0),Enum.EasingDirection.In,Enum.EasingStyle.Back,0.5, true, function() killFrame(frame) end)
end

function allowTween()
	canTween = true
end

function openFrame(frame,size)
	if not canTween then return end
	canTween = false
	screen.Enabled = true
	frame.Size = UDim2.new(0,0,0,0)
	frame.Position = UDim2.new(0.5,0,0.5,0)
	frame:TweenSizeAndPosition(size,UDim2.new(0,0,0,0),Enum.EasingDirection.Out,Enum.EasingStyle.Back,0.5,true, function() allowTween() end)
end

function sharedMain(name, playerGui)
	local parentFrame = Instance.new("Frame")
	parentFrame.Style = Enum.FrameStyle.RobloxRound
	parentFrame.Active = true
	parentFrame.Name = "MainFrame"
	parentFrame.Size = UDim2.new(1, 0, 1, 0)
	parentFrame.BackgroundTransparency = 1

	local titleLabel = Instance.new("TextLabel")
	titleLabel.Name = "TitleLabel"
	titleLabel.Font = Enum.Font.ArialBold
	titleLabel.FontSize = textSize + 2
	titleLabel.Size = UDim2.new(1.0, 0.0, 0.0, height)
	titleLabel.TextColor = BrickColor.White()
	titleLabel.BackgroundColor = BrickColor.new("Cool yellow")
	titleLabel.BackgroundTransparency = 1
	titleLabel.Text = name
	titleLabel.Parent = parentFrame

	local closeButton = Instance.new("TextButton")
	closeButton.Name = "CloseButton"
	closeButton.Style = Enum.ButtonStyle.RobloxButtonDefault
	closeButton.Size = UDim2.new(0,20,0,20)
	closeButton.Position = UDim2.new(1,-16,0,-5)
	closeButton.Text = "X"
	closeButton.TextColor3 = Color3.new(1,1,1)
	closeButton.Font = Enum.Font.ArialBold
	closeButton.FontSize = Enum.FontSize.Size18
	closeButton.Parent = parentFrame

	local closeCon = nil
	closeCon = closeButton.MouseButton1Click:connect(function()
		closeCon:disconnect()
		removeBillboards()
		screen.Enabled = false
		cancelSelectionGui()
	end)

	local scrollFrame, scrollUpButton, scrollDownButton, recalculateFunction = RbxGui.CreateScrollingFrame()
	gridRecalc = recalculateFunction
	scrollFrame.Name = "ValueContainer"
	scrollFrame.Size = UDim2.new(1,-17,1,-50)
	scrollFrame.Position = UDim2.new(0,0,0,25)
	scrollFrame.Parent = parentFrame

	local changerCon = nil
	delay(1,function()
		if scrollFrame and scrollFrame.Parent then
			changerCon = scrollFrame.Changed:connect(function(prop)
				if prop == "AbsoluteSize" then
					if scrollFrame.AbsoluteSize.Y &lt; 38 then
						changerCon:disconnect()
						closeFrame(parentFrame)
					else
						gridRecalc()
					end
				end
			end)
		end
	end)

	local dieCon
	dieCon = scrollFrame.AncestryChanged:connect(function(child,parent)
		if parent == nil then
			dieCon:disconnect()
			if changerCon then changerCon:disconnect() end
		end
	end)

	local scrollButtonFrame = Instance.new("Frame")
	scrollButtonFrame.Name = "ScrollButtonFrame"
	scrollButtonFrame.Position = UDim2.new(1,-17,0,25)
	scrollButtonFrame.Size = UDim2.new(0,17,1,-50)
	scrollButtonFrame.BackgroundTransparency = 1
	scrollButtonFrame.Parent = parentFrame

	scrollUpButton.Parent = scrollButtonFrame
	scrollDownButton.Parent = scrollButtonFrame
	scrollDownButton.Position = UDim2.new(0,0,1,-17)
	

	return parentFrame
end

function sharedButtons(parentFrame, valueChildren)
	local buttonFrame = Instance.new("Frame")
	buttonFrame.Name = "Buttons"
	buttonFrame.BackgroundTransparency = 1.0
	buttonFrame.Size = UDim2.new(1.0, 0.0, 0.0, height)
	buttonFrame.Position = UDim2.new(0.0, 0, 1, -25)
	buttonFrame.Parent = parentFrame
	valueChildren = valueChildren + 1

	local okButton = Instance.new("TextButton")
	okButton.FontSize = textSize
	okButton.Name = "OkButton"
	okButton.Font = Enum.Font.ArialBold
	okButton.TextColor = BrickColor.White()
	okButton.Style = Enum.ButtonStyle.RobloxButton
	okButton.Text = "Ok"
	okButton.Size = UDim2.new(.25, -4, 0.0, height + 5)
	okButton.Position = UDim2.new(0.55, 2, 0.0, 2)
	okButton.BackgroundColor = buttonColor
	okButton.MouseButton1Click:connect(function() removeSelectionGui() end)
	okButton.Parent = buttonFrame

	local cancelButton = okButton:clone()
	cancelButton.Name = "cancelButton"
	cancelButton.Text  = "Cancel"
	cancelButton.Position = UDim2.new(0.200000003, 2, 0, 2)
	cancelButton.MouseButton1Click:connect(function() cancelSelectionGui() end)
	cancelButton.Parent = buttonFrame
end

function processVehicleSeat(vehicleSeat, playerGui, valueChildren)
	local parentFrame = sharedMain(vehicleSeat.Name, playerGui)
	lastVehicleSeat = vehicleSeat

	local valueChildren = 1
	local fields = {"MaxSpeed", "Steer", "Torque", "TurnSpeed"}
	for pos, field in pairs(fields) do
		local newFrame = processPropertyValue(vehicleSeat, field, field, guiFrame)
		if newFrame then
			newFrame.Position = UDim2.new(0.0, 0, 0.0, (valueChildren*height) - height)
			newFrame.Parent = parentFrame.ValueContainer
			valueChildren = valueChildren + 1
		end

	end

	sharedButtons(parentFrame, valueChildren)
	return parentFrame
end

function processConfiguration(config, playerGui)
	local parentFrame = sharedMain(config.Name, playerGui)
	lastConfig = config

	local valueChildren = 1
	local children = config:GetChildren() 
	if children then
		for pos, child in pairs(children) do
			local newFrame = processValue(child, playerGui, parentFrame)
			if newFrame then
				newFrame.Position = UDim2.new(0.0, 0, 0.0, (valueChildren*height) - height)
				newFrame.Parent = parentFrame.ValueContainer
				valueChildren = valueChildren + 1
			end
		end
	end
	
	sharedButtons(parentFrame, valueChildren)
	return parentFrame
end

function on3dMouseMove(mouse, guiMain)
	if mouse.Target and canSelectObject(mouse.Target) then

		local part = mouse.Target
		if part:IsA("VehicleSeat") then
			foundPart = part
		else
			foundPart = findConfiguration(part)
		end

		if foundPart then
			if objectValueSelect["HoverBox"] then 
				local isModel, model = isInModel(part)
				local adornee = part
				if isModel then
					adornee = model
				end

				objectValueSelect["HoverBox"].Adornee = adornee
				local billboard = getBillboard(adornee)

				local configBadge = billboard:FindFirstChild("ConfigBadge",true)
				if configBadge then
					configBadge.Image = configIconOverImage
					highlightedImage = configBadge
				end
			end
			needsIconReset = true
		else
			if needsIconReset then
				if objectValueSelect["HoverBox"] then objectValueSelect["HoverBox"].Adornee = nil end
				needsIconReset = false

				if highlightedImage then 
					highlightedImage.Image = configIconImage
				end
			end
		end
	else
		if needsIconReset then
			if objectValueSelect["HoverBox"] then objectValueSelect["HoverBox"].Adornee = nil end
			needsIconReset = false

			if highlightedImage then 
				highlightedImage.Image = configIconImage
			end
		end
	end

	if objectValueSelect["Enabled"] then
		on3dObjectValueMouseMove(mouse, guiMain)
	end
end

function cancelSelectionGui()
	lastPart = nil

	if selectionGui ~= nil then
		closeFrame(selectionGui)
		selectionGui = nil
		for pos, connection in pairs(valueConnections) do
			connection:disconnect()
		end
		valueConnections = {}
	end

	showConfigurationAnnotations()

	if lastConfig then
		local configValues = lastConfig:GetChildren()
		for i = 1, #configValues do
			if origValueMap[configValues[i].Name] ~= nil then
				if constrained(configValues[i]) then configValues[i].ConstrainedValue = origValueMap[configValues[i].Name]
				else configValues[i].Value = origValueMap[configValues[i].Name] end

				origValueMap[configValues[i].Name] = nil
			end
		end
	elseif lastVehicleSeat then
		lastVehicleSeat.MaxSpeed = origValueMap["MaxSpeed"]
		origValueMap["MaxSpeed"] = nil
		lastVehicleSeat.Steer = origValueMap["Steer"]
		origValueMap["Steer"] = nil
		lastVehicleSeat.Torque = origValueMap["Torque"]
		origValueMap["Torque"] = nil
		lastVehicleSeat.TurnSpeed = origValueMap["TurnSpeed"]
		origValueMap["TurnSpeed"] = nil
	end
end

function removeSelectionGui()
	if selectionGui ~= nil then
		closeFrame(selectionGui)
		for pos, connection in pairs(valueConnections) do
			connection:disconnect()
		end
		valueConnections = {}
	end

	if objectValueSelect["HoverBox"] then objectValueSelect["HoverBox"].Adornee = nil end

	showConfigurationAnnotations()

	if lastConfig then
		local configValues = lastConfig:GetChildren()
		for i = 1, #configValues do
			if origValueMap[configValues[i].Name] ~= nil then
				origValueMap[configValues[i].Name] = nil
			end
		end
	end
end

function canSelectObject(part)
	if isRestricted then
		waitForChild(playerArea,"PlayerArea")
		if isRestricted and playerArea:FindFirstChild("PlayerArea") and part:IsDescendantOf(playerArea.PlayerArea) then
			return part and not (part.Locked) and part:IsA("BasePart") and (part.Position - Tool.Parent.Head.Position).Magnitude &lt; 60
		else
			return false
		end
	end

	return part and not (part.Locked) and part:IsA("BasePart") and (part.Position - Tool.Parent.Head.Position).Magnitude &lt; 60
end

local function findConfigInModel(model)
	local children = model:GetChildren()
	for i = 1, #children do
		if children[i]:IsA("Configuration") or children[i]:IsA("VehicleSeat") then
			return children[i]
		end
	end
	for i = 1, #children do
		if #children[i]:GetChildren() &gt; 0 then
			local returnValue = findConfigInModel(children[i])
			if returnValue ~= nil then
				return returnValue
			end
		end
	end

	return nil
end

function findConfiguration(part)
	local partInModel, model = isInModel(part)
	if partInModel then
		local isModelConfig = findConfigInModel(model)
		return isModelConfig
	else
		local children = part:GetChildren() 		
		if children then
			for pos, child in pairs(children) do
				if child:IsA("Configuration") or child:IsA("VehicleSeat") then
					return child
				end
			end
		end
	end
	return nil
end

function removeBillboards()
	local guis = guiMain:GetChildren()
	for i = 1, #guis do
		if guis[i]:IsA("Frame") then
			guis[i]:remove()
		end
	end
end

function on3dButton1Up(mouse, guiMain, playerGui)
	if objectValueSelect["Enabled"] then
		on3dObjectValueButton1Up(mouse, guiMain)
		return
	elseif canSelectObject(mouse.Target) then
		local part = mouse.Target
		local foundPart = nil
		if part:IsA("VehicleSeat") then
			foundPart = part
		else
			foundPart = findConfiguration(part)
		end
	
		if foundPart then
			
			if foundPart == lastPart then
				return
			end
			lastPart = foundPart

			removeBillboards()
			screen.Enabled = true

			if foundPart:IsA("Configuration") then
				selectionGui = processConfiguration(foundPart, playerGui)
			else
				selectionGui = processVehicleSeat(foundPart, playerGui)	
			end
			selectionGui.Parent = guiMain
			openFrame(selectionGui, selectionGui.Size)

			local hasModel, model = isInModel(part)
			if hasModel then
				screen.Adornee = model
			else
				screen.Adornee = part
			end

			if highlightedImage then 
				highlightedImage.Image = configIconImage
			end
		end
	else
		cancelSelectionGui()
	end
end

function onEquippedLocal(mouse)
	local character = script.Parent.Parent
	player = game.Players:GetPlayerFromCharacter(character)

	if player == nil then return end
	if playerOwner.Value and playerOwner.Value ~= player then return end
	playerOwner.Value = player

	if isRestricted then
		waitForChild(game.Workspace,"BuildingAreas")
		waitForChild(game.Workspace.BuildingAreas,"Area1")
		waitForChild(game.Workspace.BuildingAreas.Area1,"Player")
		local areas = game.Workspace.BuildingAreas:GetChildren()
		for i = 1, #areas do
			if areas[i]:FindFirstChild("Player") and areas[i].Player.Value == player.Name then
				playerArea = areas[i]
				break
			end
		end
		waitForChild(playerArea,"PlayerArea")
		STATIC_BASE_PLATE = playerArea.PlayerArea
	end

	if not screen then
		screen = Instance.new("BillboardGui")
		screen.Name = "ConfigGui"
		screen.Size = UDim2.new(0,360,0,180)
		screen.Enabled = false
		screen.Active = true
		screen.Parent = player.PlayerGui
		screen.AlwaysOnTop = true

		guiMain = Instance.new("Frame")
		guiMain.BackgroundTransparency = 1
		guiMain.Size = UDim2.new(1,0,1,0)
		guiMain.Parent = screen
	else
		removeBillboards()
		lastPart = nil
		screen.Parent = player.PlayerGui
	end

	setUpConfigurationService(guiMain)
	showConfigurationAnnotations()

	mouse.Icon = "http://www.roblox.com/asset?id=66887593"
	mouse.Button1Up:connect(function() on3dButton1Up(mouse, guiMain, player.PlayerGui) end)
	mouse.Move:connect(function() on3dMouseMove(mouse, guiMain) end)

	objectValueSelect.HoverBox = Instance.new("SelectionBox")
	objectValueSelect.HoverBox.Name = "HoverBox"
	objectValueSelect.HoverBox.Color = BrickColor.new("Really blue")
	objectValueSelect.HoverBox.Transparency = 0.5
	objectValueSelect.HoverBox.Adornee = nil
	objectValueSelect.HoverBox.Parent = player.PlayerGui;
end

function onUnequippedLocal()

	local guiChildren = game.Players.LocalPlayer.PlayerGui:GetChildren()
	for i = 1, #guiChildren do
		if guiChildren[i]:IsA("BillboardGui") then
			guiChildren[i].Parent = nil
		end
	end

	destroyConfigurationService()

	objectValueSelect.HoverBox:Remove()

	if screen then
		screen.Parent = nil
	end

	player = nil

	hideConfigurationAnnotations()

	objectValueSelect = {}
end


local configTable = {}

function createVisualAnnotation(config, guiMain)
	local selection = Instance.new("SelectionBox")
	selection.Name = "Annotation"
	selection.Color = BrickColor.new("Really blue")
	selection.Transparency = 0.5
	selection.Parent = guiMain.Parent
	return selection
end

function configurationParentChanged(data, part)
	local isModel, model = isInModel(part)
	if not isModel then
		data["VisualAnnotation"].Adornee = part
	else
		data["VisualAnnotation"].Adornee = model
	end
end

function showConfigurationAnnotations()
	for config, data in pairs(configTable) do
		data["VisualAnnotation"].Visible = true
	end
end


function hideConfigurationAnnotations()
	for config, data in pairs(configTable) do
		data["VisualAnnotation"].Visible = false
	end
end

local function isInMyArea(part)
	if part.Parent == nil then return false end
	if part.Parent:FindFirstChild("Player") and part.Parent.Player:IsA("StringValue") then
		if part.Parent.Player.Value == player.Name then
			return true
		else
			return false
		end
	elseif part.Parent == game.Workspace.BuildingAreas or part.Parent == game.Workspace then
		return false
	else
		return isInMyArea(part.Parent)
	end
end

function findBillboard(guiTable)
	if not guiTable then return end

	for i = 1, #guiTable do
		if guiTable[i] and guiTable[i]:IsA("BillboardGui") then
			return guiTable[i]
		end
	end
end

function getBillboard(adornee)
	local guiKey = adornee
	
	local billboard = findBillboard(adornmentTable[guiKey])
	if not billboard then
		local screen = Instance.new("BillboardGui")
		screen.Name = adornee.Name .. "BadgeGUI"
		screen.Size = UDim2.new(1.5,0,1.5,0)
		screen.Enabled = true
		screen.Active = true
		screen.AlwaysOnTop = true
		screen.ExtentsOffset = Vector3.new(0,0,0)
		screen.Adornee = adornee
		screen.Parent = game.Players.LocalPlayer.PlayerGui

		if not adornmentTable[guiKey] then 
			adornmentTable[guiKey] = {}
		end
		table.insert(adornmentTable[guiKey],screen)

		return screen
	end

	return billboard
end

function hasBadge(adornee)
	local screen = getBillboard(adornee)
	if not screen then return false end
	return screen:FindFirstChild("Badge",true)
end

function removeBadge(adornee)
	local screen = getBillboard(adornee)
	local badge = screen:FindFirstChild("ConfigBadge",true)
	if badge then badge:remove() end
end

function giveConfigBadge(adornee)
	local billboard = getBillboard(adornee)

	local configBadge = Instance.new("ImageLabel")
	configBadge.Name = "ConfigBadge"
	configBadge.BackgroundTransparency = 1
	configBadge.Image = configIconImage
	configBadge.Size = UDim2.new(1,0,1,0)
	configBadge.Parent = billboard

	billboard.Parent =  game.Players.LocalPlayer.PlayerGui

	local badgeCon = configBadge.Changed:connect(function(prop)
		if prop == "AbsoluteSize" then
			configBadge.Visible = (configBadge.AbsoluteSize.X &gt; 10)
		end
	end)

	local enterCon = configBadge.MouseEnter:connect(function()
		configBadge.Image = configIconHoverImage
	end)

	local leaveCon = configBadge.MouseLeave:connect(function()
		configBadge.Image = configIconImage
	end)

	local killCon = nil
	killCon = configBadge.AncestryChanged:connect(function(child,parent)
		if parent == nil then
			killCon:disconnect()
			badgeCon:disconnect()
			enterCon:disconnect()
			leaveCon:disconnect()
		end
	end)
end

function configurationAdded(config, guiMain)
	if configTable[config] then
		return
	end

	if isRestricted and not inBaseplate(config) then return end
	
	local data = {}
	data.Configuration = config
	data.VisualAnnotation = createVisualAnnotation(config, guiMain)
	if config:IsA("Configuration") then
		data.Connection = config.AncestryChanged:connect(function(child, newParent)
			if child == config then
				configurationParentChanged(data, newParent)
			end
		end)
		configurationParentChanged(data, config.Parent)
	else
		configurationParentChanged(data, config)
	end

	local partInModel, model = isInModel(config.Parent)
	if partInModel then
		if not hasBadge(model) then
			giveConfigBadge(model)
		end
	else
		if not hasBadge(config.Parent) then
			giveConfigBadge(config.Parent)
		end
	end

	configTable[config] = data
end

function configurationRemoved(config)

	local data = configTable[config]	
	if not(data) then
		--I have no opinion about this
		return
	end

	if data.Connection then
		data.Connection:disconnect()
	end

	data.VisualAnnotation:Remove()
	removeBadge(config.Parent)
	
	configTable[config] = nil
end

function findVehicleSeats(object, guiMain)
	if object:IsA("VehicleSeat") then
		configurationAdded(object, guiMain)
	end
	for index,child in pairs(object:GetChildren()) do
		findVehicleSeats(child, guiMain)
	end
end

function setUpConfigurationService(guiMain)
	ServiceConnections = {}
	local collectionService = game:GetService("CollectionService")

	ServiceConnections[#ServiceConnections+1] = collectionService.ItemAdded:connect(function(instance) if instance:IsA("Configuration") then configurationAdded(instance, guiMain) end end)
	ServiceConnections[#ServiceConnections+1] = collectionService.ItemRemoved:connect(function(instance) if instance:IsA("Configuration") then configurationRemoved(instance) end end)

	local configs = collectionService:GetCollection("Configuration")
	if configs then
		for pos, config in pairs(configs) do
			configurationAdded(config, guiMain)
		end
	end

	ServiceConnections[#ServiceConnections+1] = game.workspace.DescendantAdded:connect(function(instance) if instance:IsA("VehicleSeat") then configurationAdded(instance, guiMain) end end)
	ServiceConnections[#ServiceConnections+1] = game.workspace.DescendantRemoving:connect(function(instance) if instance:IsA("VehicleSeat") then configurationRemoved(instance) end end)
	findVehicleSeats(game.workspace, guiMain)

end

function destroyConfigurationService()
	for config, data in pairs(configTable) do
		configurationRemoved(config)
	end
	for index, connection in pairs(ServiceConnections) do
		connection:disconnect()
	end
	ServiceConnections = {}
end


Tool.Equipped:connect(onEquippedLocal)
Tool.Unequipped:connect(onUnequippedLocal)</ProtectedString>
			</Properties>
		</Item>
		<Item class="ObjectValue" referent="RBX31">
			<Properties>
				<string name="Name">PlayerOwner</string>
				<Ref name="Value">null</Ref>
			</Properties>
		</Item>
	</Item>
	<Item class="Tool" referent="RBX32">
		<Properties>
			<bool name="CanBeDropped">true</bool>
			<bool name="Enabled">true</bool>
			<CoordinateFrame name="Grip">
				<X>0</X>
				<Y>0</Y>
				<Z>-0.5</Z>
				<R00>0</R00>
				<R01>0</R01>
				<R02>1</R02>
				<R10>1</R10>
				<R11>0</R11>
				<R12>0</R12>
				<R20>0</R20>
				<R21>1</R21>
				<R22>0</R22>
			</CoordinateFrame>
			<string name="Name">DeleteTool</string>
			<Content name="TextureId"><url>rbxasset://../../../shareddata/textures/55212908.png</url></Content>
			<string name="ToolTip"></string>
		</Properties>
		<Item class="Part" referent="RBX33">
			<Properties>
				<bool name="Anchored">false</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">0</token>
				<token name="BottomSurfaceInput">0</token>
				<int name="BrickColor">199</int>
				<CoordinateFrame name="CFrame">
					<X>-325.425781</X>
					<Y>9.58191395</Y>
					<Z>7.98407602</Z>
					<R00>0.56549412</R00>
					<R01>-0.628281116</R01>
					<R02>-0.534302533</R02>
					<R10>0.529940367</R10>
					<R11>-0.219604015</R11>
					<R12>0.819107533</R12>
					<R20>-0.631964862</R20>
					<R21>-0.746348977</R21>
					<R22>0.208766758</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<float name="Elasticity">0.5</float>
				<float name="Friction">0.300000012</float>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">true</bool>
				<token name="Material">256</token>
				<string name="Name">Handle</string>
				<float name="Reflectance">0.400000006</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<Vector3 name="RotVelocity">
					<X>25.0305233</X>
					<Y>-47.3610191</Y>
					<Z>-6.09125948</Z>
				</Vector3>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">0</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>-0.632513762</X>
					<Y>-6.44036388</Y>
					<Z>2.01790714</Z>
				</Vector3>
				<token name="formFactorRaw">2</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>1</X>
					<Y>0.800000012</Y>
					<Z>3</Z>
				</Vector3>
			</Properties>
			<Item class="SpecialMesh" referent="RBX34">
				<Properties>
					<token name="LODX">2</token>
					<token name="LODY">2</token>
					<Content name="MeshId"><url>rbxasset://../../../shareddata/fonts/16198309.mesh</url></Content>
					<token name="MeshType">5</token>
					<string name="Name">Mesh</string>
					<Vector3 name="Offset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<Vector3 name="Scale">
						<X>1.20000005</X>
						<Y>1.20000005</Y>
						<Z>1.20000005</Z>
					</Vector3>
					<Content name="TextureId"><url>rbxasset://../../../shareddata/textures/16198294.png</url></Content>
					<Vector3 name="VertexColor">
						<X>1</X>
						<Y>1</Y>
						<Z>1</Z>
					</Vector3>
				</Properties>
			</Item>
			<Item class="Sound" referent="RBX35">
				<Properties>
					<bool name="Looped">false</bool>
					<string name="Name">Sound</string>
					<float name="Pitch">1</float>
					<bool name="PlayOnRemove">false</bool>
					<Content name="SoundId"><url>http://www.roblox.com/Asset/?ID=12135982</url></Content>
					<float name="Volume">0.699999988</float>
				</Properties>
			</Item>
		</Item>
		<Item class="LocalScript" referent="RBX36">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Model Delete Local</string>
				<ProtectedString name="Source">function waitForChild(instance, name)
	while not instance:FindFirstChild(name) do
		instance.ChildAdded:wait()
	end
end


local Tool = script.Parent

enabled = true
game:GetService("ContentProvider"):Preload("rbxasset://icons/delete_sel.png")

local cluster = nil

local selectionBox
local currentSelection
local currentSelectionColors = {}
local selectionLasso

local deleteDistance = 100
local player = nil
--local playerModel = nil
local playerModel = game.Workspace
local buildingPlate = nil

local highlight = false

local megaClusterSelectionBox = Instance.new("Part")
megaClusterSelectionBox.FormFactor = "Custom"
megaClusterSelectionBox.Size = Vector3.new(4, 4, 4) -- a little thicker than 4x4x4 unit clusterpart; just so selection box is more easily seen
megaClusterSelectionBox.Transparency = 1
megaClusterSelectionBox.Anchored = true
megaClusterSelectionBox.CanCollide = false
megaClusterSelectionBox.Parent = nil

waitForChild(Tool, "IsRestricted")
local isRestricted = Tool.IsRestricted.Value

waitForChild(Tool, "AutoWedgeClusterParts")
local autoWedgeClusterParts = Tool.AutoWedgeClusterParts.Value

function hint(label)

	-- Pass in a string, it shows a top hint.  (Replaces previous hint, if exists)
	_player = game.Players:GetPlayerFromCharacter(Tool.Parent)
	if(_player ~= nil and _player.PlayerGui:FindFirstChild("topHint")~=nil) then
		local topHint = _player.PlayerGui.topHint
		topHint.Add.Label.Value = label
		topHint.Add.Width.Value = 3 -- widest width
		topHint.Add.Time.Value = 5
		topHint.Add.Disabled = true
		topHint.Add.Disabled = false
	end

end

function canDeleteObject(part)
	-- let them delete anything that they created *or* anything on their baseplate
	return part and not (part.Locked) and part:IsA("BasePart") and (part.Position - Tool.Parent.Head.Position).Magnitude &lt; deleteDistance and (isChildOfMyModel(part) or partInBounds(part))
end

-- For Restricting Stamper Tool (isRestricted)
function inBounds(part)

	if part == nil then return false end

	if part:IsA("Part") or part:IsA("WedgePart") or part:IsA("TrussPart") then
		if not partInBounds(part) then return false end
	elseif part:IsA("Model") then
		local primPart = object.PrimaryPart
		if not partInBounds(primPart) then return false end
	end

	return true

end

function partInBounds(part)

	local xOne = buildingPlate.Position.x + buildingPlate.Size.x/2
	local xTwo = buildingPlate.Position.x - buildingPlate.Size.x/2
	local zOne = buildingPlate.Position.z + buildingPlate.Size.z/2
	local zTwo = buildingPlate.Position.z - buildingPlate.Size.z/2

	if part.Position.x &gt; xOne or part.Position.x &lt; xTwo then return false end
	if part.Position.z &gt; zOne or part.Position.z &lt; zTwo then return false end

	return true

end


function findModel(part)
	while part ~= nil do
		if part.className == "Model" and part.Name ~= playerModel.Name and part.Name ~= "GarbageParts" then
			return part
		elseif part.Name == playerModel.Name or part.Name == "GarbageParts" then
			return nil
		end
		part = part.Parent
	end

	return nil
end

function cleanOrphanedModel(parent)
	if not parent then return end
	if parent.className == "Model" then
		local children = parent:GetChildren()
		if #children == 0 and parent.Name ~= "GarbageParts" then
			local oldParent = parent.Parent
			parent:Remove()
			cleanOrphanedModel(oldParent)
		end
	end
end

function isChildOfMyModel(part)
		if not playerModel then return true end
		if playerModel:IsAncestorOf(part) then
			return true
		else return false end
end


-- Cyrion's auto-wedge fcn:
--sets cell x, y, z to default material if parameter is provided, if not sets cell x, y, z to be whatever material it previously was
--returns true if made a wedge, false if the cell remains a block
function MakeWedge(x, y, z, defaultmaterial)
	local c = game.Workspace.Terrain
	--gather info about all the cells around x, y, z
	surroundings = {} --surroundings is a 3 x 3 x 3 array of the material of the cells adjacent to x, y, z
	for i = x - 1, x + 1 do
		surroundings[i] = {}
		for j = y - 1, y + 1 do
			surroundings[i][j] = {}
			for k = z - 1, z + 1 do
				local material, wedge, rotation = c:GetCell(i, j, k)
				surroundings[i][j][k] = material.Value
			end
		end
	end
	--make some useful arrays and counters
	local sides = {} --sides is an array of the material of the 4 adjacent sides
	sides[0] = surroundings[x - 1][y][z]
	sides[1] = surroundings[x][y][z + 1]
	sides[2] = surroundings[x + 1][y][z]
	sides[3] = surroundings[x][y][z - 1]
	local adjacentSides = 0
	for n = 0, 3 do
		if sides[n] &gt; 0 then
			adjacentSides = adjacentSides + 1
		end
	end
	local sidesAbove = {} --sides is an array of the material of the 4 adjacent sides 1 height above
	sidesAbove[0] = surroundings[x - 1][y + 1][z]
	sidesAbove[1] = surroundings[x][y + 1][z + 1]
	sidesAbove[2] = surroundings[x + 1][y + 1][z]
	sidesAbove[3] = surroundings[x][y + 1][z - 1]
	local adjacentSidesAbove = 0
	for n = 0, 3 do
		if sidesAbove[n] &gt; 0 then
			adjacentSidesAbove = adjacentSidesAbove + 1
		end
	end
	local corners = {} --corners is an array of the material of the 4 adjacent corners
	corners[0] = surroundings[x - 1][y][z - 1]
	corners[1] = surroundings[x - 1][y][z + 1]
	corners[2] = surroundings[x + 1][y][z + 1]
	corners[3] = surroundings[x + 1][y][z - 1]
	local adjacentCorners = 0
	for n = 0, 3 do
		if corners[n] &gt; 0 then
			adjacentCorners = adjacentCorners + 1
		end
	end
	local cornersAbove = {} --corners is an array of the material of the 4 adjacent corners 1 height above
	cornersAbove[0] = surroundings[x - 1][y + 1][z - 1]
	cornersAbove[1] = surroundings[x - 1][y + 1][z + 1]
	cornersAbove[2] = surroundings[x + 1][y + 1][z + 1]
	cornersAbove[3] = surroundings[x + 1][y + 1][z - 1]
	local adjacentCornersAbove = 0
	for n = 0, 3 do
		if cornersAbove[n] &gt; 0 then
			adjacentCornersAbove = adjacentCornersAbove + 1
		end
	end
	--determine what type of wedge to make
	local material = nil
	local wedge = nil
	local rotation = nil 
	if defaultmaterial then
		material = defaultmaterial
	else
		material, wedge, rotation = c:GetCell(x, y, z) --start with the existing material, wedge, and rotation
	end
	wedge = 0 --default wedge is a block
	rotation = 0 --default rotation is 0
	--type 1: 45 degree ramp //must not have a block on top and must have a block under, and be surrounded by 1 side; or 3 sides and the 2 corners between them
	if surroundings[x][y + 1][z] == 0 and surroundings[x][y - 1][z] &gt; 0 then
		if adjacentSides == 1 then
			for n = 0, 3 do
				if sides[n] &gt; 0 then
					wedge = 1
					rotation = (n + 1) % 4
					c:SetCell(x, y, z, material, wedge, rotation)
					return true
				end
			end
		elseif  adjacentSides == 3 then
			for n = 0, 3 do
				if sides[n] &gt; 0 and corners[(n + 1) % 4] &gt; 0 and sides[(n + 1) % 4] &gt; 0 and corners[(n + 2) % 4] &gt; 0 and sides[(n + 2) % 4] &gt; 0 then
					wedge = 1
					rotation = (n + 2) % 4
					c:SetCell(x, y, z, material, wedge, rotation)
					return true
				end
			end
		end
	end
	--type 2: 45 degree corner //must not have a block on top and must have a block under, and be surrounded by 2 sides and the 1 corner between them; or 3 sides and 1 corner between 2 of them (facing towards that corner)
	if surroundings[x][y + 1][z] == 0 and surroundings[x][y - 1][z] &gt; 0 then
		for n = 0, 3 do
			if sides[n] &gt; 0 and corners[(n + 1) % 4] &gt; 0 and sides[(n + 1) % 4] &gt; 0 and (adjacentSides == 2 or (adjacentSides == 3 and (corners[(n + 3) % 4] &gt; 0 or (sides[(n + 2) % 4] &gt; 0 and corners[(n + 2) % 4] &gt; 0) or (sides[(n + 3) % 4] &gt; 0 and corners[n] &gt; 0)))) then
				wedge = 2
				rotation = (n + 2) % 4
				c:SetCell(x, y, z, material, wedge, rotation)
				return true
			end
		end
	end
	--type 3: 45 degree inverse corner //surrounded by three sides or 4 sides and 3 corners, with nothing above or else a block on top surrounded on 2 sides and the corner between them
	if adjacentSides == 3 and surroundings[x][y + 1][z] &gt; 0 then
		if adjacentCorners &gt; 1 then
			for n = 0, 3 do
				if (corners[n] == 0 or cornersAbove[n] == 0) and (sides[(n - 1) % 4] == 0 or sides[n] == 0) and (sidesAbove[n] == 0 and sidesAbove[(n + 1) % 4] &gt; 0 and sidesAbove[(n + 2) % 4] &gt; 0 and sidesAbove[(n + 3) % 4] == 0) then 
					wedge = 3
					rotation = (n + 3) % 4
					c:SetCell(x, y, z, material, wedge, rotation)
					return true
				end
			end
		end
	elseif adjacentSides == 4 and adjacentCorners == 3 then
		for n = 0, 3 do
			if corners[n] == 0 and (surroundings[x][y + 1][z] == 0 or (sidesAbove[n] == 0 and sidesAbove[(n + 1) % 4] &gt; 0 and cornersAbove[(n + 2) % 4] &gt; 0 and sidesAbove[(n + 2) % 4] &gt; 0 and sidesAbove[(n + 3) % 4] == 0)) then
				wedge = 3
				rotation = (n + 3) % 4
				c:SetCell(x, y, z, material, wedge, rotation)
				return true
			end
		end
	end
	--type 4: half a cube, as if it were cut diagonally from front to back //surrounded by 2 sides
	if adjacentSides == 2 and adjacentCorners &lt; 4 then
		for n = 0, 3 do
			if sides[n] == 0 and sides[(n + 1) % 4] == 0 and (surroundings[x][y + 1][z] == 0 or (sidesAbove[n] == 0 and sidesAbove[(n + 1) % 4] == 0 and sidesAbove[(n + 2) % 4] &gt; 0 and sidesAbove[(n + 3) % 4] &gt; 0)) then
				wedge = 4
				rotation = n
				c:SetCell(x, y, z, material, wedge, rotation)
				return true
			end
		end
	end
	c:SetCell(x, y, z, material, wedge, rotation)
	return false
end

function on3dButton1Down(mouse)
	local part = mouse.Target

	if part == nil then 
		return
	elseif part:IsA("Terrain") then
		if cluster ~= nil then
			local cellPos = cluster:WorldToCellPreferSolid(Vector3.new(mouse.Hit.x, mouse.Hit.y, mouse.Hit.z))
			local x = cellPos.x
			local y = cellPos.y
			local z = cellPos.z

			cluster:SetCell(x, y, z, 0, 0, 0)
			
			if (autoWedgeClusterParts) then

				for i = x - 1, x + 1 do
					for j = y - 1, y + 1 do
						for k = z - 1, z + 1 do
							MakeWedge(i, j, k)
						end
					end
				end

			end

			clearSelection()
			on3dMouseMove(mouse)

		end
	elseif canDeleteObject(part) then
		local model = findModel(part)
		local oldParent
		if model then 
			if currentSelection == model then
				currentSelection = nil
				clearSelection()
			end
			oldParent = model.Parent
			model:Remove()
		else
			if currentSelection == part then
				currentSelection = nil
				clearSelection()
			end
			oldParent = part.Parent
			part:Remove()
		end
		cleanOrphanedModel(oldParent)
	end
end

function saveSelectionColor(instance)
	if instance:IsA("BasePart") then
		currentSelectionColors[instance] = instance.BrickColor
		if instance.BrickColor == BrickColor.Red() then
			instance.BrickColor = BrickColor.new("Really red")
		else
			instance.BrickColor = BrickColor.Red()
		end
	end
end
	
function setSelection(partOrModel)
	if partOrModel ~= currentSelection then
		clearSelection()
		currentSelection = partOrModel
		selectionBox.Adornee = currentSelection
	end
end

function clearSelection()
	if currentSelection ~= nil then
		for part, color in pairs(currentSelectionColors) do
			part.BrickColor = color
		end
		selectionBox.Adornee = nil
	end
	currentSelectionColors = {}
	if currentSelection then currentSelection = nil end
	if selectionBox then selectionBox.Adornee = nil end
	megaClusterSelectionBox.Parent = nil
end


function on3dMouseMove(mouse) 
	if isRestricted then
		mouse.TargetFilter = game.Workspace.BaseplateBumpers
	else
		mouse.TargetFilter = megaClusterSelectionBox
	end
	local part = mouse.Target

	if not part then
		clearSelection() 
		return
	elseif part:IsA("Terrain") then
		if not cluster then cluster = game.Workspace.Terrain end
		local hitCell = cluster:WorldToCellPreferSolid(mouse.Hit.p)
		if cluster:GetCell(hitCell.x, hitCell.y, hitCell.z).Value &gt; 0 then
			megaClusterSelectionBox.CFrame = CFrame.new(cluster:CellCenterToWorld(hitCell.x, hitCell.y, hitCell.z))

			if isRestricted then megaClusterSelectionBox.Parent = game.Workspace.BaseplateBumpers else megaClusterSelectionBox.Parent = game.Workspace end
			selectionBox.Adornee = megaClusterSelectionBox
		else
			clearSelection()
			return
		end
	elseif canDeleteObject(part) then
		local model = findModel(part)
		if model then 		
			selectionBox.Color = BrickColor.Red()
			setSelection(model)
		else
			selectionBox.Color = BrickColor.Red()
			setSelection(part)
		end
	else
		clearSelection()
	end
end

local equipCount = 0
function onEquippedLocal(mouse)
	equipCount = equipCount + 1
	local val = equipCount

	if isRestricted then
		waitForChild(game.Workspace, "BuildingAreas")
		if val ~= equipCount then
			return
		end
	end

	local character = script.Parent.Parent
	player = game.Players:GetPlayerFromCharacter(character)
	
	if not player then return end

	if isRestricted then
		local takenAreas = game.Workspace.BuildingAreas:GetChildren()
		for i = 1, #takenAreas do
				if takenAreas[i]:FindFirstChild("Player") ~= nil then  -- Test if child exists (to fix current bug: "Player" child is omitted from 1 baseplate at random, when played online.)
					if takenAreas[i].Player.Value == Tool.Parent.Name then
						buildingPlate = takenAreas[i].PlayerArea.BasePlate
						break
					end
				end
		end
	end

   if buildingPlate then
		playerModel  = buildingPlate.Parent
	else
		--playerModel  = nil
		playerModel = game.Workspace
	end
	guiMain = Instance.new("ScreenGui")
	guiMain.Parent = player.PlayerGui

	mouse.Button1Down:connect(function() on3dButton1Down(mouse) end)
	mouse.Move:connect(function() on3dMouseMove(mouse) end)
	mouse.Icon ="rbxasset://textures\\HammerCursor.png"

	selectionBox = Instance.new("SelectionBox")
	selectionBox.Name = "Model Delete Selection"
	selectionBox.Color = BrickColor.Red()
	selectionBox.Adornee = nil
	selectionBox.Parent = player.PlayerGui

	selectionLasso = Instance.new("SelectionPartLasso")
	selectionLasso.Name = "Model Delete Lasso"
	selectionLasso.Humanoid = character.Humanoid
	selectionLasso.archivable = false
	selectionLasso.Visible = true
	selectionLasso.Parent = game.workspace
	selectionLasso.Color = BrickColor.Red()

	highlight = true
end

function onUnequippedLocal()
	highlight = false
	if selectionBox then
		clearSelection()
		selectionBox:Remove()
	end
	if selectionLasso then selectionLasso:Remove() end
end


Tool.Equipped:connect(onEquippedLocal)
Tool.Unequipped:connect(onUnequippedLocal)
</ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX37">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">SwordScript</string>
				<ProtectedString name="Source">-------- OMG HAX

r = game:service("RunService")


local damage = 0


local slash_damage = 0


sword = script.Parent.Handle
Tool = script.Parent



function attack()
	local anim = Instance.new("StringValue")
	anim.Name = "toolanim"
	anim.Value = "Slash"
	anim.Parent = Tool
end


function swordUp()
	Tool.GripForward = Vector3.new(-1,0,0)
	Tool.GripRight = Vector3.new(0,1,0)
	Tool.GripUp = Vector3.new(0,0,1)
end

function swordOut()
	Tool.GripForward = Vector3.new(0,0,1)
	Tool.GripRight = Vector3.new(0,-1,0)
	Tool.GripUp = Vector3.new(-1,0,0)
end



Tool.Enabled = true

function onActivated()

	if not Tool.Enabled then
		return
	end

	Tool.Enabled = false

	local character = Tool.Parent;
	local humanoid = character.Humanoid
	if humanoid == nil then
		return 
	end

	

	attack()

	wait(1)

	Tool.Enabled = true
end


script.Parent.Activated:connect(onActivated)

</ProtectedString>
			</Properties>
		</Item>
		<Item class="BoolValue" referent="RBX38">
			<Properties>
				<string name="Name">IsRestricted</string>
				<bool name="Value">false</bool>
			</Properties>
		</Item>
		<Item class="BoolValue" referent="RBX39">
			<Properties>
				<string name="Name">AutoWedgeClusterParts</string>
				<bool name="Value">false</bool>
			</Properties>
		</Item>
	</Item>
	<Item class="Tool" referent="RBX40">
		<Properties>
			<bool name="CanBeDropped">true</bool>
			<bool name="Enabled">true</bool>
			<CoordinateFrame name="Grip">
				<X>0</X>
				<Y>0</Y>
				<Z>-0.699999988</Z>
				<R00>-0</R00>
				<R01>0</R01>
				<R02>1</R02>
				<R10>1</R10>
				<R11>-0</R11>
				<R12>0</R12>
				<R20>0</R20>
				<R21>1</R21>
				<R22>0</R22>
			</CoordinateFrame>
			<string name="Name">RotateTool</string>
			<Content name="TextureId"><url>rbxasset://../../../shareddata/textures/59103214.png</url></Content>
			<string name="ToolTip">Rotate</string>
		</Properties>
		<Item class="Part" referent="RBX41">
			<Properties>
				<bool name="Anchored">false</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">0</token>
				<token name="BottomSurfaceInput">0</token>
				<int name="BrickColor">199</int>
				<CoordinateFrame name="CFrame">
					<X>-348.126465</X>
					<Y>22.9737568</Y>
					<Z>-33.3428497</Z>
					<R00>-0.827723265</R00>
					<R01>0.538811445</R01>
					<R02>-0.15670456</R02>
					<R10>0.246336192</R10>
					<R11>0.097995162</R11>
					<R12>-0.964217544</R12>
					<R20>-0.504175186</R20>
					<R21>-0.836707354</R21>
					<R22>-0.213841558</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<float name="Elasticity">0.5</float>
				<float name="Friction">0.300000012</float>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">true</bool>
				<token name="Material">256</token>
				<string name="Name">Handle</string>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<Vector3 name="RotVelocity">
					<X>8.72971153</X>
					<Y>16.4864178</Y>
					<Z>17.5190411</Z>
				</Vector3>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">0</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>-6.03426361</X>
					<Y>19.2309494</Y>
					<Z>-11.73279</Z>
				</Vector3>
				<token name="formFactorRaw">1</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>1</X>
					<Y>0.800000012</Y>
					<Z>2</Z>
				</Vector3>
			</Properties>
			<Item class="SpecialMesh" referent="RBX42">
				<Properties>
					<token name="LODX">2</token>
					<token name="LODY">2</token>
					<Content name="MeshId"><url>rbxasset://../../../shareddata/fonts/16884681.mesh</url></Content>
					<token name="MeshType">5</token>
					<string name="Name">Mesh</string>
					<Vector3 name="Offset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<Vector3 name="Scale">
						<X>0.600000024</X>
						<Y>0.600000024</Y>
						<Z>0.600000024</Z>
					</Vector3>
					<Content name="TextureId"><url>rbxasset://../../../shareddata/textures/16884673.png</url></Content>
					<Vector3 name="VertexColor">
						<X>1</X>
						<Y>1</Y>
						<Z>1</Z>
					</Vector3>
				</Properties>
			</Item>
		</Item>
		<Item class="LocalScript" referent="RBX43">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">RotateScript</string>
				<ProtectedString name="Source">-- NOTES:
--      NEEDS:
--            X  1.)  Make single blocks rotate always (they rotate 2x, then seem to think of themselves as blockers of themselves...  whaaa?)
--				  X  2.)  Make scripts continue to work through rotations (or else error on any objects which can't be rotated...  prehaps elevators?)
--            3.)  File bug for #1 and for "# of parts counted BEFORE instance-filter is applied for game.Workspace:FindPartsInRegion3"
--            4.)  Make things rotate separately (break and make welds)
--				  5.)  When something else is attached to a single block, stuff still breaks X&lt;

-- general functions
function waitForProperty(instance, name)
	while not instance[name] do
		instance.Changed:wait()
	end
end
function waitForChild(instance, name)
	while not instance:FindFirstChild(name) do
		instance.ChildAdded:wait()
	end
end

local Tool = script.Parent
local player
local playerArea = nil
local selectionBox = nil
local selectedModel = nil

local terrainSelectionBox = Instance.new("Part")
terrainSelectionBox.Parent = nil
terrainSelectionBox.formFactor = "Custom"
terrainSelectionBox.Size = Vector3.new(4, 4, 4)
terrainSelectionBox.CFrame = CFrame.new()

local cluster = nil

waitForChild(Tool, "ErrorBox")
local errorBox = Tool.ErrorBox

waitForChild(Tool, "PlayerOwner")
local playerOwner = Tool.PlayerOwner

waitForProperty(game,"PlaceId")
local isRestricted = (game.PlaceId == 41324860 or game.PlaceId == 129686177)

game:GetService("ContentProvider"):Preload("rbxasset://icons/configure_sel.png")


function getBoundingBox2(partOrModel)
-- for models, the bounding box is defined as the minimum and maximum individual part bounding boxes
-- relative to the first part's coordinate frame.

	local minVec = Vector3.new(math.huge, math.huge, math.huge)
	local maxVec = Vector3.new(-math.huge, -math.huge, -math.huge)

	if partOrModel:IsA("Part") or partOrModel:IsA("WedgePart") or partOrModel:IsA("TrussPart")then
		minVec = partOrModel.CFrame:pointToWorldSpace(-0.5 * partOrModel.Size)
		maxVec = partOrModel.CFrame:pointToWorldSpace(0.5 * partOrModel.Size)
	else
		local part1 = partOrModel:GetChildren()[1]
		for i, object in pairs(partOrModel:GetChildren()) do
			if (object:IsA("Part") or object:IsA("WedgePart") or object:IsA("TrussPart")) then
				boxMinInWorld1 = object.CFrame:pointToWorldSpace(-0.5 * object.Size)
				--boxMinInPart1 = part1.CFrame:pointToObjectSpace(boxMinInWorld)
				boxMaxInWorld1 = object.CFrame:pointToWorldSpace(0.5 * object.Size)
				--boxMaxInPart1 = part1.CFrame:pointToObjectSpace(boxMaxInWorld)

				local minX = minVec.x
				local minY = minVec.y
				local minZ = minVec.z
				local maxX = maxVec.x
				local maxY = maxVec.y
				local maxZ = maxVec.z
				if boxMinInWorld1.x &lt; minVec.x then
					minX = boxMinInWorld1.x
				end
				if boxMinInWorld1.y &lt; minVec.y then
					minY = boxMinInWorld1.y
				end
				if boxMinInWorld1.z &lt; minVec.z then
					minZ = boxMinInWorld1.z
				end
				if boxMaxInWorld1.x &lt; minX then
					minX = boxMaxInWorld1.x
				end
				if boxMaxInWorld1.y &lt; minY then
					minY = boxMaxInWorld1.y
				end
				if boxMaxInWorld1.z &lt; minZ then
					minZ = boxMaxInWorld1.z
				end

				if boxMinInWorld1.x &gt; maxVec.x then
					maxX = boxMinInWorld1.x
				end
				if boxMinInWorld1.y &gt; maxVec.y then
					maxY = boxMinInWorld1.y
				end
				if boxMinInWorld1.z &gt; maxVec.z then
					maxZ = boxMinInWorld1.z
				end
				if boxMaxInWorld1.x &gt; maxX then
					maxX = boxMaxInWorld1.x
				end
				if boxMaxInWorld1.y &gt; maxY then
					maxY = boxMaxInWorld1.y
				end
				if boxMaxInWorld1.z &gt; maxZ then
					maxZ = boxMaxInWorld1.z
				end

				minVec = Vector3.new(minX, minY, minZ)
				maxVec = Vector3.new(maxX, maxY, maxZ)
			end
		end
	end

	return minVec, maxVec
end

function isInRobloxModel(part)
	if part == game.Workspace then
		return false, nil
	elseif part:FindFirstChild("RobloxModel") then 
		return true, part
	else
		return isInRobloxModel(part.Parent)
	end
end

function isInMyArea(part)
	if playerArea:FindFirstChild("PlayerArea")then
		return playerArea.PlayerArea:IsAncestorOf(part)
	end
	return false
end


function on3dButton1Down(mouse)
	-- don't do anything for now (can fix later: for now this means you can click one model, drag mouse to second model, and release mouse, and this will activate second model)
end


function offsetPartsByVector3(partOrModel, offsetVector)
	local insertCFrame
	if partOrModel:IsA("Model") then
		for i, object in pairs(partOrModel:GetChildren()) do
			if (object:IsA("Part") or object:IsA("WedgePart") or object:IsA("TrussPart")) then
				object.CFrame = object.CFrame + offsetVector
			end
		end
	else
		partOrModel.CFrame = partOrModel.CFrame + offsetVector
	end
end

function storeAndDisableScriptsInModel(parent, scriptTable)
	for i, object in pairs(parent:GetChildren()) do
		if object:IsA("Script") or object:IsA("LocalScript") then if not object.Disabled then object.Disabled = true table.insert(scriptTable, object) end end
		if object.GetChildren then storeAndDisableScriptsInModel(object, scriptTable) end
	end
end

function isInternalWeld(weld, model)
	return (not weld.Part0 or weld.Part0:IsDescendantOf(model)) and (not weld.Part1 or weld.Part1:IsDescendantOf(model))
end

function storeAndRemoveWeldsInModel(initialmodel, model, welds, weldParents)
	for i, object in pairs(model:GetChildren()) do
		if object.className == "ManualWeld" then if isInternalWeld(object, initialmodel) then table.insert(welds, object) table.insert(weldParents, object.Parent) object.Parent = nil end end
		if object.GetChildren then storeAndRemoveWeldsInModel(initialmodel, object, welds, weldParents) end
	end
end


local debris = game:GetService("Debris")
function flashRedBox(modelToFlash)
	if not modelToFlash then return end 

	errorBox.Parent = player.PlayerGui
	errorBox.Adornee = modelToFlash

	delay(0,function()
		for i = 1, 3 do
			errorBox.Visible = true
			wait(0.13)
			errorBox.Visible = false
			wait(0.13)
		end
		errorBox.Adornee = nil
		errorBox.Parent = Tool
	end)
end


-- below function should work as a Region3 query, returning true if a single cluster part is within this region
function clusterPartsInRegion(startVector, endVector)
	if not cluster then return false end

	local startCell = cluster:WorldToCell(startVector)
	local endCell = cluster:WorldToCell(endVector)

	local startX = startCell.X
	local startY = startCell.Y
	local startZ = startCell.Z

	local endX = endCell.X
	local endY = endCell.Y
	local endZ = endCell.Z

	if startX &lt; cluster.MaxExtents.Min.X then startX = cluster.MaxExtents.Min.X end
	if startY &lt; cluster.MaxExtents.Min.Y then startY = cluster.MaxExtents.Min.Y end
	if startZ &lt; cluster.MaxExtents.Min.Z then startZ = cluster.MaxExtents.Min.Z end

	if endX &gt; cluster.MaxExtents.Max.X then endX = cluster.MaxExtents.Max.X end
	if endY &gt; cluster.MaxExtents.Max.Y then endY = cluster.MaxExtents.Max.Y end
	if endZ &gt; cluster.MaxExtents.Max.Z then endZ = cluster.MaxExtents.Max.Z end

	for x = startX, endX do
		for y = startY, endY do
			for z = startZ, endZ do
				if (cluster:GetCell(x, y, z).Value) &gt; 0 then return true end
			end
		end
	end

	return false
end


local debounce = false
function on3dButton1Up(mouse)
	local modelToRotate = selectedModel -- so that other mouse events can't give us race conditions

	if modelToRotate and not debounce then
		debounce = true

		if modelToRotate == terrainSelectionBox then
			-- just rotate the terrain cell if we're selecting on terrain
			local cellPos = game.Workspace.Terrain:WorldToCell(terrainSelectionBox.CFrame.p)
			local cellMat, cellType, cellOrient = game.Workspace.Terrain:GetCell(cellPos.X, cellPos.Y, cellPos.Z)
			game.Workspace.Terrain:SetCell(cellPos.X, cellPos.Y, cellPos.Z, cellMat, cellType, (cellOrient.Value + 1)%4)

			debounce = false
			return
		end

		-- get the model centroid
		local minBB, maxBB = getBoundingBox2(modelToRotate)
		local oldModelCentroid = (minBB + maxBB) / 2  -- point to rotate around

		local diagVector = minBB - oldModelCentroid
		local rotatedDiagVector = Vector3.new(diagVector.Z, diagVector.Y, diagVector.X)
		local rotatedMinBB = oldModelCentroid + rotatedDiagVector
		local rotatedMaxBB = oldModelCentroid - rotatedDiagVector

		-- check if part rotation will cause collision
		local fudgeVector = Vector3.new(0.4, 0.4, 0.4)  -- mmmmmm, fudge

		-- we need to check the even/odd parity on the x and z axes of the model.  If there is a difference, then the rotation will push the model off-grid, so we will
			--   need to adjust
		local adjustVector = Vector3.new(0, 0, 0)
		local diffVector = minBB - maxBB
		local garbage, xParity = math.modf(math.modf(math.abs(diffVector.X)/4 + .5)/2)
		local garbage, zParity = math.modf(math.modf(math.abs(diffVector.Z)/4 + .5)/2)
		xParity = math.floor(xParity*2 + .5)
		zParity = math.floor(zParity*2 + .5)
		if xParity ~= zParity then
			-- need to shift
			adjustVector = Vector3.new(2, 0, 2)
			local mouseHitFrame = mouse.Hit
			if mouseHitFrame then
				local mouseHit = mouseHitFrame.p
				if math.abs(diffVector.X) &gt; math.abs(diffVector.Z) then
					-- longest axis is X-axis
					if mouseHit.X &gt; oldModelCentroid.X then
						adjustVector = Vector3.new(2, 0, 2)
					else
						adjustVector = Vector3.new(-2, 0, -2)
					end
				else
					-- longest axis is Z-axis
					if mouseHit.Z &gt; oldModelCentroid.Z then
						adjustVector = Vector3.new(-2, 0, 2)
					else
						adjustVector = Vector3.new(2, 0, -2)
					end
				end
			end
		end
		-- below line checks CURRENT BB, not post-rotation BB
		--local blockingParts = game.Workspace:FindPartsInRegion3(Region3.new(minBB + fudgeVector, maxBB - fudgeVector), modelToRotate, 100)

		-- if blocked by the cluster, then exit out
		if cluster and clusterPartsInRegion(minBB + fudgeVector, maxBB - fudgeVector) then
			debounce = false
			flashRedBox(modelToRotate)
			return
		end

		local blockingParts = game.Workspace:FindPartsInRegion3(Region3.new(rotatedMinBB + fudgeVector + adjustVector, rotatedMaxBB - fudgeVector + adjustVector), modelToRotate, 100)

		if #blockingParts &gt; 1 or (#blockingParts &gt; 0 and blockingParts[1] ~= modelToRotate) then
			-- BLOCKED!!  MAKE ERROR NOISE!
			for j = 1, #blockingParts do 
				if blockingParts[j].className ~= "WedgePart" and (blockingParts[j].Size / 2):Dot(blockingParts[j].Size / 2) &gt; 9 and blockingParts[j] ~= modelToRotate then
					debounce = false
					flashRedBox(modelToRotate)
					return
				end
			end
		--else
		end
			-- do the rotation! :D
			local rotCF = CFrame.fromEulerAnglesXYZ(0, math.pi/2, 0)

			game.JointsService:SetJoinAfterMoveInstance(modelToRotate)
			game.JointsService:ClearJoinAfterMoveJoints()

		
			-- below simple script disabling/re-enabling works for all scripts in normal usabilityset except for elevators and retracting spike [see if just need to change "Weld" in spikescript to "ManualWeld"... may need to also make sure below script-table can store all descendent scripts of modelToRotate, and not just immediate children...]
				-- and elevator scripts only break if you rotate when the elevator is in the "fully down" position...  probably just need some sort of check in ElevatorScript for this case

			local scriptsToTurnBackOn = {}
			storeAndDisableScriptsInModel(modelToRotate, scriptsToTurnBackOn)

			local weldsToReturn = {}
			local weldParentsToReturn = {}
			storeAndRemoveWeldsInModel(modelToRotate, modelToRotate, weldsToReturn, weldParentsToReturn)

			modelToRotate:BreakJoints()

			if modelToRotate:IsA("Model") then
				for i, object in pairs(modelToRotate:GetChildren()) do
					if object:IsA("Part") or object:IsA("TrussPart") or object:IsA("WedgePart") then object.CFrame = rotCF * object.CFrame end
				end
			else
				modelToRotate.CFrame = rotCF * modelToRotate.CFrame
			end

			-- fix position so centroid remains in same place [and then move centroid by adjustVector so it stays on grid]
			local newMinBB, newMaxBB = getBoundingBox2(modelToRotate)
			local newModelCentroid = (newMinBB + newMaxBB) / 2
			offsetPartsByVector3(modelToRotate, oldModelCentroid - newModelCentroid + adjustVector)

			game.JointsService:CreateJoinAfterMoveJoints()
			modelToRotate:MakeJoints()

			-- return all manual welds
			for i = 1, #weldsToReturn do weldsToReturn[i].Parent = weldParentsToReturn[i] end

			-- turn back on scripts
			for i = 1, #scriptsToTurnBackOn do scriptsToTurnBackOn[i].Disabled = false end
		--end

		--[[ for debugging
		local tempPart = Instance.new("Part")
		tempPart.CanCollide = false
		tempPart.Anchored = true
		tempPart.Size = maxBB - minBB
		tempPart.CFrame = CFrame.new((minBB + maxBB)/2)
		tempPart.Parent = game.Workspace
		game:GetService("Debris"):AddItem(tempPart, .5) ]]--


		debounce = false
	end
end

function on3dMouseMove(mouse)
	local mouseModel

	if mouse.Target and mouse.Target:IsA("Terrain") and not isRestricted and mouse.Hit and (mouse.Hit.p - Tool.Parent.Head.Position).magnitude &lt; 60 then
		-- do something special if we're selecting close-by terrain
		selectedModel = terrainSelectionBox

		local cell = game.Workspace.Terrain:WorldToCellPreferSolid(mouse.Hit.p)
		local cellCenter = game.Workspace.Terrain:CellCenterToWorld(cell.X, cell.Y, cell.Z)
		terrainSelectionBox.CFrame = CFrame.new(cellCenter)

		selectionBox.Adornee = selectedModel
		return
	end

	if mouse.Target == nil then mouseModel = nil
	else boolGarbage, mouseModel = isInRobloxModel(mouse.Target) end

	if mouseModel == nil or (isRestricted and (not isInMyArea(mouseModel))) then mouseModel = nil end

	-- see if need to switch selectionBox
	if mouseModel ~= selectedModel then
		selectedModel = mouseModel
		selectionBox.Adornee = selectedModel
	end
end

function canSelectObject(part)
	if isRestricted then
		waitForChild(playerArea,"PlayerArea")
		if playerArea:FindFirstChild("PlayerArea") and part:IsDescendantOf(playerArea.PlayerArea) then
			return part and not (part.Locked) and part:IsA("BasePart") and (part.Position - Tool.Parent.Head.Position).Magnitude &lt; 60
		else
			return false
		end
	end

	return part and not (part.Locked) and part:IsA("BasePart") and (part.Position - Tool.Parent.Head.Position).Magnitude &lt; 60
end

function onEquippedLocal(mouse)
	if game.Workspace:FindFirstChild("Terrain") then
		cluster = game.Workspace.Terrain
	end

	local character = script.Parent.Parent
	player = game.Players:GetPlayerFromCharacter(character)

	if player == nil then return end
	if playerOwner.Value and playerOwner.Value ~= player then return end
	playerOwner.Value = player

	if isRestricted then
		waitForChild(game.Workspace,"BuildingAreas")
		waitForChild(game.Workspace.BuildingAreas,"Area1")
		waitForChild(game.Workspace.BuildingAreas.Area1,"Player")
		local areas = game.Workspace.BuildingAreas:GetChildren()
		for i = 1, #areas do
			if areas[i]:FindFirstChild("Player") and areas[i].Player.Value == player.Name then
				playerArea = areas[i]
				break
			end
		end
	end

	if game.Workspace:FindFirstChild("BaseplateBumpers") then mouse.TargetFilter = game.Workspace.BaseplateBumpers end

	mouse.Icon = "http://www.roblox.com/asset?id=67163124"
	mouse.Button1Down:connect(function() on3dButton1Down(mouse) end)
	mouse.Button1Up:connect(function() on3dButton1Up(mouse) end)
	mouse.Move:connect(function() on3dMouseMove(mouse) end)
	
	selectionBox = Instance.new("SelectionBox")
	selectionBox.Name = "MainSelectionBox"
	selectionBox.Color = BrickColor.Blue()
	selectionBox.Adornee = nil
	selectionBox.Parent = player.PlayerGui;

	on3dMouseMove(mouse) -- so if they unequip/reequip, they still have selection box
end

function onUnequippedLocal()
	if selectionBox then selectionBox:Remove() end
	selectedModel = nil
	player = nil
end


Tool.Equipped:connect(onEquippedLocal)
Tool.Unequipped:connect(onUnequippedLocal)

</ProtectedString>
			</Properties>
		</Item>
		<Item class="SelectionBox" referent="RBX44">
			<Properties>
				<Ref name="Adornee">null</Ref>
				<int name="Color">21</int>
				<string name="Name">ErrorBox</string>
				<float name="Transparency">0</float>
				<bool name="Visible">false</bool>
			</Properties>
		</Item>
		<Item class="ObjectValue" referent="RBX45">
			<Properties>
				<string name="Name">PlayerOwner</string>
				<Ref name="Value">null</Ref>
			</Properties>
		</Item>
	</Item>
	<Item class="Tool" referent="RBX46">
		<Properties>
			<bool name="CanBeDropped">true</bool>
			<bool name="Enabled">true</bool>
			<CoordinateFrame name="Grip">
				<X>0</X>
				<Y>0</Y>
				<Z>0.349999994</Z>
				<R00>1</R00>
				<R01>0</R01>
				<R02>0</R02>
				<R10>0</R10>
				<R11>1</R11>
				<R12>0</R12>
				<R20>0</R20>
				<R21>0</R21>
				<R22>1</R22>
			</CoordinateFrame>
			<string name="Name">StamperTool</string>
			<Content name="TextureId"><url>rbxasset://../../../shareddata/textures/59102781.png</url></Content>
			<string name="ToolTip"></string>
		</Properties>
		<Item class="Part" referent="RBX47">
			<Properties>
				<bool name="Anchored">false</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">4</token>
				<token name="BottomSurfaceInput">0</token>
				<int name="BrickColor">194</int>
				<CoordinateFrame name="CFrame">
					<X>-332.734894</X>
					<Y>12.5494843</Y>
					<Z>11.3863106</Z>
					<R00>0.200423956</R00>
					<R01>-0.879663825</R01>
					<R02>-0.431302607</R02>
					<R10>-0.0550297797</R10>
					<R11>-0.44964838</R11>
					<R12>0.891508937</R12>
					<R20>-0.978162587</R20>
					<R21>-0.154945284</R21>
					<R22>-0.138528109</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<float name="Elasticity">0.5</float>
				<float name="Friction">0.300000012</float>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">true</bool>
				<token name="Material">256</token>
				<string name="Name">Handle</string>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<Vector3 name="RotVelocity">
					<X>-18.069809</X>
					<Y>-6.81256485</Y>
					<Z>-13.7736206</Z>
				</Vector3>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">3</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>11.172863</X>
					<Y>-2.04021835</Y>
					<Z>-10.6246719</Z>
				</Vector3>
				<token name="formFactorRaw">1</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>1</X>
					<Y>0.400000006</Y>
					<Z>1</Z>
				</Vector3>
			</Properties>
			<Item class="SpecialMesh" referent="RBX48">
				<Properties>
					<token name="LODX">2</token>
					<token name="LODY">2</token>
					<Content name="MeshId"><url>rbxasset://../../../shareddata/fonts/42163552.mesh</url></Content>
					<token name="MeshType">5</token>
					<string name="Name">Mesh</string>
					<Vector3 name="Offset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<Vector3 name="Scale">
						<X>0.899999976</X>
						<Y>0.899999976</Y>
						<Z>0.899999976</Z>
					</Vector3>
					<Content name="TextureId"><url>rbxasset://../../../shareddata/textures/42163513.png</url></Content>
					<Vector3 name="VertexColor">
						<X>1</X>
						<Y>1</Y>
						<Z>1</Z>
					</Vector3>
				</Properties>
			</Item>
		</Item>
		<Item class="ObjectValue" referent="RBX49">
			<Properties>
				<string name="Name">PlayerOwner</string>
				<Ref name="Value">null</Ref>
			</Properties>
		</Item>
		<Item class="ObjectValue" referent="RBX50">
			<Properties>
				<string name="Name">SavedState</string>
				<Ref name="Value">null</Ref>
			</Properties>
		</Item>
		<Item class="Model" referent="RBX51">
			<Properties>
				<CoordinateFrame name="ModelInPrimary">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<string name="Name">LuaGlobalVariables</string>
				<Ref name="PrimaryPart">null</Ref>
			</Properties>
			<Item class="Model" referent="RBX52">
				<Properties>
					<CoordinateFrame name="ModelInPrimary">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">InsertAsset</string>
					<Ref name="PrimaryPart">null</Ref>
				</Properties>
				<Item class="StringValue" referent="RBX53">
					<Properties>
						<string name="Name">AssetName</string>
						<string name="Value"></string>
					</Properties>
				</Item>
				<Item class="IntValue" referent="RBX54">
					<Properties>
						<string name="Name">AssetId</string>
						<int name="Value">0</int>
					</Properties>
				</Item>
				<Item class="StringValue" referent="RBX55">
					<Properties>
						<string name="Name">Image</string>
						<string name="Value"></string>
					</Properties>
				</Item>
				<Item class="BoolValue" referent="RBX56">
					<Properties>
						<string name="Name">StampMode</string>
						<bool name="Value">true</bool>
					</Properties>
				</Item>
				<Item class="BoolValue" referent="RBX57">
					<Properties>
						<string name="Name">Updated</string>
						<bool name="Value">false</bool>
					</Properties>
				</Item>
			</Item>
			<Item class="BoolValue" referent="RBX58">
				<Properties>
					<string name="Name">SwitchLoaderToDialog</string>
					<bool name="Value">false</bool>
				</Properties>
				<Item class="StringValue" referent="RBX59">
					<Properties>
						<string name="Name">DialogType</string>
						<string name="Value">Stamp</string>
					</Properties>
				</Item>
				<Item class="StringValue" referent="RBX60">
					<Properties>
						<string name="Name">AssetImage</string>
						<string name="Value">nil</string>
					</Properties>
				</Item>
			</Item>
			<Item class="BoolValue" referent="RBX61">
				<Properties>
					<string name="Name">ShowInvalidPlacement</string>
					<bool name="Value">false</bool>
				</Properties>
			</Item>
			<Item class="BoolValue" referent="RBX62">
				<Properties>
					<string name="Name">ShowMaxedOut</string>
					<bool name="Value">false</bool>
				</Properties>
			</Item>
			<Item class="BoolValue" referent="RBX63">
				<Properties>
					<string name="Name">SwitchMode</string>
					<bool name="Value">false</bool>
				</Properties>
				<Item class="StringValue" referent="RBX64">
					<Properties>
						<string name="Name">Mode</string>
						<string name="Value"></string>
					</Properties>
				</Item>
			</Item>
			<Item class="BoolValue" referent="RBX65">
				<Properties>
					<string name="Name">Stamped</string>
					<bool name="Value">false</bool>
				</Properties>
			</Item>
			<Item class="BoolValue" referent="RBX66">
				<Properties>
					<string name="Name">Moving</string>
					<bool name="Value">false</bool>
				</Properties>
			</Item>
			<Item class="BoolValue" referent="RBX67">
				<Properties>
					<string name="Name">ShowAdminCategories</string>
					<bool name="Value">false</bool>
				</Properties>
			</Item>
			<Item class="IntValue" referent="RBX68">
				<Properties>
					<string name="Name">userIDs</string>
					<int name="Value">6</int>
				</Properties>
				<Item class="IntValue" referent="RBX69">
					<Properties>
						<string name="Name">userID</string>
						<int name="Value">11744447</int>
					</Properties>
				</Item>
				<Item class="IntValue" referent="RBX70">
					<Properties>
						<string name="Name">userID</string>
						<int name="Value">18881789</int>
					</Properties>
				</Item>
				<Item class="IntValue" referent="RBX71">
					<Properties>
						<string name="Name">userID</string>
						<int name="Value">18881808</int>
					</Properties>
				</Item>
				<Item class="IntValue" referent="RBX72">
					<Properties>
						<string name="Name">userID</string>
						<int name="Value">18881829</int>
					</Properties>
				</Item>
				<Item class="IntValue" referent="RBX73">
					<Properties>
						<string name="Name">userID</string>
						<int name="Value">18881853</int>
					</Properties>
				</Item>
				<Item class="IntValue" referent="RBX74">
					<Properties>
						<string name="Name">userID</string>
						<int name="Value">18881866</int>
					</Properties>
				</Item>
			</Item>
			<Item class="BoolValue" referent="RBX75">
				<Properties>
					<string name="Name">ReloadCurrentAsset</string>
					<bool name="Value">false</bool>
				</Properties>
			</Item>
			<Item class="BoolValue" referent="RBX76">
				<Properties>
					<string name="Name">ReloadCurrentAsset</string>
					<bool name="Value">false</bool>
				</Properties>
			</Item>
			<Item class="BoolValue" referent="RBX77">
				<Properties>
					<string name="Name">MouseClick</string>
					<bool name="Value">false</bool>
				</Properties>
			</Item>
			<Item class="BoolValue" referent="RBX78">
				<Properties>
					<string name="Name">IsRestricted</string>
					<bool name="Value">false</bool>
				</Properties>
			</Item>
		</Item>
		<Item class="LocalScript" referent="RBX79">
			<Properties>
				<bool name="Disabled">true</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">BasePlateGuide</string>
				<ProtectedString name="Source">local pointDirection = nil

local tailLength = 2 -- 2 or 7
--local dSize = -.05  -- .01 or .005
local dSize = 0 -- because we want the targets to all be the same size (tail isn't larger anymore; just "ghost" effect)
local dTime = .04 --.025

-- old targetLock pic (square): 48972746

local targetLockSize = .2
local arrowSize = .1

local arrowScreenProportionSize = .95
local arrowMoveFactor = .025

local targetMoveFactor = targetLockSize / 2 - .025

local halfDSize = dSize / 2

local r = game:service("RunService")

local vChar = script.Parent
if vChar == nil then script.Parent = nil end

local vPlay = game.Players:GetPlayerFromCharacter(vChar)
if vPlay == nil then script.Parent = nil end

local arrowGui = vPlay.PlayerGui:FindFirstChild("GuideArrowGui")
if arrowGui == nil then
	arrowGui = script.GuideArrowGui
	arrowGui.Parent = vPlay.PlayerGui
else
	script.GuideArrowGui:remove()
end

local upArrow = arrowGui.UpArrow
local downArrow = arrowGui.DownArrow
local leftArrow = arrowGui.LeftArrow
local rightArrow = arrowGui.RightArrow
local targetLock = arrowGui.TargetLock
local arrowList = {upArrow, downArrow, leftArrow, rightArrow, targetLock}

local goAway = arrowGui.GoAwayButton
goAway.Visible = true
goAway.Active = true
local keepShowing = true
goAway.MouseButton1Click:connect(function () keepShowing = false end)


local arrowHeightAugment = 0.0
local arrowWidthAugment = 0.0
local targetHeightAugment = 0.0
local targetWidthAugment = 0.0


local targetLockList = {targetLock}
for i = 1, tailLength do table.insert(targetLockList, targetLock:Clone()) end

targetLockList[1].Size = UDim2.new(targetLockSize, 0, targetLockSize, 0)
for i = 1, #targetLockList-1 do
	targetLockList[i+1].Parent = arrowGui
	--targetLockList[i+1].Size = UDim2.new(targetLockSize-i*dSize, 0, targetLockSize-i*dSize, 0)
end
-- switching over to a "ghost-like" transparency effect, but this means we have to upload separate images :(
-- if our tail is turned on, manually apply the ghosting to the next two images
if tailLength &gt; 0 then targetLockList[2].Image = "http://www.roblox.com/asset/?id=49324811" end
if tailLength &gt; 1 then targetLockList[3].Image = "http://www.roblox.com/asset/?id=49324846" end


function onResize() -- force arrows into a square resolution
	xSize = arrowGui.AbsoluteSize.X
	ySize = arrowGui.AbsoluteSize.Y

	if xSize &gt;= ySize then
		arrowHeightAugment = 0.0

		-- calculate arrowWidthAugment and new arrow ratio here
		newArrowUDim = UDim2.new(ySize / xSize * arrowSize, 0, arrowSize, 0)
		rightArrow.Size = newArrowUDim 
		leftArrow.Size = newArrowUDim 
		upArrow.Size = newArrowUDim 
		downArrow.Size = newArrowUDim

		for tli = 1, #targetLockList do
			targetLockList[tli].Size = UDim2.new(ySize / xSize * (targetLockSize-tli*dSize), 0, targetLockSize-tli*dSize, 0)
		end

		arrowWidthAugment = (xSize - ySize)*arrowSize*.5 / xSize
	else
		arrowWidthAugment = 0.0

		-- calculate arrowHeightAugment here
		newArrowUDim = UDim2.new(arrowSize, 0, xSize / ySize * arrowSize, 0)
		rightArrow.Size = newArrowUDim
		leftArrow.Size = newArrowUDim
		upArrow.Size = newArrowUDim
		downArrow.Size = newArrowUDim

		for tli = 1, #targetLockList do
			targetLockList[tli].Size = UDim2.new(targetLockSize-tli*dSize, 0, xSize / ySize * (targetLockSize-tli*dSize), 0)
		end

		arrowHeightAugment = (ySize - xSize)*arrowSize*.5 / ySize
	end

	targetWidthAugment = targetLock.Size.X.Scale / 2 - .025
	targetHeightAugment = targetLock.Size.Y.Scale / 2 - .025
end

arrowGui.Changed:connect(onResize) -- dynamically resize the arrows on screen resize

function findMyBasePlate()
	--if true then return game.Workspace.Base end -- for testing purposes

	local buildingAreas = game.Workspace.BuildingAreas:GetChildren()
	for i = 1, #buildingAreas do
		if buildingAreas[i].Player.Value == script.Parent.Name then
			return buildingAreas[i]:FindFirstChild("BasePlate") or buildingAreas[i].PlayerArea:FindFirstChild("BasePlate")
		end
	end
end

local myBase = findMyBasePlate()
if myBase == nil then
	print("BasePlateGuide script error: no base plate found!")
	-- abort if no BasePlate found
	arrowGui:remove()
	script:remove()
end

function setVisible(whichArrow)
	for i = 1, #arrowList do
		if arrowList[i] == whichArrow then
			arrowList[i].Visible = true
		else
			arrowList[i].Visible = false
		end
	end
end

function truncate(number, augmentation)
	if number+augmentation &lt; 0 then return 0 
   elseif number &gt; (1 - arrowSize)+augmentation then return (1 - arrowSize)+2*augmentation -- furthest extent we want the arrows to reach is .95 - arrowSize
	else return number+augmentation end
end


function notInBasePlate(myPos, base)
	local corner1 = base.Position - base.Size/2
	local corner2 = base.Position + base.Size/2
	if myPos.X &gt; corner1.X and myPos.Y &gt; corner1.Y and myPos.Z &gt; corner1.Z and myPos.X &lt; corner2.X and myPos.Z &lt; corner2.Z then -- we only care they're somewhere above baseplate
		return false
	else
		return true
	end
end

local lastTime = 0
local camera = game.Workspace.CurrentCamera
while notInBasePlate(script.Parent.Torso.Position, myBase) and keepShowing do
	--pointDirection = (myBase.Position - script.Parent.Torso.Position) * Vector3.new(1, 0, 1)
	camFrame = camera.CoordinateFrame
	pointDirection = camFrame:vectorToObjectSpace(myBase.Position - camFrame.p)
	camZ = pointDirection.Z
	camX = pointDirection.X/math.abs(camZ)
	camY = pointDirection.Y/math.abs(camZ)
	--print(camX, camY, camZ)

	-- was .55 for 610 (Y) and 1.15 for 1286 (X), so seems like scaling factor is universally 1114 on both axes	
	-- nvm:  at 1662 x 666, we have ... and .55, so seems like .55 always for Y, then X is scaled according to its proportion to Y

	local xThreshold = arrowGui.AbsoluteSize.X / arrowGui.AbsoluteSize.Y * .55
	local yThreshold = .55

	local nCamX = camX / xThreshold
	local nCamY = camY / yThreshold

	if (math.abs(nCamX) &gt; 1 or math.abs(nCamY) &gt; 1) or (camZ &gt; 0) then -- camZ test makes sure we only lock on if facing right direction
		for j = 2, #targetLockList do
			targetLockList[j].Visible = false
		end
	
		if math.abs(nCamX) &gt; math.abs(nCamY) then
			--if nCamY &gt; 1 then nCamY = 1
			--elseif nCamY &lt; -1 then nCamY = -1 end

			if camX &gt; 0 then
				-- should go right
				rightArrow.Position = UDim2.new(arrowScreenProportionSize - arrowMoveFactor - .025 + 2*arrowWidthAugment, 0, truncate(arrowScreenProportionSize*(1-nCamY)/2 - arrowMoveFactor, arrowHeightAugment), 0)
				setVisible(rightArrow)
			else
				-- should go left
				leftArrow.Position = UDim2.new(0, 0, truncate(arrowScreenProportionSize*(1-nCamY)/2 - arrowMoveFactor, arrowHeightAugment), 0)
				setVisible(leftArrow)
			end
		else
			--if nCamX &gt; 1 then nCamX = 1
			--elseif nCamX &lt; -1 then nCamX = -1 end

			if camY &gt; 0 then
				-- should go up
				upArrow.Position = UDim2.new(truncate(arrowScreenProportionSize*(nCamX+1)/2 - arrowMoveFactor, arrowWidthAugment), 0, 0, 0)
				setVisible(upArrow)
			else
				-- should go down
				downArrow.Position = UDim2.new(truncate(arrowScreenProportionSize*(nCamX+1)/2 - arrowMoveFactor, arrowWidthAugment), 0, arrowScreenProportionSize - arrowMoveFactor -.025 + 2*arrowHeightAugment, 0)
				setVisible(downArrow)
			end
		end
	else
		-- locked on target
		--for j = 2, #targetLockList do
			--targetLockList[j].Visible = true
		--end
		--targetLock.Position = UDim2.new(.95*(nCamX+1)/2 - targetMoveFactor, 0, .95*(1-nCamY)/2 - targetMoveFactor, 0)
		targetLock.Position = UDim2.new(.95*(nCamX+1)/2 - targetWidthAugment, 0, .95*(1-nCamY)/2 - targetHeightAugment, 0)
		setVisible(targetLock)
	end

	--wait()
	
	-- update every dTime seconds

	-- ok to do it this way instead of a ring array, because even though it's less efficient, it's less efficient by only one or two commands [since only have 2 "tails"]

	local t = r.Stepped:wait()
	if t - lastTime &gt; dTime then
		lastTime = t
		for j = #targetLockList, 2, -1 do
			targetLockList[j].Position = targetLockList[j-1].Position + UDim2.new(halfDSize, 0, halfDSize, 0)
			targetLockList[j].Visible = targetLockList[j-1].Visible
		end
	end
end

--[[setVisible(nil)
for j = 2, #targetLockList do
	targetLockList[j].Visible = false
end
goAway.Visible = false
goAway.Active = false
]]--
arrowGui:remove()
script:remove()</ProtectedString>
			</Properties>
			<Item class="ScreenGui" referent="RBX80">
				<Properties>
					<string name="Name">GuideArrowGui</string>
				</Properties>
				<Item class="ImageLabel" referent="RBX81">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>rbxasset://../../../shareddata/textures/48972729.png</url></Content>
						<string name="Name">UpArrow</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0.0500000007</XS>
							<XO>0</XO>
							<YS>0.0500000007</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
				<Item class="ImageLabel" referent="RBX82">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>rbxasset://../../../shareddata/textures/48972703.png</url></Content>
						<string name="Name">RightArrow</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0.0500000007</XS>
							<XO>0</XO>
							<YS>0.0500000007</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
				<Item class="ImageLabel" referent="RBX83">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>rbxasset://../../../shareddata/textures/48972653.png</url></Content>
						<string name="Name">DownArrow</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0.0500000007</XS>
							<XO>0</XO>
							<YS>0.0500000007</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
				<Item class="ImageLabel" referent="RBX84">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>rbxasset://../../../shareddata/textures/48972682.png</url></Content>
						<string name="Name">LeftArrow</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0.0500000007</XS>
							<XO>0</XO>
							<YS>0.0500000007</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
				<Item class="ImageLabel" referent="RBX85">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>rbxasset://../../../shareddata/textures/49321779.png</url></Content>
						<string name="Name">TargetLock</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0.0500000007</XS>
							<XO>0</XO>
							<YS>0.0500000007</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
				<Item class="TextButton" referent="RBX86">
					<Properties>
						<bool name="Active">true</bool>
						<bool name="AutoButtonColor">true</bool>
						<Color3 name="BackgroundColor3">4278255360</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">0</token>
						<token name="FontSize">0</token>
						<bool name="Modal">false</bool>
						<string name="Name">GoAwayButton</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>20</XO>
							<YS>0</YS>
							<YO>40</YO>
						</UDim2>
						<bool name="Selected">false</bool>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>150</XO>
							<YS>0</YS>
							<YO>20</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<string name="Text">Hide Guide Arrows</string>
						<Color3 name="TextColor3">4279970357</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="ScreenGui" referent="RBX87">
			<Properties>
				<string name="Name">StampGUI</string>
			</Properties>
			<Item class="Frame" referent="RBX88">
				<Properties>
					<bool name="Active">true</bool>
					<Color3 name="BackgroundColor3">4288914085</Color3>
					<float name="BackgroundTransparency">1</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<string name="Name">InsertPanel</string>
					<UDim2 name="Position">
						<XS>0.200000003</XS>
						<XO>2</XO>
						<YS>0.100000001</YS>
						<YO>24</YO>
					</UDim2>
					<UDim2 name="Size">
						<XS>0.600000024</XS>
						<XO>-20</XO>
						<YS>0.639999986</YS>
						<YO>0</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<token name="Style">3</token>
					<bool name="Visible">true</bool>
					<int name="ZIndex">1</int>
				</Properties>
				<Item class="Frame" referent="RBX89">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">ItemsFrame</string>
						<UDim2 name="Position">
							<XS>0.239999995</XS>
							<XO>0</XO>
							<YS>0.0850000009</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0.540000021</XS>
							<XO>0</XO>
							<YS>0.800000012</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="Frame" referent="RBX90">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4294112243</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<string name="Name">InsertAssetButtonExample</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>128</XO>
								<YS>0</YS>
								<YO>64</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>64</XO>
								<YS>0</YS>
								<YO>64</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="TextButton" referent="RBX91">
							<Properties>
								<bool name="Active">true</bool>
								<bool name="AutoButtonColor">true</bool>
								<Color3 name="BackgroundColor3">4282861383</Color3>
								<float name="BackgroundTransparency">0.100000001</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">0</token>
								<token name="FontSize">0</token>
								<bool name="Modal">false</bool>
								<string name="Name">Button</string>
								<UDim2 name="Position">
									<XS>0.0250000004</XS>
									<XO>0</XO>
									<YS>0.0250000004</YS>
									<YO>0</YO>
								</UDim2>
								<bool name="Selected">false</bool>
								<UDim2 name="Size">
									<XS>0.949999988</XS>
									<XO>0</XO>
									<YS>0.949999988</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<token name="Style">2</token>
								<string name="Text"></string>
								<Color3 name="TextColor3">4279970357</Color3>
								<bool name="TextScaled">false</bool>
								<Color3 name="TextStrokeColor3">4278190080</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0.100000001</float>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="ImageLabel" referent="RBX92">
								<Properties>
									<bool name="Active">false</bool>
									<Color3 name="BackgroundColor3">4288914085</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">1</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<Content name="Image"><null></null></Content>
									<string name="Name">ButtonImage</string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>-8</XO>
										<YS>0</YS>
										<YO>-8</YO>
									</UDim2>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>16</XO>
										<YS>1</YS>
										<YO>16</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">2</int>
								</Properties>
							</Item>
						</Item>
						<Item class="IntValue" referent="RBX93">
							<Properties>
								<string name="Name">AssetId</string>
								<int name="Value">209411115</int>
							</Properties>
						</Item>
						<Item class="StringValue" referent="RBX94">
							<Properties>
								<string name="Name">AssetName</string>
								<string name="Value">Roof - Outer Corner</string>
							</Properties>
						</Item>
						<Item class="ImageLabel" referent="RBX95">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4278190080</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<Content name="Image"><url>rbxasset://../../../shareddata/textures/54140547.png</url></Content>
								<string name="Name">ConfigIcon</string>
								<UDim2 name="Position">
									<XS>1</XS>
									<XO>-23</XO>
									<YS>1</YS>
									<YO>-24</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>16</XO>
									<YS>0</YS>
									<YO>16</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<bool name="Visible">false</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="TextButton" referent="RBX96">
					<Properties>
						<bool name="Active">true</bool>
						<bool name="AutoButtonColor">true</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">2</token>
						<token name="FontSize">7</token>
						<bool name="Modal">false</bool>
						<string name="Name">CancelButton</string>
						<UDim2 name="Position">
							<XS>1</XS>
							<XO>-32</XO>
							<YS>0</YS>
							<YO>-2</YO>
						</UDim2>
						<bool name="Selected">false</bool>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>34</XO>
							<YS>0</YS>
							<YO>34</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">1</token>
						<string name="Text"></string>
						<Color3 name="TextColor3">4294967295</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="ImageLabel" referent="RBX97">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>rbxasset://../../../shareddata/textures/54135717.png</url></Content>
							<string name="Name">ImageLabel</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>-2</XO>
								<YS>0</YS>
								<YO>-2</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>16</XO>
								<YS>0</YS>
								<YO>16</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
				</Item>
				<Item class="TextButton" referent="RBX98">
					<Properties>
						<bool name="Active">true</bool>
						<bool name="AutoButtonColor">true</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">2</token>
						<token name="FontSize">5</token>
						<bool name="Modal">false</bool>
						<string name="Name">SelectSetButton</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<bool name="Selected">false</bool>
						<UDim2 name="Size">
							<XS>0.200000003</XS>
							<XO>0</XO>
							<YS>0.100000001</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">1</token>
						<string name="Text">Select Set</string>
						<Color3 name="TextColor3">4294967295</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
				<Item class="Frame" referent="RBX99">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">PagingControls</string>
						<UDim2 name="Position">
							<XS>0.239999995</XS>
							<XO>0</XO>
							<YS>0.899999976</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0.540000021</XS>
							<XO>0</XO>
							<YS>0.100000001</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="TextButton" referent="RBX100">
						<Properties>
							<bool name="Active">true</bool>
							<bool name="AutoButtonColor">true</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">7</token>
							<bool name="Modal">false</bool>
							<string name="Name">PreviousPageButton</string>
							<UDim2 name="Position">
								<XS>0.5</XS>
								<XO>-95</XO>
								<YS>0.5</YS>
								<YO>-20</YO>
							</UDim2>
							<bool name="Selected">false</bool>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>60</XO>
								<YS>0</YS>
								<YO>40</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">2</token>
							<string name="Text"></string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="ImageLabel" referent="RBX101">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<Content name="Image"><url>rbxasset://../../../shareddata/textures/54138586.png</url></Content>
								<string name="Name">ImageLabel</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>8</XO>
									<YS>0</YS>
									<YO>-1</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>18</XO>
									<YS>0</YS>
									<YO>18</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
					</Item>
					<Item class="TextLabel" referent="RBX102">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4284874854</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">7</token>
							<string name="Name">PageText</string>
							<UDim2 name="Position">
								<XS>0.5</XS>
								<XO>-30</XO>
								<YS>0.5</YS>
								<YO>-20</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>60</XO>
								<YS>0</YS>
								<YO>40</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">1 / 3</string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="TextButton" referent="RBX103">
						<Properties>
							<bool name="Active">true</bool>
							<bool name="AutoButtonColor">true</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">7</token>
							<bool name="Modal">false</bool>
							<string name="Name">NextPageButton</string>
							<UDim2 name="Position">
								<XS>0.5</XS>
								<XO>35</XO>
								<YS>0.5</YS>
								<YO>-20</YO>
							</UDim2>
							<bool name="Selected">false</bool>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>60</XO>
								<YS>0</YS>
								<YO>40</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">2</token>
							<string name="Text"></string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="ImageLabel" referent="RBX104">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<Content name="Image"><url>rbxasset://../../../shareddata/textures/54138563.png</url></Content>
								<string name="Name">ImageLabel</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>10</XO>
									<YS>0</YS>
									<YO>-1</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>18</XO>
									<YS>0</YS>
									<YO>18</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="Frame" referent="RBX105">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4294901862</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">Sets</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>5</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0.230000004</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>-5</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="Frame" referent="RBX106">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4294967295</Color3>
							<float name="BackgroundTransparency">0.699999988</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<string name="Name">Line</string>
							<UDim2 name="Position">
								<XS>1</XS>
								<XO>-3</XO>
								<YS>0.0599999987</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>3</XO>
								<YS>0.899999976</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="TextLabel" referent="RBX107">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">7</token>
							<string name="Name">SetsHeader</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>47</XO>
								<YS>0</YS>
								<YO>24</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">Sets</string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">0</token>
							<token name="TextYAlignment">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="Frame" referent="RBX108">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4291559577</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<string name="Name">SetsLists</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0.0599999987</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>-6</XO>
								<YS>0.939999998</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="TextButton" referent="RBX109">
							<Properties>
								<bool name="Active">true</bool>
								<bool name="AutoButtonColor">false</bool>
								<Color3 name="BackgroundColor3">4294967295</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">1</token>
								<token name="FontSize">6</token>
								<bool name="Modal">false</bool>
								<string name="Name">SetButtonExample</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>5</XO>
									<YS>0</YS>
									<YO>18</YO>
								</UDim2>
								<bool name="Selected">false</bool>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>-5</XO>
									<YS>0</YS>
									<YO>18</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<token name="Style">0</token>
								<string name="Text">House Decorations</string>
								<Color3 name="TextColor3">4294967295</Color3>
								<bool name="TextScaled">false</bool>
								<Color3 name="TextStrokeColor3">4278190080</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<bool name="TextWrapped">true</bool>
								<token name="TextXAlignment">0</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">false</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="Frame" referent="RBX110">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4284874803</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">ItemPreview</string>
						<UDim2 name="Position">
							<XS>0.790000021</XS>
							<XO>0</XO>
							<YS>0.0850000009</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0.209999993</XS>
							<XO>0</XO>
							<YS>0.899999976</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="ImageLabel" referent="RBX111">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4278190080</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><null></null></Content>
							<string name="Name">LargePreview</string>
							<UDim2 name="Position">
								<XS>0.5</XS>
								<XO>-2</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>4</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">3</int>
						</Properties>
					</Item>
					<Item class="Frame" referent="RBX112">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4286578816</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<string name="Name">TextPanel</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>4</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>-4</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="TextLabel" referent="RBX113">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4291624857</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">2</token>
								<token name="FontSize">7</token>
								<string name="Name">RolloverText</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>48</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<string name="Text">Window - Diagonal</string>
								<Color3 name="TextColor3">4294112243</Color3>
								<bool name="TextScaled">false</bool>
								<Color3 name="TextStrokeColor3">4278190080</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<bool name="TextWrapped">true</bool>
								<token name="TextXAlignment">0</token>
								<token name="TextYAlignment">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="Frame" referent="RBX114">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<string name="Name">ConfigureText</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>48</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>-48</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<token name="Style">0</token>
								<bool name="Visible">false</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="TextLabel" referent="RBX115">
								<Properties>
									<bool name="Active">false</bool>
									<Color3 name="BackgroundColor3">4294901862</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<token name="Font">2</token>
									<token name="FontSize">5</token>
									<string name="Name">Configure</string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>14</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<string name="Text">Configure:</string>
									<Color3 name="TextColor3">4294112243</Color3>
									<bool name="TextScaled">false</bool>
									<Color3 name="TextStrokeColor3">4278190080</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0</float>
									<bool name="TextWrapped">true</bool>
									<token name="TextXAlignment">0</token>
									<token name="TextYAlignment">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
							</Item>
							<Item class="TextLabel" referent="RBX116">
								<Properties>
									<bool name="Active">false</bool>
									<Color3 name="BackgroundColor3">4288914085</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<token name="Font">1</token>
									<token name="FontSize">5</token>
									<string name="Name">Configure1</string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>14</YO>
									</UDim2>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>14</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<string name="Text">Speed</string>
									<Color3 name="TextColor3">4294112243</Color3>
									<bool name="TextScaled">false</bool>
									<Color3 name="TextStrokeColor3">4278190080</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0</float>
									<bool name="TextWrapped">true</bool>
									<token name="TextXAlignment">0</token>
									<token name="TextYAlignment">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
							</Item>
							<Item class="TextLabel" referent="RBX117">
								<Properties>
									<bool name="Active">false</bool>
									<Color3 name="BackgroundColor3">4288914085</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<token name="Font">1</token>
									<token name="FontSize">5</token>
									<string name="Name">Configure2</string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>28</YO>
									</UDim2>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>14</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<string name="Text">Damage</string>
									<Color3 name="TextColor3">4294112243</Color3>
									<bool name="TextScaled">false</bool>
									<Color3 name="TextStrokeColor3">4278190080</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0</float>
									<bool name="TextWrapped">true</bool>
									<token name="TextXAlignment">0</token>
									<token name="TextYAlignment">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
							</Item>
							<Item class="TextLabel" referent="RBX118">
								<Properties>
									<bool name="Active">false</bool>
									<Color3 name="BackgroundColor3">4288914085</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<token name="Font">1</token>
									<token name="FontSize">5</token>
									<string name="Name">Configure3</string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>42</YO>
									</UDim2>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>14</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<string name="Text">Delay</string>
									<Color3 name="TextColor3">4294112243</Color3>
									<bool name="TextScaled">false</bool>
									<Color3 name="TextStrokeColor3">4278190080</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0</float>
									<bool name="TextWrapped">true</bool>
									<token name="TextXAlignment">0</token>
									<token name="TextYAlignment">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
							</Item>
						</Item>
					</Item>
				</Item>
			</Item>
			<Item class="Frame" referent="RBX119">
				<Properties>
					<bool name="Active">true</bool>
					<Color3 name="BackgroundColor3">4288914085</Color3>
					<float name="BackgroundTransparency">0</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<string name="Name">StamperPanel</string>
					<UDim2 name="Position">
						<XS>0.5</XS>
						<XO>-175</XO>
						<YS>1</YS>
						<YO>-135</YO>
					</UDim2>
					<UDim2 name="Size">
						<XS>0</XS>
						<XO>350</XO>
						<YS>0</YS>
						<YO>48</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<token name="Style">3</token>
					<bool name="Visible">true</bool>
					<int name="ZIndex">2</int>
				</Properties>
				<Item class="TextButton" referent="RBX120">
					<Properties>
						<bool name="Active">true</bool>
						<bool name="AutoButtonColor">true</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">2</token>
						<token name="FontSize">7</token>
						<bool name="Modal">false</bool>
						<string name="Name">MinimizeButton</string>
						<UDim2 name="Position">
							<XS>1</XS>
							<XO>-32</XO>
							<YS>0</YS>
							<YO>-2</YO>
						</UDim2>
						<bool name="Selected">false</bool>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>34</XO>
							<YS>0</YS>
							<YO>34</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">1</token>
						<string name="Text"></string>
						<Color3 name="TextColor3">4294967295</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">3</int>
					</Properties>
					<Item class="ImageLabel" referent="RBX121">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>rbxasset://../../../shareddata/textures/54932670.png</url></Content>
							<string name="Name">ImageLabel</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>-3</XO>
								<YS>0</YS>
								<YO>-4</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>16</XO>
								<YS>0</YS>
								<YO>20</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">4</int>
						</Properties>
					</Item>
				</Item>
				<Item class="Frame" referent="RBX122">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">StamperButtons</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="Frame" referent="RBX123">
						<Properties>
							<bool name="Active">true</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<string name="Name">RecentFrame</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>103</XO>
								<YS>0</YS>
								<YO>-6</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>192</XO>
								<YS>0</YS>
								<YO>44</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">3</int>
						</Properties>
						<Item class="TextButton" referent="RBX124">
							<Properties>
								<bool name="Active">true</bool>
								<bool name="AutoButtonColor">true</bool>
								<Color3 name="BackgroundColor3">4282861383</Color3>
								<float name="BackgroundTransparency">0.100000001</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">0</token>
								<token name="FontSize">0</token>
								<bool name="Modal">false</bool>
								<string name="Name">Button1</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>-2</YO>
								</UDim2>
								<bool name="Selected">false</bool>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>48</XO>
									<YS>0</YS>
									<YO>48</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<token name="Style">2</token>
								<string name="Text"></string>
								<Color3 name="TextColor3">4294967295</Color3>
								<bool name="TextScaled">false</bool>
								<Color3 name="TextStrokeColor3">4278190080</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0.100000001</float>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">0</token>
								<token name="TextYAlignment">0</token>
								<bool name="Visible">false</bool>
								<int name="ZIndex">4</int>
							</Properties>
							<Item class="ImageLabel" referent="RBX125">
								<Properties>
									<bool name="Active">false</bool>
									<Color3 name="BackgroundColor3">4288914085</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">1</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<Content name="Image"><url>rbxasset://../../../shareddata/textures/209434543.png</url></Content>
									<string name="Name">ButtonImage</string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>-8</XO>
										<YS>0</YS>
										<YO>-8</YO>
									</UDim2>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>16</XO>
										<YS>1</YS>
										<YO>16</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">5</int>
								</Properties>
							</Item>
							<Item class="TextLabel" referent="RBX126">
								<Properties>
									<bool name="Active">false</bool>
									<Color3 name="BackgroundColor3">4288914085</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">1</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<token name="Font">2</token>
									<token name="FontSize">5</token>
									<string name="Name">ShortcutText</string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>-7</XO>
										<YS>0</YS>
										<YO>-8</YO>
									</UDim2>
									<UDim2 name="Size">
										<XS>0</XS>
										<XO>7</XO>
										<YS>0</YS>
										<YO>12</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<string name="Text">F</string>
									<Color3 name="TextColor3">4294967295</Color3>
									<bool name="TextScaled">false</bool>
									<Color3 name="TextStrokeColor3">4278190080</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0</float>
									<bool name="TextWrapped">false</bool>
									<token name="TextXAlignment">2</token>
									<token name="TextYAlignment">1</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">8</int>
								</Properties>
							</Item>
						</Item>
						<Item class="TextButton" referent="RBX127">
							<Properties>
								<bool name="Active">true</bool>
								<bool name="AutoButtonColor">true</bool>
								<Color3 name="BackgroundColor3">4282861383</Color3>
								<float name="BackgroundTransparency">0.100000001</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">0</token>
								<token name="FontSize">0</token>
								<bool name="Modal">false</bool>
								<string name="Name">Button2</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>48</XO>
									<YS>0</YS>
									<YO>-2</YO>
								</UDim2>
								<bool name="Selected">false</bool>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>48</XO>
									<YS>0</YS>
									<YO>48</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<token name="Style">2</token>
								<string name="Text"></string>
								<Color3 name="TextColor3">4279970357</Color3>
								<bool name="TextScaled">false</bool>
								<Color3 name="TextStrokeColor3">4278190080</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0.100000001</float>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">false</bool>
								<int name="ZIndex">4</int>
							</Properties>
							<Item class="ImageLabel" referent="RBX128">
								<Properties>
									<bool name="Active">false</bool>
									<Color3 name="BackgroundColor3">4288914085</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">1</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<Content name="Image"><url>rbxasset://../../../shareddata/textures/209434543.png</url></Content>
									<string name="Name">ButtonImage</string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>-8</XO>
										<YS>0</YS>
										<YO>-8</YO>
									</UDim2>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>16</XO>
										<YS>1</YS>
										<YO>16</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">5</int>
								</Properties>
							</Item>
							<Item class="TextLabel" referent="RBX129">
								<Properties>
									<bool name="Active">false</bool>
									<Color3 name="BackgroundColor3">4288914085</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">1</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<token name="Font">2</token>
									<token name="FontSize">5</token>
									<string name="Name">ShortcutText</string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>-7</XO>
										<YS>0</YS>
										<YO>-8</YO>
									</UDim2>
									<UDim2 name="Size">
										<XS>0</XS>
										<XO>7</XO>
										<YS>0</YS>
										<YO>12</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<string name="Text">G</string>
									<Color3 name="TextColor3">4294967295</Color3>
									<bool name="TextScaled">false</bool>
									<Color3 name="TextStrokeColor3">4278190080</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0</float>
									<bool name="TextWrapped">false</bool>
									<token name="TextXAlignment">2</token>
									<token name="TextYAlignment">1</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">8</int>
								</Properties>
							</Item>
						</Item>
						<Item class="TextButton" referent="RBX130">
							<Properties>
								<bool name="Active">true</bool>
								<bool name="AutoButtonColor">true</bool>
								<Color3 name="BackgroundColor3">4282861383</Color3>
								<float name="BackgroundTransparency">0.100000001</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">0</token>
								<token name="FontSize">0</token>
								<bool name="Modal">false</bool>
								<string name="Name">Button3</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>95</XO>
									<YS>0</YS>
									<YO>-3</YO>
								</UDim2>
								<bool name="Selected">false</bool>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>48</XO>
									<YS>0</YS>
									<YO>48</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<token name="Style">2</token>
								<string name="Text"></string>
								<Color3 name="TextColor3">4279970357</Color3>
								<bool name="TextScaled">false</bool>
								<Color3 name="TextStrokeColor3">4278190080</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0.100000001</float>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">false</bool>
								<int name="ZIndex">4</int>
							</Properties>
							<Item class="ImageLabel" referent="RBX131">
								<Properties>
									<bool name="Active">false</bool>
									<Color3 name="BackgroundColor3">4288914085</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">1</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<Content name="Image"><url>rbxasset://../../../shareddata/textures/209434543.png</url></Content>
									<string name="Name">ButtonImage</string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>-8</XO>
										<YS>0</YS>
										<YO>-8</YO>
									</UDim2>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>16</XO>
										<YS>1</YS>
										<YO>16</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">5</int>
								</Properties>
							</Item>
							<Item class="TextLabel" referent="RBX132">
								<Properties>
									<bool name="Active">false</bool>
									<Color3 name="BackgroundColor3">4288914085</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">1</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<token name="Font">2</token>
									<token name="FontSize">5</token>
									<string name="Name">ShortcutText</string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>-7</XO>
										<YS>0</YS>
										<YO>-8</YO>
									</UDim2>
									<UDim2 name="Size">
										<XS>0</XS>
										<XO>7</XO>
										<YS>0</YS>
										<YO>12</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<string name="Text">H</string>
									<Color3 name="TextColor3">4294967295</Color3>
									<bool name="TextScaled">false</bool>
									<Color3 name="TextStrokeColor3">4278190080</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0</float>
									<bool name="TextWrapped">false</bool>
									<token name="TextXAlignment">2</token>
									<token name="TextYAlignment">1</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">8</int>
								</Properties>
							</Item>
						</Item>
						<Item class="TextButton" referent="RBX133">
							<Properties>
								<bool name="Active">true</bool>
								<bool name="AutoButtonColor">true</bool>
								<Color3 name="BackgroundColor3">4282861383</Color3>
								<float name="BackgroundTransparency">0.100000001</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">0</token>
								<token name="FontSize">0</token>
								<bool name="Modal">false</bool>
								<string name="Name">Button4</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>142</XO>
									<YS>0</YS>
									<YO>-3</YO>
								</UDim2>
								<bool name="Selected">false</bool>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>48</XO>
									<YS>0</YS>
									<YO>48</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<token name="Style">2</token>
								<string name="Text"></string>
								<Color3 name="TextColor3">4279970357</Color3>
								<bool name="TextScaled">false</bool>
								<Color3 name="TextStrokeColor3">4278190080</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0.100000001</float>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">false</bool>
								<int name="ZIndex">4</int>
							</Properties>
							<Item class="ImageLabel" referent="RBX134">
								<Properties>
									<bool name="Active">false</bool>
									<Color3 name="BackgroundColor3">4288914085</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">1</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<Content name="Image"><url>rbxasset://../../../shareddata/textures/209434543.png</url></Content>
									<string name="Name">ButtonImage</string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>-8</XO>
										<YS>0</YS>
										<YO>-8</YO>
									</UDim2>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>16</XO>
										<YS>1</YS>
										<YO>16</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">5</int>
								</Properties>
							</Item>
							<Item class="TextLabel" referent="RBX135">
								<Properties>
									<bool name="Active">false</bool>
									<Color3 name="BackgroundColor3">4288914085</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">1</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<token name="Font">2</token>
									<token name="FontSize">5</token>
									<string name="Name">ShortcutText</string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>-7</XO>
										<YS>0</YS>
										<YO>-8</YO>
									</UDim2>
									<UDim2 name="Size">
										<XS>0</XS>
										<XO>7</XO>
										<YS>0</YS>
										<YO>12</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<string name="Text">J</string>
									<Color3 name="TextColor3">4294967295</Color3>
									<bool name="TextScaled">false</bool>
									<Color3 name="TextStrokeColor3">4278190080</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0</float>
									<bool name="TextWrapped">false</bool>
									<token name="TextXAlignment">2</token>
									<token name="TextYAlignment">1</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">8</int>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="TextButton" referent="RBX136">
						<Properties>
							<bool name="Active">true</bool>
							<bool name="AutoButtonColor">true</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">5</token>
							<bool name="Modal">false</bool>
							<string name="Name">CloneButton</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>-6</YO>
							</UDim2>
							<bool name="Selected">false</bool>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>45</XO>
								<YS>0</YS>
								<YO>45</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">2</token>
							<string name="Text"></string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">3</int>
						</Properties>
						<Item class="ImageLabel" referent="RBX137">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<Content name="Image"><url>rbxasset://../../../shareddata/textures/51641555.png</url></Content>
								<string name="Name">ImageLabel</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>-7</XO>
									<YS>0</YS>
									<YO>-7</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>14</XO>
									<YS>1</YS>
									<YO>14</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">4</int>
							</Properties>
						</Item>
						<Item class="TextLabel" referent="RBX138">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">2</token>
								<token name="FontSize">5</token>
								<string name="Name">CloneShortcut</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>-7</XO>
									<YS>0</YS>
									<YO>-8</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>8</XO>
									<YS>0</YS>
									<YO>12</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<string name="Text">E</string>
								<Color3 name="TextColor3">4294967295</Color3>
								<bool name="TextScaled">false</bool>
								<Color3 name="TextStrokeColor3">4278190080</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">5</int>
							</Properties>
						</Item>
					</Item>
					<Item class="TextButton" referent="RBX139">
						<Properties>
							<bool name="Active">true</bool>
							<bool name="AutoButtonColor">true</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">5</token>
							<bool name="Modal">false</bool>
							<string name="Name">PartsButton</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>45</XO>
								<YS>0</YS>
								<YO>-6</YO>
							</UDim2>
							<bool name="Selected">true</bool>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>45</XO>
								<YS>0</YS>
								<YO>45</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">2</token>
							<string name="Text"></string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">3</int>
						</Properties>
						<Item class="ImageLabel" referent="RBX140">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<Content name="Image"><url>rbxasset://../../../shareddata/textures/54966682.png</url></Content>
								<string name="Name">ImageLabel</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>-7</XO>
									<YS>0</YS>
									<YO>-7</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>14</XO>
									<YS>1</YS>
									<YO>14</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">4</int>
							</Properties>
						</Item>
						<Item class="TextLabel" referent="RBX141">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">2</token>
								<token name="FontSize">5</token>
								<string name="Name">PartsShortcut</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>-7</XO>
									<YS>0</YS>
									<YO>-8</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>8</XO>
									<YS>0</YS>
									<YO>12</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<string name="Text">Q</string>
								<Color3 name="TextColor3">4294967295</Color3>
								<bool name="TextScaled">false</bool>
								<Color3 name="TextStrokeColor3">4278190080</Color3>
								<float name="TextStrokeTransparency">0</float>
								<float name="TextTransparency">0</float>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">5</int>
							</Properties>
						</Item>
					</Item>
					<Item class="Frame" referent="RBX142">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<string name="Name">ClonePanel</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>-8</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>80</XO>
								<YS>1</YS>
								<YO>16</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">2</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="TextLabel" referent="RBX143">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">2</token>
								<token name="FontSize">5</token>
								<string name="Name">ClonePanelText</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>-6</XO>
									<YS>0</YS>
									<YO>-8</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>12</XO>
									<YS>1</YS>
									<YO>16</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<string name="Text">Click on a part to clone it</string>
								<Color3 name="TextColor3">4294967295</Color3>
								<bool name="TextScaled">false</bool>
								<Color3 name="TextStrokeColor3">4278190080</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<bool name="TextWrapped">true</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">false</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="TextButton" referent="RBX144">
					<Properties>
						<bool name="Active">true</bool>
						<bool name="AutoButtonColor">true</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">2</token>
						<token name="FontSize">7</token>
						<bool name="Modal">false</bool>
						<string name="Name">RestoreButton</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>-25</XO>
							<YS>0</YS>
							<YO>-20</YO>
						</UDim2>
						<bool name="Selected">false</bool>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>50</XO>
							<YS>0</YS>
							<YO>25</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">1</token>
						<string name="Text"></string>
						<Color3 name="TextColor3">4294967295</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">3</int>
					</Properties>
					<Item class="ImageLabel" referent="RBX145">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>rbxasset://../../../shareddata/textures/54933540.png</url></Content>
							<string name="Name">ImageLabel</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>-4</XO>
								<YS>0</YS>
								<YO>-4</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>8</XO>
								<YS>1</YS>
								<YO>8</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">4</int>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="LocalScript" referent="RBX146">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">StampGuiController</string>
					<ProtectedString name="Source">local stampGui = script.Parent
local insertPanel = stampGui.InsertPanel
local stamperPanel = stampGui.StamperPanel

local itemPreview = insertPanel.ItemPreview

function handleResize()
	wait() -- neccessary to insure heartbeat happened
	itemPreview.LargePreview.Size = UDim2.new(1,0,0,itemPreview.AbsoluteSize.X)
	itemPreview.LargePreview.Position = UDim2.new(0.5,-itemPreview.LargePreview.AbsoluteSize.X/2,0,0)
	itemPreview.TextPanel.Position = UDim2.new(0,0,0,itemPreview.LargePreview.AbsoluteSize.Y)
	itemPreview.TextPanel.Size = UDim2.new(1,0,0,itemPreview.AbsoluteSize.Y - itemPreview.LargePreview.AbsoluteSize.Y)
end

stampGui.Changed:connect(function(prop)
	if prop == "AbsoluteSize" then
		handleResize()
	end
end)

handleResize()</ProtectedString>
				</Properties>
			</Item>
			<Item class="Frame" referent="RBX147">
				<Properties>
					<bool name="Active">false</bool>
					<Color3 name="BackgroundColor3">4288914085</Color3>
					<float name="BackgroundTransparency">0</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<string name="Name">LoadDialog</string>
					<UDim2 name="Position">
						<XS>0.5</XS>
						<XO>-175</XO>
						<YS>0.5</YS>
						<YO>-25</YO>
					</UDim2>
					<UDim2 name="Size">
						<XS>0</XS>
						<XO>350</XO>
						<YS>0</YS>
						<YO>50</YO>
					</UDim2>
					<token name="SizeConstraint">1</token>
					<token name="Style">3</token>
					<bool name="Visible">false</bool>
					<int name="ZIndex">1</int>
				</Properties>
				<Item class="TextLabel" referent="RBX148">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">2</token>
						<token name="FontSize">8</token>
						<string name="Name">LoadLabel</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>-8</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>155</XO>
							<YS>0.5</YS>
							<YO>36</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<string name="Text">Loading...</string>
						<Color3 name="TextColor3">4294506744</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="SelectionBox" referent="RBX149">
			<Properties>
				<Ref name="Adornee">null</Ref>
				<int name="Color">21</int>
				<string name="Name">ErrorBox</string>
				<float name="Transparency">0</float>
				<bool name="Visible">false</bool>
			</Properties>
		</Item>
		<Item class="LocalScript" referent="RBX150">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">GuiScript</string>
				<ProtectedString name="Source">-- This script is responsible for working the gui

-- basic functions
function waitForChild(instance, name)
	while not instance:findFirstChild(name) do
		instance.ChildAdded:wait()
	end
end

function waitForProperty(instance, name)
	while not instance[name] do
		instance.Changed:wait()
	end
end


-- Locals
local Tool = script.Parent

waitForChild(Tool, "LuaGlobalVariables")
local variables = Tool.LuaGlobalVariables
waitForChild(variables, "InsertAsset")
local insertAsset = variables.InsertAsset
waitForChild(variables, "SwitchMode")
local switchMode = variables.SwitchMode
waitForChild(variables, "ShowAdminCategories")
local showAdminCategories = variables.ShowAdminCategories

waitForChild(variables, "ReloadCurrentAsset")
waitForChild(variables,"userIDs")

game:GetService("ContentProvider"):Preload("http://www.roblox.com/asset/?id=42163425")
game:GetService("ContentProvider"):Preload("http://www.roblox.com/asset/?id=42563487")

local BaseUrl = game:GetService("ContentProvider").BaseUrl

local buttonHeight = 64
local buttonWidth = buttonHeight

local waypointShowing = false
local showingPartPicker = true
local firstEquip = true

local Window
local Data
local loading = false

local startTime = 0

local SetCache = {}

local lastEnter = nil

-- For Restricting Stamper Tool
local buildingPlate
local partModel

-- wait for all of our set ids to load
local userIdsForStamperParts = variables.userIDs -- 7502714 This is UsabilityMan (on gametest)

function giveNewUserId(id)
	local newUserId = Instance.new("IntValue")
	newUserId.Name = "userID"
	newUserId.Value = id
	newUserId.Parent = userIdsForStamperParts
	userIdsForStamperParts.Value = userIdsForStamperParts.Value + 1
end

BaseUrl = BaseUrl:lower()

local isRestricted = Instance.new("BoolValue")
isRestricted.Name = "IsRestricted"
isRestricted.Value = false

function isLocalWTRB()
	waitForChild(game,"StarterGui")
	if game.StarterGui:FindFirstChild("VersionGui") then
		if game.StarterGui.VersionGui:FindFirstChild("VersionText", true) then
			return true
		end
	end
	return false
end

waitForProperty(game,"PlaceId")
if game.PlaceId == 41324860 or isLocalWTRB() then
	isRestricted.Value = true
end
isRestricted.Parent = variables

giveNewUserId(18881789)
giveNewUserId(18881808)
if not isRestricted.Value then
	giveNewUserId(18881829)
	giveNewUserId(18881853)
	giveNewUserId(18881866)
else
	giveNewUserId(2409156)
	giveNewUserId(19238067)
	giveNewUserId(19238114)
end

while #userIdsForStamperParts:GetChildren() &lt; userIdsForStamperParts.Value do userIdsForStamperParts.ChildAdded:wait() end
userIdsForStamperParts = userIdsForStamperParts:GetChildren()

local useAssetVersionId = false
local LargeThumbnailUrl
local SmallThumbnailUrl

local InsertRows = 0
local InsertColumns = 0
local insertButtons = {}

local CancelDuringLoad

local prevPart = {AssetNameValue = "",AssetIdValue = 0 ,InsertFrameButtonImage = ""}
local recentPartStack = {}

-- Connection Managers
local guiChangedCon = nil
local cloneButtonCon = nil
local partListClickCon = nil
local itemFrameChangedCon = nil
local setsNextPageCon = nil
local setsPrevPageCon = nil
local insertPanelCloseCon = nil
local minimizeCon = nil
local restoreCon = nil
local setButtonCons = {}
local insertButtonCons = {}
local recentPartStackCons = {}

local Mouse = nil
local currSetPage = 1

local mode = 0 -- 0 = main dialog, 1 = stamper, 2 = eyedropper

waitForChild(script.Parent,"StampGUI")
local stamperGui = script.Parent.StampGUI
waitForChild(stamperGui,"InsertPanel")
waitForChild(stamperGui.InsertPanel, "CancelButton")
local currStampGui = nil

local maxRecentParts = 4
for i = 1, maxRecentParts do
	recentPartStack[i] = {AssetNameValue,AssetIdValue,InsertFrameButtonImage}
	recentPartStack[i].AssetNameValue = ""
	recentPartStack[i].AssetIdValue = ""
	recentPartStack[i].InsertFrameButtonImage = ""
end
----------------------------------------------------------------------------------------


-- functions
function showBaseplateGuideArrows()
	playerCharacter = Tool.Parent
	if playerCharacter:FindFirstChild("Humanoid") and not playerCharacter:FindFirstChild("BasePlateGuide") then
		newGuide = Tool.BasePlateGuide:Clone()
		newGuide.Parent = playerCharacter
		newGuide.Disabled = false
	end
end

function setAssetUrls()
	if useAssetVersionId then
		LargeThumbnailUrl = BaseUrl .. "Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=420&amp;ht=420&amp;assetversionid="
		SmallThumbnailUrl = BaseUrl .. "Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=75&amp;ht=75&amp;assetversionid="
	else
		LargeThumbnailUrl = BaseUrl .. "Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=420&amp;ht=420&amp;aid="
		SmallThumbnailUrl = BaseUrl .. "Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=75&amp;ht=75&amp;aid="
	end
end

function signalSwitchMode(mode)
	switchMode.Mode.Value = mode
	switchMode.Value = true
end

function goToClone()
	cancelLoadingWindow()
	closeInsertPanel()
	cancelAssetPlacement()

	mode = 2
	--signalStamperScript("",0,"","",false)
	signalSwitchMode("Clone")

	currStampGui.StamperPanel.StamperButtons.ClonePanel.Visible = true
	currStampGui.StamperPanel.StamperButtons.CloneButton.Selected = true
	if currStampGui.Parent ~= nil then
		currStampGui.StamperPanel.StamperButtons.ClonePanel:TweenPosition(UDim2.new(0, -88, 0, -8),Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,0.35,true)
		delay(0.3,function() currStampGui.StamperPanel.StamperButtons.ClonePanel.ClonePanelText.Visible = true end)
	end
end

function goToStamp()
	mode = 1
	cancelLoadingWindow()
	closeInsertPanel()
	closeClonePanel()
end

function goToInsertPanel()
	cancelLoadingWindow()
	closeClonePanel()
	pcall(function() currStampGui.InsertPanel.CancelButton.Modal = true end)
	currStampGui.StamperPanel.StamperButtons.PartsButton.Selected = true

	if not showingPartPicker then
		showingPartPicker = true
		if currStampGui.Parent ~= nil then
			currStampGui.InsertPanel:TweenPosition(UDim2.new(0.2, 2, 0.1, 24),Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,0.35,true)
		end
	else
		closeInsertPanel()
		reloadCurrentAsset()
	end
end

function closeInsertPanel()
	pcall(function() currStampGui.InsertPanel.CancelButton.Modal = false end)
	currStampGui.StamperPanel.StamperButtons.PartsButton.Selected = false

	showingPartPicker = false
	if currStampGui.Parent ~= nil then
		currStampGui.InsertPanel:TweenPosition(UDim2.new(0.2, 2, 1, 24),Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,0.35,true)
	end
end

function closeClonePanel()
	currStampGui.StamperPanel.StamperButtons.ClonePanel.ClonePanelText.Visible = false
	currStampGui.StamperPanel.StamperButtons.CloneButton.Selected = false
	if currStampGui.Parent ~= nil then
		currStampGui.StamperPanel.StamperButtons.ClonePanel:TweenPosition(UDim2.new(0, 0, 0, -8),Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,0.35,true)
		delay(0.3,function() currStampGui.StamperPanel.StamperButtons.ClonePanel.Visible = false end)
	end
end

function cancelAssetPlacement()
	gInitial90DegreeRotations = 0
	Data.Stamp.Cancelled = true
	Data.Stamp.Dragger = nil
	if Data.Stamp.Model then
		Data.Stamp.Model:Remove()
		Data.Stamp.Model = nil
	end
	if Data.Stamp.CurrentParts then
		for index, object in pairs(Data.Stamp.CurrentParts) do
			object:Remove()
		end
		Data.Stamp.CurrentParts = nil
	end

	if Mouse then
		Mouse.Icon ="rbxasset://textures\\ArrowCursor.png"
	end
	game.JointsService:ClearJoinAfterMoveJoints()

end

function hint(label)

	-- Pass in a string, it shows a top hint.  (Replaces previous hint, if exists)
	_player = game.Players:GetPlayerFromCharacter(Tool.Parent)
	if(_player.PlayerGui:FindFirstChild("topHint")~=nil) then
		local topHint = _player.PlayerGui.topHint
		topHint.Add.Label.Value = label
		topHint.Add.Width.Value = 3 -- widest width
		topHint.Add.Time.Value = 5
		topHint.Add.Disabled = true
		topHint.Add.Disabled = false
	end

end

function getPlayer()
	return game.Players:GetPlayerFromCharacter(script.Parent.Parent)
end

function getHumanoid()
	local player = game.Players:GetPlayerFromCharacter(script.Parent.Parent)
	if player then
		waitForProperty(player,"Character")
		waitForChild(player.Character,"Humanoid")
		return player.Character.Humanoid
	else
		return nil
	end
end

function buildSetButton(name, setId, setImageId, i,  count)

	local button = currStampGui.InsertPanel.Sets.SetsLists.SetButtonExample:Clone()
	button.Text = name
	button.Name = "SetButton"
	button.Visible = true

	local setValue = Instance.new("IntValue")
	setValue.Name = "SetId"
	setValue.Value = setId
	setValue.Parent = button

	local setName = Instance.new("StringValue")
	setName.Name = "SetName"
	setName.Value = name
	setName.Parent = button

	return button
end


function previousSetPage()
	local newIndex = math.max(0, Data.Category[Data.CurrentCategory].Index - (InsertRows * InsertColumns))
	setSetIndex(newIndex)
end


function nextSetPage()
	local newIndex = math.max(0, Data.Category[Data.CurrentCategory].Index + (InsertRows * InsertColumns))
	setSetIndex(newIndex)
end

function setInsertButtonImageBehavior(insertFrame, visible, name, assetId)
	if visible then
		insertFrame.AssetName.Value = name
		insertFrame.AssetId.Value = assetId
		local newImageUrl = SmallThumbnailUrl  .. assetId
		if newImageUrl ~= insertFrame.Button.ButtonImage.Image then
			delay(0,function()
				game:GetService("ContentProvider"):Preload(SmallThumbnailUrl  .. assetId)
				insertFrame.Button.ButtonImage.Image = SmallThumbnailUrl  .. assetId
			end)
		end
		table.insert(insertButtonCons,
			insertFrame.Button.MouseButton1Click:connect(function()
				beginInsertAssetGui(insertFrame.AssetName.Value, insertFrame.AssetId.Value, insertFrame.Button.ButtonImage.Image, 1)
			end)
		)
		insertFrame.Visible = true
	else
		insertFrame.Visible = false
	end
end

function setSetIndex(dataOffset)

	Data.Category[Data.CurrentCategory].Index = dataOffset

	InsertRows = math.floor(currStampGui.InsertPanel.ItemsFrame.AbsoluteSize.Y/buttonHeight)
	InsertColumns = math.floor(currStampGui.InsertPanel.ItemsFrame.AbsoluteSize.X/buttonWidth)

	local PageSize = InsertRows * InsertColumns
	local contents = Data.Category[Data.CurrentCategory].Contents
	if contents then
		
		local numOfPages = math.ceil((#contents)/(PageSize))
		local currPage = math.ceil((dataOffset/PageSize) + 1)
		currStampGui.InsertPanel.PagingControls.PageText.Text = tostring(currPage) .. "/" .. tostring(numOfPages)
		currStampGui.InsertPanel.PagingControls.PageText.Visible = (numOfPages &gt; 1)

      currStampGui.InsertPanel.PagingControls.PreviousPageButton.Visible = (numOfPages &gt; 1) and dataOffset &gt; 1
		currStampGui.InsertPanel.PagingControls.NextPageButton.Visible = (numOfPages &gt; 1) and ((dataOffset - 1) + PageSize) &lt; (#contents)

		-- remove our buttons and their connections
		for i = 1, #insertButtons do
			insertButtons[i]:remove()
		end
		for i = 1, #insertButtonCons do
			pcall(function() insertButtonCons[i]:disconnect() end)
		end

		insertButtonCons = {}
		insertButtons = {}
		local arrayPosition = 1
		for y = 1, InsertRows do
			for x = 1, InsertColumns do
				local buttonPosition = UDim2.new(0,(buttonWidth)*(x-1),0, (buttonHeight)*(y-1))

				local buttonCon
				insertButtons[arrayPosition], buttonCon = buildInsertButton(buttonPosition)
				table.insert(insertButtonCons,buttonCon)
				insertButtons[arrayPosition].Parent = currStampGui.InsertPanel.ItemsFrame
				arrayPosition = arrayPosition + 1
			end
		end

		Data.InsertButtons = insertButtons

		for index = 1, PageSize do
			if insertButtons[index] then
				if contents[index + dataOffset] then
					local assetId
					if useAssetVersionId then
						assetId = contents[index + dataOffset].AssetVersionId
					else
						assetId = contents[index + dataOffset].AssetId
					end
					setInsertButtonImageBehavior(insertButtons[index], true, contents[index + dataOffset].Name, assetId)
				else
					setInsertButtonImageBehavior(insertButtons[index], false)
				end
			end
		end
	else
		currStampGui.InsertPanel.PagingControls.PreviousPageButton.Visible = false
		currStampGui.InsertPanel.PagingControls.NextPageButton.Visible = false
	end

end

function moveLoadingLeft()
	if (tick() - startTime &gt; 5) and (currStampGui.Parent ~= nil) then
		loading = false
		cancelAssetPlacement()
		goToInsertPanel()
	end
	if loading then
		currStampGui.LoadDialog.LoadLabel:TweenPosition(UDim2.new(0, 0, 0, -8),Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,0.7,true,function() moveLoadingRight() end)
	end
end

function moveLoadingRight()
	if (tick() - startTime &gt; 5) and (currStampGui.Parent ~= nil) then
		loading = false
		cancelAssetPlacement()
		goToInsertPanel()
	end
	if loading then
		currStampGui.LoadDialog.LoadLabel:TweenPosition(UDim2.new(0, 180, 0, -8),Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,0.7,true,function() moveLoadingLeft() end)
	end
end

function moveLoadingWindow()
	startTime = tick()
	currStampGui.LoadDialog.Visible = true
	loading = true
	moveLoadingRight()
end

function cancelLoadingWindow()
	currStampGui.LoadDialog.Visible = false
	loading = false
end


function selectCategoryPage(buttons, page)

	if buttons ~= Data.CurrentCategory then
		if Data.CurrentCategory then
			for key, button in pairs(Data.CurrentCategory) do
				button.Visible = false
			end
		end

		Data.CurrentCategory = buttons
		if Data.Category[Data.CurrentCategory] == nil then
			Data.Category[Data.CurrentCategory] = {}
			if #buttons &gt; 0 then
				selectSet(buttons[1], buttons[1].SetName.Value, buttons[1].SetId.Value, 0)
			end
		else
			Data.Category[Data.CurrentCategory].Button = nil
			selectSet(Data.Category[Data.CurrentCategory].ButtonFrame, Data.Category[Data.CurrentCategory].SetName, Data.Category[Data.CurrentCategory].SetId, Data.Category[Data.CurrentCategory].Index)
		end
		if Data.Main.FrameHeight then
			if Data.Category[Data.CurrentCategory].SetIndex then
				layoutSetButtons(Data.Main.FrameHeight, Data.Category[Data.CurrentCategory].SetIndex)
			else
				layoutSetButtons(Data.Main.FrameHeight, 1)
			end
		end
	end

end

function selectSet(button, setName, setId, setIndex)

	if button and Data.Category[Data.CurrentCategory] ~= nil then
		if button ~= Data.Category[Data.CurrentCategory].Button then
			Data.Category[Data.CurrentCategory].Button = button

			if SetCache[setId] == nil then
				SetCache[setId] = game:GetService("InsertService"):GetCollection(setId)
			end
			Data.Category[Data.CurrentCategory].Contents = SetCache[setId]

			Data.Category[Data.CurrentCategory].SetName = setName
			Data.Category[Data.CurrentCategory].SetId = setId
		end
		setSetIndex(setIndex)
	end

end


function selectCategory(button, category)
	selectCategoryPage(category, 0)
end


function processCategory(sets, setPanel)
	local setButtons = {}
	local numSkipped = 0
	for index, object in pairs(sets) do
		if not showAdminCategories.Value and object.Name == "Beta" then
			-- skip this if not an admin
			numSkipped = numSkipped + 1
		else
			setButtons[index - numSkipped] = buildSetButton(object.Name, object.CategoryId, object.ImageAssetId, index - numSkipped, #sets)
			setButtons[index - numSkipped].Parent = setPanel
		end
	end
	return setButtons
end


function setsNextPageClick(totalSetPages, gridSize)
	-- set our logic/gui correctly
	if currSetPage &gt;= totalSetPages then return end

	currSetPage = currSetPage + 1
	currStampGui.InsertPanel.PagingControls.PageText.Text = tostring(currSetPage) .. "/" .. tostring(totalSetPages)
	if currSetPage == totalSetPages then
		currStampGui.InsertPanel.PagingControls.NextPageButton.Visible = false
		currStampGui.InsertPanel.PagingControls.PreviousPageButton.Visible = true
	else
		Window.Sets.PagingControls.NextPageButton.Visible = true
	end
	
	-- actually update the items
	makeCurrentSetsPageVisible(gridSize)
end

function setsPrevPageClick(totalSetPages, gridSize)
	-- set our logic/gui correctly
	if currSetPage &lt;= 1 then return end

	currSetPage = currSetPage - 1
	currStampGui.InsertPanel.PagingControls.PageText.Text = tostring(currSetPage) .. "/" .. tostring(totalSetPages)
	if currSetPage == 1 then
		currStampGui.InsertPanel.PagingControls.NextPageButton.Visible = true
		currStampGui.InsertPanel.PagingControls.PreviousPageButton.Visible = false
	else
		currStampGui.InsertPanel.PagingControls.PreviousPageButton.Visible = true
	end

	-- actually update the items
	makeCurrentSetsPageVisible(gridSize)
end

function resetAllSetButtonSelection()
	local setButtons = Window.Sets.SetsLists:GetChildren()
	for i = 1, #setButtons do
		setButtons[i].Selected = false
		setButtons[i].BackgroundTransparency = 1
		setButtons[i].TextColor3 = Color3.new(1,1,1)
		setButtons[i].BackgroundColor3 = Color3.new(1,1,1)
	end
end

function populateSetsFrame()
	local categories = #Data.UserCategoryButtons
	local robloxMaxCat = categories
	
	-- don't do anything until window is visible (otherwise we won't layout anything!)
	while Window.Sets.SetsLists.AbsoluteSize.X &lt;= 0 do
		Window.Sets.SetsLists.Changed:wait()
	end
	while Window.Sets.SetsLists.SetButtonExample.AbsoluteSize.X &lt;= 0 do
		Window.Sets.SetsLists.SetButtonExample.Changed:wait()
	end

	local totalColumns = math.floor(Window.Sets.SetsLists.AbsoluteSize.X/Window.Sets.SetsLists.SetButtonExample.AbsoluteSize.X)
	local totalRows = math.floor(Window.Sets.SetsLists.AbsoluteSize.Y/Window.Sets.SetsLists.SetButtonExample.AbsoluteSize.Y)
	
	local currRow = 0
	local buttonVisible = true

	local masterCategory = 1
	for i = 1, categories do
		local userCategory = masterCategory -- needed to maintain local scope for categories in event listeners below
		local button = Window.Sets.SetsLists.SetButtonExample:clone()

		button.Name = "Set" .. tostring(Data.UserCategoryButtons[userCategory].SetName.Value) .. "Button"
		button.Parent = Window.Sets.SetsLists
		button.Position = UDim2.new(0,5,0,currRow * button.AbsoluteSize.Y)
		button.Visible = buttonVisible
		button.Text =  tostring(Data.UserCategoryButtons[userCategory].SetName.Value)

		if i == 1 then
			button.Selected = true
			button.BackgroundColor3 = Color3.new(0,204/255,0)
			button.TextColor3 = Color3.new(0,0,0)
			button.BackgroundTransparency = 0
		end

		button.MouseEnter:connect(function()
			if not button.Selected then
				button.BackgroundTransparency = 0
				button.TextColor3 = Color3.new(0,0,0)
			end
		end)
		button.MouseLeave:connect(function()
			if not button.Selected then
				button.BackgroundTransparency = 1
				button.TextColor3 = Color3.new(1,1,1)
			end
		end)
		setButtonCons[i] = button.MouseButton1Click:connect(function()
			resetAllSetButtonSelection()
			button.Selected = not button.Selected
			button.BackgroundColor3 = Color3.new(0,204/255,0)
			button.TextColor3 = Color3.new(0,0,0)
			button.BackgroundTransparency = 0

			selectSet(button, button.Text, Data.UserCategoryButtons[userCategory].SetId.Value, 0)
		end)
		
		masterCategory = masterCategory + 1

		currRow = currRow + 1
	end
	
	-- don't use example button as the first set!
	local example = currStampGui.InsertPanel.Sets.SetsLists.SetButtonExample
	currStampGui.InsertPanel.Sets.SetsLists.SetButtonExample.Parent = nil
	local buttons =  currStampGui.InsertPanel.Sets.SetsLists:GetChildren()
	example.Parent = currStampGui.InsertPanel.Sets.SetsLists

	-- set first category as loaded for default
	selectSet(buttons[1], buttons[1].Text, Data.UserCategoryButtons[1].SetId.Value, 0)
	selectCategory(buttons[1], Data.UserCategoryButtons)
end


function layoutSetButtons(frameHeight, setIndex)
	Data.Main.FrameHeight = frameHeight
	Data.Main.InsertSets = math.floor(frameHeight / (height*2))
	if #Data.CurrentCategory &gt; Data.Main.InsertSets then
		--Steal one entry since we have too many things
		Data.Main.InsertSets = Data.Main.InsertSets - 1
	end

	Data.Category[Data.CurrentCategory].SetIndex = setIndex
end


function showLargePreview(insertButton)
	if insertButton:FindFirstChild("AssetId") then
		delay(0,function()
			game:GetService("ContentProvider"):Preload(LargeThumbnailUrl .. tostring(insertButton.AssetId.Value))
			currStampGui.InsertPanel.ItemPreview.LargePreview.Image = LargeThumbnailUrl .. tostring(insertButton.AssetId.Value)
		end)
	end
	if insertButton:FindFirstChild("AssetName") then
		currStampGui.InsertPanel.ItemPreview.TextPanel.RolloverText.Text = insertButton.AssetName.Value
	end
end


function buildInsertButton(buttonPosition)
	local insertButton = currStampGui.InsertPanel.ItemsFrame.InsertAssetButtonExample:clone()
	insertButton.Position = buttonPosition
	insertButton.Name = "InsertAssetButton"
	insertButton.Visible = true

	local mouseEnterCon = insertButton.MouseEnter:connect(function()
		lastEnter = insertButton
		delay(0.1,function()
			if lastEnter == insertButton then
				showLargePreview(insertButton)
			end
		end)
	end)
	return insertButton, mouseEnterCon
end

function minimizeStamperPanel()
	currStampGui.StamperPanel.StamperButtons.Visible = false
	currStampGui.StamperPanel.MinimizeButton.Visible = false
	if currStampGui.Parent ~= nil then
		currStampGui.StamperPanel:TweenSizeAndPosition(UDim2.new(0,0,0,0), UDim2.new(0.5,0,1,-92),Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,0.5,true)
		delay(0.5,function()
			currStampGui.StamperPanel.RestoreButton.Visible = true
		end)
	end
end

function restoreStamperPanel()
	currStampGui.StamperPanel.RestoreButton.Visible = false
	if currStampGui.Parent ~= nil then
		currStampGui.StamperPanel:TweenSizeAndPosition(UDim2.new(0,350,0,48), UDim2.new(0.5,-175,1,-135), Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,0.5,true)
		delay(0.5,function()
			currStampGui.StamperPanel.StamperButtons.Visible = true
			currStampGui.StamperPanel.MinimizeButton.Visible = true
		end)
	end
end

function setUpStamperGui()
	pcall(function() currStampGui.InsertPanel.CancelButton.Modal = true end)
	Window.Sets = currStampGui.InsertPanel.Sets

	cloneButtonCon = currStampGui.StamperPanel.StamperButtons.CloneButton.MouseButton1Click:connect(goToClone)
	partListClickCon = currStampGui.StamperPanel.StamperButtons.PartsButton.MouseButton1Click:connect(goToInsertPanel)

	Data.Main = {}
	Data.Category = {}
	Data.Stamp = {}

	Data.BaseCategoryButtons = {}
	local userData = {}
	for id = 1, #userIdsForStamperParts do
		local newUserData = game:GetService("InsertService"):GetUserCategories(userIdsForStamperParts[id].Value)
		if newUserData and #newUserData &gt; 2 then
			-- start at #3 to skip over My Decals and My Models for each account
			for category = 3, #newUserData do
				if newUserData[category].Name == "High Scalability" then
					table.insert(userData,1,newUserData[category])
				else
					table.insert(userData, newUserData[category])
				end
			end
		end
	end
	
	if userData then
		Data.UserCategoryButtons = processCategory(userData, setPanel)
	end

	guiChangedCon = currStampGui.Changed:connect(function(prop)
		if prop == "AbsoluteSize" then
			wait()
			setSetIndex(0)
		end
	end)

	InsertRows = math.floor(currStampGui.InsertPanel.ItemsFrame.AbsoluteSize.Y/buttonHeight)
	InsertColumns = math.floor(currStampGui.InsertPanel.ItemsFrame.AbsoluteSize.X/buttonWidth)

	populateSetsFrame()

	setsPrevPageCon = currStampGui.InsertPanel.PagingControls.PreviousPageButton.MouseButton1Click:connect(function() previousSetPage() end)
	setsNextPageCon = currStampGui.InsertPanel.PagingControls.NextPageButton.MouseButton1Click:connect(function() nextSetPage() end)

	insertPanelCloseCon = currStampGui.InsertPanel.CancelButton.MouseButton1Click:connect(function()
		closeInsertPanel()
		closeClonePanel()
		reloadCurrentAsset()
	end)

	minimizeCon = currStampGui.StamperPanel.MinimizeButton.MouseButton1Click:connect(function() minimizeStamperPanel() end)
	restoreCon = currStampGui.StamperPanel.RestoreButton.MouseButton1Click:connect(function() restoreStamperPanel() end)
end

-- signal to scripts we are ready to start manipulating objects
function signalStamperScript(assetName, assetId, image, stampMode)
	insertAsset.AssetName.Value = assetName
	insertAsset.AssetId.Value = assetId
	insertAsset.Image.Value = image
	insertAsset.StampMode.Value = stampMode
	insertAsset.Updated.Value = true
end

function reloadCurrentAsset()
	variables.ReloadCurrentAsset.Value = true
end


function beginInsertAssetGui(assetName, assetId, image, stampMode)
	Data.Stamp.StampMode = stampMode
	closeInsertPanel()
	signalStamperScript("",0,"","",false)
	moveLoadingWindow()
	cancelAssetPlacement()
	signalStamperScript(assetName, assetId, image, stampMode)
end


function cancelAssetLoad()
	Data.Loading.Cancelled = true
	insertComplete()
	gInitial90DegreeRotations = 0
end

function inBounds2(part)
	-- part must have a position property
	local xOne= buildingPlate.Position.x + buildingPlate.Size.x/2
	local xTwo = buildingPlate.Position.x - buildingPlate.Size.x/2
	local zOne = buildingPlate.Position.z + buildingPlate.Size.z/2
	local zTwo = buildingPlate.Position.z - buildingPlate.Size.z/2
	if part.Position.x &gt; xOne or part.Position.x &lt; xTwo then return false end
	if part.Position.z &gt; zOne or part.Position.z &lt; zTwo then return false end
	return true
end


-- For Restricting Stamper Tool (isRestricted)
function showHelp_pointToBuildingplate()

	if(buildingPlate==nil) then
		hint("All building areas are taken. If you want to build, leave and join again.")
	else
		-- only show one waypoint at a time (because kids will click a million times outside their plate)
		hint("Stamper Tool only works in your area.")
		if(not waypointShowing) then
			waypointShowing = true
			local _character = Tool.Parent
			waitForChild(_character, "Torso")
			_player = game.Players:GetPlayerFromCharacter(_character)
			_player.PlayerGui.showBaseplateWaypoint.target.Value = buildingPlate
			_player.PlayerGui.showBaseplateWaypoint.Disabled = true
			_player.PlayerGui.showBaseplateWaypoint.Disabled = false
			-- Wait until character moves in bounds (check every 2 seconds)
			while(not inBounds2(_character.Torso) and isEquipped) do	wait(2) end
			-- Then hide the waypoint
			hideHelp_pointToBuildingplate()
		end
	end

end


function showHelp_tooManyParts()
	hint("You have reached maximum number of parts! Delete some to put more down.")
end


function hideHelp_pointToBuildingplate()
	waypointShowing = false
	_player.PlayerGui.hideBaseplateWaypoint.Disabled = true
	_player.PlayerGui.hideBaseplateWaypoint.Disabled = false		
end


function setUpRestrictions()
	playerModel = game.Workspace.ActiveParts:FindFirstChild(player.Name .. "'s parts")

	local takenAreas = game.Workspace.BuildingAreas:GetChildren()

	waitForChild(player, "playerNumber")
		
	if(player.playerNumber.Value == 0) then
	  buildingPlate = nil
	  partModel = nil
	else
	  waitForChild(game.Workspace, "BuildingAreas")
	  local buildingAreas = game.Workspace.BuildingAreas
	  waitForChild(buildingAreas, "Area"..tostring(player.playerNumber.Value))
	  local targetArea = buildingAreas:FindFirstChild("Area"..tostring(player.playerNumber.Value))
	  waitForChild(targetArea, "PlayerArea")
	  waitForChild(targetArea.PlayerArea, "BasePlate")

	  buildingPlate = targetArea.PlayerArea.BasePlate
	  partModel = targetArea.PlayerArea
			
	end

	-- Check if player is standing in bounds, if not show error
	local _character = Tool.Parent
	waitForChild(_character, "Torso")
	_player = game.Players:GetPlayerFromCharacter(_character)
	if(buildingPlate~=nil) then
		if(not inBounds2(_character.Torso)) then
			showHelp_pointToBuildingplate()
		end
	else
		-- You have no building plate.
		hint("All building areas are taken. If you want to build, leave and join again.")
	end
end

function onInsertKeyDown(key)
	if loading then return end -- don't try to switch while we're loading

	key = string.lower(key)

	-- go to mru buttons
	if key == 'f' then
		mruButtonClick(1)
	elseif key == 'g' then
		mruButtonClick(2)
	elseif key == 'h' then
		mruButtonClick(3)
	elseif key == 'j' then
		mruButtonClick(4)
	end

end

function onEquippedLocal(mouse)
	player = getPlayer()
	if not player then 
		return 
	end
	if Tool.PlayerOwner.Value and Tool.PlayerOwner.Value ~= player then return end 

	-- For Restricting Stamper Tool
	if isRestricted.Value then
		setUpRestrictions()
	end

	Mouse = mouse
	if not firstEquip and currStampGui and Tool.SavedState.Value and Tool.PlayerOwner.Value == getPlayer() and Data and Data.FullyLoaded then

		currStampGui.Parent = getPlayer().PlayerGui

		if mode == 1 then -- if we were stamping, keep going
			-- if we signal a negative asset, then that means keep going using whatever was in recent memory [don't reload from insert service]
			signalStamperScript(insertAsset.AssetName.Value, -1, insertAsset.Image.Value, true)			
		elseif mode == 2 then -- time to clone
			goToClone()
		end

	else
		if firstEquip then
			Tool.PlayerOwner.Value = player
			firstEquip = false
		end
		CancelDuringLoad = false
		resetCons()

		Data = {}
		Data.FullyLoaded = false
				
		Window = {}
		Window.Sets = {}

		currStampGui = stamperGui:clone()
		currStampGui.Parent = getPlayer().PlayerGui
		wait()
		setUpStamperGui()

		if not(CancelDuringLoad) then
			currStampGui.Parent = getPlayer().PlayerGui
			Tool.SavedState.Value = currStampGui
		end

		Data.FullyLoaded = true
	end

	Mouse.KeyDown:connect(onInsertKeyDown)
end


function onUnequippedLocal()
	if currStampGui then
		Tool.SavedState.Value = currStampGui
		currStampGui.Parent = nil
	end
	
	pcall(function()
		cancelAssetPlacement()
		Data.Loading.Cancelled = true
	end)
	CancelDuringLoad = true
end


function killConnection(connection)
	if connection then connection:disconnect() end
end


function resetCons()
	killConnection(guiChangedCon)
	killConnection(cloneButtonCon)
	killConnection(partListClickCon)
	killConnection(itemFrameChangedCon)
	killConnection(setsPrevPageCon)
	killConnection(setsNextPageCon)
	killConnection(insertPanelCloseCon)
	killConnection(minimizeCon)
	killConnection(restoreCon)
end


function onAncestryChanged(child,parent)
	if Tool.PlayerOwner.Value and not Tool:IsDescendantOf(Tool.PlayerOwner.Value) and not Tool:IsDescendantOf(Tool.PlayerOwner.Value.Character) then
		--Tool was dropped in some way, so we need to nuke our external state
		Tool.SavedState.Value = nil
		resetCons()
	end
end


function getMaxNumOfRecentParts()
	return maxRecentParts
end


function pushRecentStackBack()
	for i = getMaxNumOfRecentParts() - 1, 1, -1 do
		recentPartStack[i + 1].AssetNameValue = recentPartStack[i].AssetNameValue
		recentPartStack[i + 1].AssetIdValue = recentPartStack[i].AssetIdValue
		recentPartStack[i + 1].InsertFrameButtonImage = recentPartStack[i].InsertFrameButtonImage
	end
end


function clearMRUList()
	local buttons = currStampGui.StamperPanel.StamperButtons.RecentFrame:GetChildren()
	for i = 1, #buttons do
		if recentPartStackCons[i] then recentPartStackCons[i]:disconnect() end
		buttons[i].Visible = false
	end
end


function mruButtonClick(position)
	if recentPartStack[position].AssetIdValue == insertAsset.AssetId.Value then return end -- already stamping part
	-- get rid of old part
	signalStamperScript("",0,"","",false)

	--Show the dialog window
	moveLoadingWindow()
	signalStamperScript(recentPartStack[position].AssetNameValue, recentPartStack[position].AssetIdValue, recentPartStack[position].InsertFrameButtonImage, true)
end


function insertMRUButton(position)
	local mruButton = currStampGui.StamperPanel.StamperButtons.RecentFrame:FindFirstChild("Button" .. tostring(position))
	mruButton.ButtonImage.Image = recentPartStack[position].InsertFrameButtonImage
	if mruButton.ButtonImage.Image == "" then
		mruButton.Text = recentPartStack[position].AssetNameValue
	end

	if recentPartStackCons[position] then pcall(function() recentPartStackCons[position]:Disconnect() end) end
	recentPartStackCons[position] = mruButton.MouseButton1Click:connect(function() mruButtonClick(position) end)
	mruButton.Visible = true
end


function refreshRecentParts()
	if insertAsset.Image.Value == "" then return end -- we don't have an asset, get out of here
	if not recentPartStack then return end -- if somehow not created yet (recentPartStack[i] calls below were nil somehow)
	
	local numOfRecentParts = getMaxNumOfRecentParts()

	for i = 1,numOfRecentParts do
		if insertAsset.AssetId and recentPartStack[i] and insertAsset.AssetId.Value == recentPartStack[i].AssetIdValue then -- already have part, don't push back
			return
		end
	end

	pushRecentStackBack()

	-- update our stack to show previously allocated part
	recentPartStack[1].AssetNameValue = insertAsset.AssetName.Value
	recentPartStack[1].AssetIdValue = insertAsset.AssetId.Value
	recentPartStack[1].InsertFrameButtonImage =  insertAsset.Image.Value

	clearMRUList()

	for i = 1, numOfRecentParts do
		if recentPartStack[i] and recentPartStack[i].AssetIdValue ~= "" then
			insertMRUButton(i)
		end
	end
end


function updateGui(type)
	if type == "Main" then
		goToInsertPanel()
	elseif type == "EyeDropper" then
		goToClone()
	elseif type == "SideDialog" then
		goToStamp()
	end
end
----------------------------------------------------------------------------------------



-- Lua Start Execution
setAssetUrls()

Tool.Equipped:connect(onEquippedLocal)
Tool.Unequipped:connect(onUnequippedLocal)
Tool.AncestryChanged:connect(onAncestryChanged)

waitForChild(variables, "SwitchLoaderToDialog")
variables.SwitchLoaderToDialog.Changed:connect(function(prop)
	if variables.SwitchLoaderToDialog.Value == true then
		updateGui(variables.SwitchLoaderToDialog.DialogType.Value)
		variables.SwitchLoaderToDialog.Value = false
	end

end)

waitForChild(variables, "ShowInvalidPlacement")
variables.ShowInvalidPlacement.Changed:connect(function(prop)
	if variables.ShowInvalidPlacement.Value == true then
		showHelp_pointToBuildingplate()
		showBaseplateGuideArrows()
		variables.ShowInvalidPlacement.Value = false
	end
end)

waitForChild(variables, "ShowMaxedOut")
variables.ShowMaxedOut.Changed:connect(function(prop)
	if variables.ShowMaxedOut.Value == true then
		showHelp_tooManyParts()
		variables.ShowMaxedOut.Value = false
	end
end)

waitForChild(variables, "Stamped")
variables.Stamped.Changed:connect(function()
	if variables.Stamped.Value == true then
		refreshRecentParts()
	end
end)
----------------------------------------------------------------------------------------</ProtectedString>
			</Properties>
		</Item>
		<Item class="LocalScript" referent="RBX151">
			<Properties>
				<bool name="Disabled">true</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Readme</string>
				<ProtectedString name="Source">--[[ 
	Stamper Tool v1.0.0
	

	Welcome to the stamper tool readme!
	Currently, this doc only exists to show the Stamper Tool Version!

]] </ProtectedString>
			</Properties>
		</Item>
		<Item class="LocalScript" referent="RBX152">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">StampScript</string>
				<ProtectedString name="Source">-- basic functions

function waitForChild(instance, name)
	while not instance:findFirstChild(name) do
		instance.ChildAdded:wait()
	end
end
----------------------------------------------------------------------------------------

-- Locals

local Tool = script.Parent

local Mouse
local mouseMoveCon
local mouseButton1DownCon
local mouseButton1UpCon
local cameraChangeCon

local walking = false

local pressedEsc = false

local billBoardOwnerGui = nil

local cluster = game.Workspace:FindFirstChild("Terrain")

local gInitial90DegreeRotations = 0
local gStaticTrans = 1
local gDesiredTrans = 0.7
local transFadeInTime = 0.5
local fadeInDelayTime = 0.5
local eyedropperOffGridTolerance = 0.01

local insertBoundingBoxOverlapVector = Vector3.new(1, 1, 1) -- we can still stamp if our character extrudes into the target stamping space by 1 or fewer units

local useAssetVersionId = false


-- for high-scalability display
local adornPart = Instance.new("Part")
adornPart.Parent = nil
adornPart.formFactor = "Custom"
adornPart.Size = Vector3.new(4, 4, 4)
adornPart.CFrame = CFrame.new()

local adorn = Instance.new("SelectionBox")
adorn.Color = BrickColor.new("Toothpaste")
adorn.Adornee = adornPart
adorn.Visible = true
adorn.Transparency = 0
adorn.Name = "HighScalabilityStamperLine"
adorn.Parent = nil

local terrainSelectionBox = Instance.new("Part")
terrainSelectionBox.Parent = nil
terrainSelectionBox.formFactor = "Custom"
terrainSelectionBox.Size = Vector3.new(4, 4, 4)
terrainSelectionBox.CFrame = CFrame.new()

local HighScalabilityLine = {}
HighScalabilityLine.Start = nil
HighScalabilityLine.End = nil
HighScalabilityLine.Adorn = adorn
HighScalabilityLine.AdornPart = adornPart
HighScalabilityLine.InternalLine = nil
HighScalabilityLine.NewHint = true

-- for higher dimensional megacluster part stamping
HighScalabilityLine.MorePoints = {nil, nil}
HighScalabilityLine.MoreLines = {nil, nil}
HighScalabilityLine.Dimensions = 1

waitForChild(Tool,"LuaGlobalVariables")
local variables = Tool.LuaGlobalVariables
waitForChild(variables,"ShowInvalidPlacement")
waitForChild(variables, "Stamped")
waitForChild(Tool,"ErrorBox")
waitForChild(variables, "ShowAdminCategories")
local errorBox = Tool.ErrorBox

waitForChild(variables, "IsRestricted")
waitForChild(variables, "MouseClick")
click = variables.MouseClick

local Data = {}
Data.Stamp = {}
Data.Loading = {}

local guiScriptIsLoadingSomething = false
local unstampableSurface = false

local eyeDropperConnection, eyeDropperMoveConnection

local playerModel
local player

local lastTargetCFrame = nil
local lastTargetTerrainOrientation = 0

-- For Restricting Stamper Tool
local isRestricted = variables.IsRestricted.Value
local adminAccess = variables.ShowAdminCategories.Value

-- For Delete highlighting
local selectionBox
local currentSelection
local currentSelectionColors = {}

if isRestricted then waitForChild(game.Workspace, "BaseplateBumpers") end
----------------------------------------------------------------------------------------

-- Functions
function hint(label)
	-- Pass in a string, it shows a top hint.  (Replaces previous hint, if exists)
	_player = game.Players:GetPlayerFromCharacter(Tool.Parent)
	if(_player.PlayerGui:FindFirstChild("topHint")~=nil) then
		local topHint = _player.PlayerGui.topHint
		topHint.Add.Label.Value = label
		topHint.Add.Width.Value = 3 -- widest width
		topHint.Add.Time.Value = 5
		topHint.Add.Disabled = true
		topHint.Add.Disabled = false
	end
end


function getClosestColorToTerrainMaterial(terrainValue)
	if terrainValue == 1 then
		return BrickColor.new("Bright green")
	elseif terrainValue == 2 then
		return BrickColor.new("Bright yellow")
	elseif terrainValue == 3 then
		return BrickColor.new("Bright red")
	elseif terrainValue == 4 then
		return BrickColor.new("Medium stone grey")
	else
		return BrickColor.new("Bright green")
	end
end


local manualWeldTable = {}
local manualWeldParentTable = {}
function saveTheWelds(object)
	if object:IsA("ManualWeld") or object:IsA("Rotate") then
		table.insert(manualWeldTable, object)
		table.insert(manualWeldParentTable, object.Parent)
	else
		local children = object:GetChildren()
		for i = 1, #children do
			saveTheWelds(children[i])
		end
	end
end

function restoreTheWelds()
	for i = 1, #manualWeldTable do
		manualWeldTable[i].Parent = manualWeldParentTable[i]
	end
end


function findSeatsInModel(parent, seatTable)
	if not parent then return end

	if parent.className == "Seat" or parent.className == "VehicleSeat" then
		table.insert(seatTable, parent)
	end
	local myChildren = parent:GetChildren()
	for j = 1, #myChildren do
		findSeatsInModel(myChildren[j], seatTable)
	end
end

function setSeatEnabledStatus(model, isEnabled)
	local seatList = {}
	findSeatsInModel(model, seatList)

	if isEnabled then
		-- remove any welds called "SeatWeld" in seats
		for i = 1, #seatList do
			local nextSeat = seatList[i]:FindFirstChild("SeatWeld")
			while nextSeat do nextSeat:Remove() nextSeat = seatList[i]:FindFirstChild("SeatWeld") end
		end
	else
		-- put a weld called "SeatWeld" in every seat
		--   this tricks it into thinking there's already someone sitting there, and it won't make you sit XD
		for i = 1, #seatList do
			local fakeWeld = Instance.new("Weld")
			fakeWeld.Name = "SeatWeld"
			fakeWeld.Parent = seatList[i]
		end
	end
end


function UnlockInstances(object)

	if object:IsA("BasePart") then
		object.Locked = false
	end
	for index,child in pairs(object:GetChildren()) do
		UnlockInstances(child)
	end

end

function generateOwnerGui(playerName)
	local gui = Instance.new("BillboardGui")
	gui.Name = "PlayerStamperTagGui"
	gui.StudsOffset = Vector3.new(0,1,0)
	gui.ExtentsOffset = Vector3.new(0,1,0)
	gui.Size = UDim2.new(5,0,2,0)
	pcall(function() gui.PlayerToHideFrom = game.Players.LocalPlayer end)

	local frame = Instance.new("Frame")
	frame.BackgroundColor3 = Color3.new(0,0,0)
	frame.BackgroundTransparency = 0.5
	frame.Name = "OwnerFrame"
	frame.Size = UDim2.new(1,0,1,0)
	frame.Parent = gui
	
	local ownerName = Instance.new("TextLabel")
	ownerName.Name = "OwnerName"
	ownerName.Size = UDim2.new(1,0,1,0)
	ownerName.Text = playerName
	ownerName.Font = Enum.Font.ArialBold
	ownerName.FontSize = Enum.FontSize.Size14
	ownerName.TextWrap = true
	ownerName.TextColor3 = Color3.new(1,1,1)
	ownerName.TextStrokeTransparency = 0
	ownerName.BackgroundTransparency = 1
	ownerName.Parent = frame

	return gui
end



function getPlayer()
	return game.Players:GetPlayerFromCharacter(script.Parent.Parent)
end

function beginInsertAssetStamp(assetName, assetId, image, stampMode)
	-- trying to stop assets, gone back to Main Stamp Dialog
	if assetId == 0 then
		guiScriptIsLoadingSomething = true
		cancelAssetPlacement()
		return
	end
	if assetId &lt; 0 then
		guiScriptIsLoadingSomething = true
		cancelAssetPlacement()
		setupDraggableClone()
		wait() -- need this so onInsertMouseMove() can sync up with setupDraggableClone()
		onInsertMouseMove()
		guiScriptIsLoadingSomething = false
		return
	end
	-- This call will cause a "wait" until the data comes back
	-- below we wait a max of 8 seconds before deciding to bail out on loading
	local root
	local loader
	loading = true
	if useAssetVersionId then
		loader = coroutine.create(function()	
			root = game:GetService("InsertService"):LoadAssetVersion(assetId)
			loading = false
		end)
		coroutine.resume(loader)
	else
		loader = coroutine.create(function()	
			root = game:GetService("InsertService"):LoadAsset(assetId)
			loading = false
		end)
		coroutine.resume(loader)
	end

	local lastGameTime = 0
	local totalTime = 0
	local maxWait = 8
	while loading and totalTime &lt; maxWait do
		lastGameTime = tick()
		wait(1)
		totalTime = totalTime + tick() - lastGameTime
	end
	loading = false

	if totalTime &gt;= maxWait or pressedEsc then
		Data.Loading.Cancelled = true
		pressedEsc = false
	else
		Data.Loading.Cancelled = false
	end


	if Data.Loading.Cancelled then
		--The user got bored and wandered off
		--Just delete the model from the world... a shame we loaded it when they got bored
		-- 12/28/2010: Putting this inside a pcall (on gametest, first time equipping stamper, this was being called with root=nil.) (Jahr)
		pcall(function() root:Remove() end)
		signalInsertComplete("Main")
	else
		if root == nil then
			signalInsertComplete("Main")
			return
		end

		if not root:IsA("Model") then
			signalInsertComplete("Main")
			return
		end

		local instances = root:GetChildren()
		if #instances == 0 then
			root:Remove()
			signalInsertComplete("Main")
			return
		end

		--Unlock all parts that are inserted, to make sure they are editable
		UnlockInstances(root)

		--Continue the insert process
		root.Name = "InsertedObject" .. assetId

		--Examine the contents and decide what it looks like
		for pos, instance in pairs(instances) do
			--Single instance objects might be treated special, decals/skyboxes
			if instance:IsA("Decal") then
				--Current system here stops after finding one Decal (and gives you Decal tool)
				--We should do the same (probably)
				beginInsertDecal(instance)
				root:Remove()

				Window.Stamp.Frame.Visible = true
				return
			elseif instance:IsA("Team") then
				instance.Parent = game:GetService("Teams")
			elseif instance:IsA("SpawnLocation") then
				-- uh.............
			elseif instance:IsA("HopperBin") then
				-- Must go into the starterPack, prompt user?
			elseif instance:IsA("Tool") then
				-- Ask them if it should go in StarterPack?
			elseif instance:IsA("Sky") then
				local lightingService = game:GetService("Lighting")
				for index,child in pairs(lightingService:GetChildren()) do
					if child:IsA("Sky") then
						child:Remove();
					end
				end
				instance.Parent = lightingService
				return
			else

			end
		end

		if #root:GetChildren() == 0 then
			root:Remove()
			signalInsertComplete("Main")
			return
		end

		signalInsertComplete("SideDialog")
		
		cancelAssetPlacement()
		Data.Stamp.Model = root
		setupDraggableClone()
		guiScriptIsLoadingSomething = false
	end

end

function beginInsertDecal(decal)

	Data.Stamp.DecalSelection = Instance.new("SurfaceSelection")
	Data.Stamp.DecalSelection.Color = BrickColor.new("Bright orange")
	Data.Stamp.DecalSelection.archivable = false
	Data.Stamp.DecalSelection.Parent = getPlayer().PlayerGui

	--Save the decal in our Lua code for later use
	Data.Stamp.Decal = decal
	Data.Stamp.Decal.Parent = nil

end


-- signal to gui to switch frames
function signalInsertComplete(type)

	if type == "SideDialog" then
		variables.SwitchLoaderToDialog.DialogType.Value = "SideDialog"
		variables.SwitchLoaderToDialog.Value = true
	elseif type == "Main" then
		variables.SwitchLoaderToDialog.DialogType.Value = "Main"
		variables.SwitchLoaderToDialog.Value = true
	elseif type == "EyeDropper" then
		variables.SwitchLoaderToDialog.DialogType.Value = "EyeDropper"
		variables.SwitchLoaderToDialog.Value = true
	end

	-- needed to make sure we disconnect eyedroper handler
	if type ~= "EyeDropper" then
		if eyeDropperConnection then
			eyeDropperConnection:disconnect()
			eyeDropperConnection = nil
		end
		if eyeDropperMoveConnection then eyeDropperMoveConnection:disconnect() end

		if Mouse and not mouseButton1UpCon then mouseButton1UpCon = Mouse.Button1Up:connect(onInsertMouseButton1Up) end
	end
	clearSelection()

end


function p(assetName, assetId, image, stampMode)
	-- trying to stop assets, gone back to Main Stamp Dialog
	if assetId == 0 then
		cancelAssetPlacement()
		return
	end

	-- This call will cause a "wait" until the data comes back
	-- below we wait a max of 8 seconds before deciding to bail out on loading
	local root
	local loader
	loading = true
	if useAssetVersionId then
		loader = coroutine.create(function()
			root = game:GetService("InsertService"):LoadAssetVersion(assetId)
			loading = false
		end)
		coroutine.resume(loader)
	else
		loader = coroutine.create(function()	
			root = game:GetService("InsertService"):LoadAsset(assetId)
			loading = false
		end)
		coroutine.resume(loader)
	end

	local lastGameTime = 0
	local totalTime = 0
	local maxWait = 8
	while loading and totalTime &lt; maxWait do
		lastGameTime = tick()
		wait(1)
		totalTime = totalTime + tick() - lastGameTime
	end
	loading = false

	if totalTime &gt;= maxWait or pressedEsc then
		Data.Loading.Cancelled = true
		pressedEsc = false
	else
		Data.Loading.Cancelled = false
	end


	if Data.Loading.Cancelled then
		--The user got bored and wandered off
		--Just delete the model from the world... a shame we loaded it when they got bored
		-- 12/28/2010: Putting this inside a pcall (on gametest, first time equipping stamper, this was being called with root=nil.) (Jahr)
		pcall(function() root:Remove() end)
		signalInsertComplete("Main")
	else
		local instances = root:GetChildren()
		if #instances == 0 then
			root:Remove()
			signalInsertComplete("Main")
			return
		end

		--Unlock all parts that are inserted, to make sure they are editable
		UnlockInstances(root)

		--Continue the insert process
		root.Name = "InsertedObject" .. assetId

		--Examine the contents and decide what it looks like
		for pos, instance in pairs(instances) do
			--Single instance objects might be treated special, decals/skyboxes
			if instance:IsA("Decal") then
				--Current system here stops after finding one Decal (and gives you Decal tool)
				--We should do the same (probably)
				beginInsertDecal(instance)
				root:Remove()

				Window.Stamp.Frame.Visible = true
				return
			elseif instance:IsA("Team") then
				instance.Parent = game:GetService("Teams")
			elseif instance:IsA("SpawnLocation") then
				-- uh.............
			elseif instance:IsA("HopperBin") then
				-- Must go into the starterPack, prompt user?
			elseif instance:IsA("Tool") then
				-- Ask them if it should go in StarterPack?
			elseif instance:IsA("Sky") then
				local lightingService = game:GetService("Lighting")
				for index,child in pairs(lightingService:GetChildren()) do
					if child:IsA("Sky") then
						child:Remove();
					end
				end
				instance.Parent = lightingService
				return
			else

			end
		end

		if #root:GetChildren() == 0 then
			root:Remove()
			signalInsertComplete("Main")
			return
		end

		signalInsertComplete("SideDialog")
		
		cancelAssetPlacement()
		Data.Stamp.Model = root
		setupDraggableClone()
	end

end


function positionPartsAtCFrame3(partOrModel, aCFrame)

	local insertCFrame
	if Data.Stamp.CurrentParts[1]:IsA("Model") or Data.Stamp.CurrentParts[1]:IsA("Tool") then
		--insertCFrame = Data.Stamp.CurrentParts[1]:GetChildren()[1].CFrame
		-- we assume model has at least one part in it; need to find first part
		i = 1
		while (i &lt; (#Data.Stamp.CurrentParts[1]:GetChildren()) and not Data.Stamp.CurrentParts[1]:GetChildren()[i]:IsA("Part") and not Data.Stamp.CurrentParts[1]:GetChildren()[i]:IsA("TrussPart") and not Data.Stamp.CurrentParts[1]:GetChildren()[i]:IsA("WedgePart") and not Data.Stamp.CurrentParts[1]:GetChildren()[i]:IsA("CornerWedgePart")) do
			i = i + 1
		end
		insertCFrame = Data.Stamp.CurrentParts[1]:GetChildren()[i].CFrame

		for i, object in pairs(Data.Stamp.CurrentParts[1]:GetChildren()) do
			if object:IsA("Flag") then object = object.Handle end
			if (object:IsA("Part") or object:IsA("WedgePart") or object:IsA("CornerWedgePart") or object:IsA("TrussPart") or object:IsA("Seat") or object:IsA("VehicleSeat")) then
				local posPartInWorld = object.Position
				local posPart1InWorld = insertCFrame.p
				local newPosPartInWorld = posPartInWorld - posPart1InWorld + aCFrame.p
	
				local x, y, z, R00, R01, R02, R10, R11, R12, R20, R21, R22 = object.CFrame:components()
				object.CFrame = CFrame.new(newPosPartInWorld.x, newPosPartInWorld.y, newPosPartInWorld.z, R00, R01, R02, R10, R11, R12, R20, R21, R22)
			end
		end
		else
		Data.Stamp.CurrentParts[1].CFrame = aCFrame
	end

end


-- For Restricting Stamper Tool (isRestricted)
function inBounds(object)

	for part, transparency in pairs(object) do
		if part:IsA("Part") or part:IsA("WedgePart") or part:IsA("CornerWedgePart") or part:IsA("TrussPart") then
			if not partInBounds(part) then return false end
		elseif part:IsA("Model") then
			local primPart = object.PrimaryPart
			if not partInBounds(primPart) then return false end
		end
	end
	return true

end

function partInBounds(part)

	if part == nil then return false end

	local xOne= buildingPlate.Position.x + buildingPlate.Size.x/2
	local xTwo = buildingPlate.Position.x - buildingPlate.Size.x/2
	local zOne = buildingPlate.Position.z + buildingPlate.Size.z/2
	local zTwo = buildingPlate.Position.z - buildingPlate.Size.z/2

	if part.Position.x &gt; xOne or part.Position.x &lt; xTwo then return false end
	if part.Position.z &gt; zOne or part.Position.z &lt; zTwo then return false end

	return true

end



function canSelectObject(part)
	return part and not (part.Locked) and part:IsA("BasePart") and (part.Position - Tool.Parent.Head.Position).Magnitude &lt; 60
end

function canEyeDropperObject(part)
	local stamperTag = part.Parent:FindFirstChild("RobloxStamper")
	if stamperTag == nil then stamperTag = part:FindFirstChild("RobloxStamper") end

	return part and not (part.Locked) and part:IsA("BasePart") and (part.Position - Tool.Parent.Head.Position).Magnitude &lt; 60 and stamperTag ~= nil
end

function isOnGrid(partOrModel)
	-- first check to see if off-grid, and if so, prevent eyedropperage
		local modelExtentsInWorldCoords
		if partOrModel:IsA("Model") then
			modelExtentsInWorldCoords = partOrModel:GetModelCFrame():vectorToWorldSpace(partOrModel:GetModelSize())
		else
			modelExtentsInWorldCoords = partOrModel.CFrame:vectorToWorldSpace(partOrModel.Size)
		end

		-- we now simply check to see if the above property fits in a 4x4x4 gridspace
		offX = math.fmod(math.abs(modelExtentsInWorldCoords.X), 4)
		offY = math.fmod(math.abs(modelExtentsInWorldCoords.Y), 4)
		offZ = math.fmod(math.abs(modelExtentsInWorldCoords.Z), 4)

		local numberOfAxesOffGrid = 0
		if math.min(offX, 4 - offX) &gt; eyedropperOffGridTolerance then numberOfAxesOffGrid = numberOfAxesOffGrid + 1 end
		if math.min(offY, 4 - offY) &gt; eyedropperOffGridTolerance then numberOfAxesOffGrid = numberOfAxesOffGrid + 1 end
		if math.min(offZ, 4 - offZ) &gt; eyedropperOffGridTolerance then numberOfAxesOffGrid = numberOfAxesOffGrid + 1 end

		if numberOfAxesOffGrid &gt; 1 then return false -- we allow one axis to be not fit to grid, since any rotation must necessarily affect &gt;= 2 axes (some of the models are like 4x4x6 :(  ).
		else return true end
end


-- below is a helper function to help get the model surface instead of the part surface [for allowing a side to elect out of making joints automatically]
function calcRayHitTime(rayStart, raySlope, intersectionPlane)
	if math.abs(raySlope) &lt; .01 then return 0 end -- 0 slope --&gt;  we just say intersection time is 0, and sidestep this dimension
	-- rayStart + t*raySlope = intersectionPlane, so t = (intersectionPlane - rayStart) / raySlope
	return (intersectionPlane - rayStart) / raySlope
end


function modelTargetSurface(partOrModel, rayStart, rayEnd)
	if not partOrModel then
		return 0
	end

	local modelCFrame = nil
	local modelSize = nil
	if partOrModel:IsA("Model") then
		modelCFrame = partOrModel:GetModelCFrame()
		modelSize = partOrModel:GetModelSize()
	else
		modelCFrame = partOrModel.CFrame
		modelSize = partOrModel.Size
	end

	local mouseRayStart = modelCFrame:pointToObjectSpace(rayStart)
	local mouseRayEnd = modelCFrame:pointToObjectSpace(rayEnd)
	local mouseSlope = mouseRayEnd - mouseRayStart

	local xPositive = 1
	local yPositive = 1
	local zPositive = 1
	if mouseSlope.X &gt; 0 then xPositive = -1 end
	if mouseSlope.Y &gt; 0 then yPositive = -1 end
	if mouseSlope.Z &gt; 0 then zPositive = -1 end

	-- find which surface the transformed mouse ray hits (using modelSize):
	local xHitTime = calcRayHitTime(mouseRayStart.X, mouseSlope.X, modelSize.X/2 * xPositive)
	local yHitTime = calcRayHitTime(mouseRayStart.Y, mouseSlope.Y, modelSize.Y/2 * yPositive)
	local zHitTime = calcRayHitTime(mouseRayStart.Z, mouseSlope.Z, modelSize.Z/2 * zPositive)

	local hitFace = 0

	--if xHitTime &gt;= 0 and yHitTime &gt;= 0 and zHitTime &gt;= 0 then
	if xHitTime &gt; yHitTime then
		if xHitTime &gt; zHitTime then
			-- xFace is hit
			hitFace = 1*xPositive
		else
			-- zFace is hit
			hitFace = 3*zPositive
		end
	else
		if yHitTime &gt; zHitTime then
			-- yFace is hit
			hitFace = 2*yPositive
		else
			-- zFace is hit
			hitFace = 3*zPositive
		end
	end

	return hitFace
end


-- helper function for truncating to 45-degree angles on a 2D plane
function truncateToCircleEighth(bigValue, littleValue)
	local big = math.abs(bigValue)
	local little = math.abs(littleValue)
	local hypotenuse = math.sqrt(big*big + little*little)
	local frac = little / hypotenuse

	local bigSign = 1
	local littleSign = 1
	if bigValue &lt; 0 then bigSign = -1 end
	if littleValue &lt; 0 then littleSign = -1 end

	if frac &gt; .382683432 then
		-- between 22.5 and 45 degrees, so truncate to 45-degree tilt
		return .707106781 * hypotenuse * bigSign, .707106781 * hypotenuse * littleSign
	else 
		-- between 0 and 22.5 degrees, so truncate to 0-degree tilt
		return hypotenuse * bigSign, 0
	end
end

function onInsertMouseMove()

	if Data.Stamp.MovingLock then
		return
	end

	-- check to see if mouse is still active, and return otherwise!
	if not pcall(function () if Mouse and Mouse.Target and Mouse.Target.Parent:FindFirstChild("RobloxModel") == nil then return true else return false end end) then print("ERRORED OUT") game.JointsService:SetJoinAfterMoveTarget(nil) Mouse = nil return end

	if isRestricted and Mouse then
		Mouse.TargetFilter = game.Workspace.BaseplateBumpers
	end

	Data.Stamp.MovingLock = true
	if Data.Stamp.Dragger == nil then
		if Data.Stamp.Model ~= nil then
			if isRestricted then
				if checkPartLimit() then
					setupDraggableClone()
				else
					variables.ShowMaxedOut.Value = true
				end
			else
				setupDraggableClone()
			end
		end
	else
		-- REM TL: Data.Stamp.Dragger:MouseMove(Mouse.UnitRay)
		-- don't move with dragger - will move in one step on mouse down
		-- draw ghost at acceptable positions
		configFound, targetCFrame, targetSurface = findConfigAtMouseTarget(Data.Stamp.TransparencyTable)
		if configFound then

				if autoAlignToFace() and targetSurface ~= 1 and targetSurface ~= 4 then
				-- pre-rotate the flag or portrait so it's aligned correctly
				--local currCFrame
				--if Data.Stamp.CurrentParts[1]:IsA("Model") or Data.Stamp.CurrentParts[1]:IsA("Tool") then currCFrame = Data.Stamp.CurrentParts[1]:GetModelCFrame()
				--else currCFrame = Data.Stamp.CurrentParts[1].CFrame end

				local numRotations = 0 -- update this according to how many rotations you need to get it to target surface
				if targetSurface == 3 then numRotations = 0 - gInitial90DegreeRotations + autoAlignToFace()
				elseif targetSurface == 0 then numRotations = 2 - gInitial90DegreeRotations + autoAlignToFace()
				elseif targetSurface == 5 then numRotations = 3 - gInitial90DegreeRotations + autoAlignToFace()
				elseif targetSurface == 2 then numRotations = 1 - gInitial90DegreeRotations + autoAlignToFace() end
				

				local ry = math.pi/2
				local rotCF = CFrame.fromEulerAnglesXYZ(0, ry*numRotations, 0)
				gInitial90DegreeRotations = gInitial90DegreeRotations + numRotations
				if Data.Stamp.CurrentParts[1]:IsA("Model") or Data.Stamp.CurrentParts[1]:IsA("Tool") then
					for i, object in pairs(Data.Stamp.CurrentParts[1]:GetChildren()) do
						if object:IsA("Flag") then object = object.Handle end
						if object:IsA("Part") or object:IsA("TrussPart") or object:IsA("WedgePart") or object:IsA("CornerWedgePart") or object:IsA("Seat") or object:IsA("VehicleSeat") then
							object.CFrame = rotCF * object.CFrame
						end
					end
				else
					Data.Stamp.CurrentParts[1].CFrame = rotCF * Data.Stamp.CurrentParts[1].CFrame
				end
			end



			-- CODE TO CHECK FOR DRAGGING GHOST PART INTO A COLLIDING STATE
			local minBB, maxBB = getBoundingBoxInWorldCoordinates(Data.Stamp.CurrentParts[1])
	
			-- need to offset by distance to be dragged
			local currModelCFrame
			if Data.Stamp.CurrentParts[1]:IsA("Model") then
				-- we assume model has at least one part in it; need to find first part
				i = 1
				while i &lt; (#Data.Stamp.CurrentParts[1]:GetChildren()) and not Data.Stamp.CurrentParts[1]:GetChildren()[i]:IsA("BasePart") do
					i = i + 1
				end
				currModelCFrame = Data.Stamp.CurrentParts[1]:GetChildren()[i].CFrame
			else currModelCFrame = Data.Stamp.CurrentParts[1].CFrame end
			minBB = minBB + targetCFrame.p - currModelCFrame.p
			maxBB = maxBB + targetCFrame.p - currModelCFrame.p

			-- don't drag into terrain
			if clusterPartsInRegion(minBB+insertBoundingBoxOverlapVector, maxBB-insertBoundingBoxOverlapVector) then 
				if lastTargetCFrame then 
					positionPartsAtCFrame3(thingToDrag, lastTargetCFrame) 
					if (Data.Stamp.CurrentParts[1].Name == "MegaClusterCube") and (Data.Stamp.CurrentParts[1]:FindFirstChild("ClusterMaterial")) and (Data.Stamp.CurrentParts[1].ClusterMaterial:IsA("Vector3Value")) then 
						local clusterMat = Data.Stamp.CurrentParts[1].ClusterMaterial
						clusterMat.Value = Vector3.new(clusterMat.Value.X, clusterMat.Value.Y, lastTargetTerrainOrientation)
					end
				end
				Data.Stamp.MovingLock = false
				return 
			end
			
			local blockingParts = game.Workspace:FindPartsInRegion3(Region3.new(minBB+insertBoundingBoxOverlapVector, maxBB-insertBoundingBoxOverlapVector), currentSelection, 100)
			for b = 1, #blockingParts do
				-- put code back here if we want to prevent stamper from dragging ghost parts into other stamped models (once Region3 fix goes out)
			end

			positionPartsAtCFrame3(Data.Stamp.CurrentParts[1], targetCFrame)
			lastTargetCFrame = targetCFrame  -- successful positioning, so update 'dat cframe
			if (Data.Stamp.CurrentParts[1].Name == "MegaClusterCube") and (Data.Stamp.CurrentParts[1]:FindFirstChild("ClusterMaterial")) and (Data.Stamp.CurrentParts[1].ClusterMaterial:IsA("Vector3Value")) then lastTargetTerrainOrientation = Data.Stamp.CurrentParts[1].ClusterMaterial.Value.Z end


			-- auto break joints code
			if Mouse and Mouse.Target and Mouse.Target.Parent then
				local modelInfo = Mouse.Target:FindFirstChild("RobloxModel")
				if not modelInfo then modelInfo = Mouse.Target.Parent:FindFirstChild("RobloxModel") end
				
				local myModelInfo = Data.Stamp.CurrentParts[1]:FindFirstChild("UnstampableFaces")

				--if (modelInfo and modelInfo.Parent:FindFirstChild("UnstampableFaces")) or (modelInfo and myModelInfo) then  -- need better targetSurface calcs
				if (true) then
					local breakingFaces = ""
					local myBreakingFaces = ""
					if modelInfo and modelInfo.Parent:FindFirstChild("UnstampableFaces") then breakingFaces = modelInfo.Parent.UnstampableFaces.Value end
					if myModelInfo then myBreakingFaces = myModelInfo.Value end
					local hitFace = 0

					if modelInfo then hitFace = modelTargetSurface(modelInfo.Parent, game.Workspace.CurrentCamera.CoordinateFrame.p, Mouse.Hit.p) end

					-- are we stamping TO an unstampable surface?
					for bf in string.gmatch(breakingFaces, "[^,]+") do
						if hitFace == tonumber(bf) then
							-- return before we hit the JointsService code below!
							unstampableSurface = true
							game.JointsService:ClearJoinAfterMoveJoints() -- clear the JointsService cache
							Data.Stamp.MovingLock = false
							return
						end
					end

					-- now we have to cast the ray back in the other direction to find the surface we're stamping FROM
					hitFace = modelTargetSurface(Data.Stamp.CurrentParts[1], Mouse.Hit.p, game.Workspace.CurrentCamera.CoordinateFrame.p)

					-- are we stamping WITH an unstampable surface?
					for bf in string.gmatch(myBreakingFaces, "[^,]+") do
						if hitFace == tonumber(bf) then
							unstampableSurface = true
							game.JointsService:ClearJoinAfterMoveJoints() -- clear the JointsService cache
							Data.Stamp.MovingLock = false
							return
						end
					end

					-- just need to match breakingFace against targetSurface using rotation supplied by modelCFrame
					-- targetSurface: 1 is top, 4 is bottom, 
				end
			end

		end

		-- to show joints during the mouse move
		unstampableSurface = false
      game.JointsService:SetJoinAfterMoveInstance(Data.Stamp.CurrentParts[1])

		-- most common mouse inactive error occurs here, so check mouse active one more time in a pcall
		if not pcall(function () if Mouse and Mouse.Target and Mouse.Target.Parent:FindFirstChild("RobloxModel") == nil then return true else return false end end) then print("ERRORED OUT") game.JointsService:ClearJoinAfterMoveJoints() Mouse = nil Data.Stamp.MovingLock = false return end

      if Mouse and Mouse.Target and Mouse.Target.Parent:FindFirstChild("RobloxModel") == nil then
			game.JointsService:SetJoinAfterMoveTarget(Mouse.Target)
      else
			game.JointsService:SetJoinAfterMoveTarget(nil)
      end
      game.JointsService:ShowPermissibleJoints()

		-- here we allow for a line of high-scalability parts
		if (Data.Stamp.CurrentParts[1] and Data.Stamp.CurrentParts[1].Name == "MegaClusterCube") and HighScalabilityLine.Start then
			HighScalabilityLine.End = Data.Stamp.CurrentParts[1].CFrame.p

			local line
			local line2 = Vector3.new(0, 0, 0)
			local line3 = Vector3.new(0, 0, 0)

			if HighScalabilityLine.Dimensions == 1 then
				-- extract the line from these positions and limit to a 2D plane made from 2 of the world axes
				--   then use dominating axis to limit line to be at 45-degree intervals
				--   will use this internal representation of the line for the actual stamping
				line = (HighScalabilityLine.End - HighScalabilityLine.Start)

				if math.abs(line.X) &lt; math.abs(line.Y) then
					if math.abs(line.X) &lt; math.abs(line.Z) then
						-- limit to Y/Z plane, domination unknown
						local newY, newZ
						if (math.abs(line.Y) &gt; math.abs(line.Z)) then 
							newY, newZ = truncateToCircleEighth(line.Y, line.Z)
						else 
							newZ, newY = truncateToCircleEighth(line.Z, line.Y)
						end
						line = Vector3.new(0, newY, newZ)
					else
						-- limit to X/Y plane, with Y dominating
						local newY, newX = truncateToCircleEighth(line.Y, line.X)
						line = Vector3.new(newX, newY, 0)
					end
				else
					if math.abs(line.Y) &lt; math.abs(line.Z) then
						-- limit to X/Z plane, domination unknown
						local newX, newZ
						if math.abs(line.X) &gt; math.abs(line.Z) then
							newX, newZ = truncateToCircleEighth(line.X, line.Z)
						else
							newZ, newX = truncateToCircleEighth(line.Z, line.X)
						end
						line = Vector3.new(newX, 0, newZ)
					else 
						-- limit to X/Y plane, with X dominating
						local newX, newY = truncateToCircleEighth(line.X, line.Y)
						line = Vector3.new(newX, newY, 0)
					end
				end
				HighScalabilityLine.InternalLine = line

			elseif HighScalabilityLine.Dimensions == 2 then
				line = HighScalabilityLine.MoreLines[1]
				line2 = HighScalabilityLine.End - HighScalabilityLine.MorePoints[1]
		
				-- take out any component of line2 along line1, so you get perpendicular to line1 component
				line2 = line2 - line.unit*line.unit:Dot(line2)

				tempCFrame = CFrame.new(HighScalabilityLine.Start, HighScalabilityLine.Start + line)

				-- then zero out whichever is the smaller component
				local yAxis = tempCFrame:vectorToWorldSpace(Vector3.new(0, 1, 0))
				local xAxis = tempCFrame:vectorToWorldSpace(Vector3.new(1, 0, 0))
				
				local xComp = xAxis:Dot(line2)
				local yComp = yAxis:Dot(line2)

				if math.abs(yComp) &gt; math.abs(xComp) then
					line2 = line2 - xAxis*xComp
				else
					line2 = line2 - yAxis*yComp
				end

				HighScalabilityLine.InternalLine = line2
			elseif HighScalabilityLine.Dimensions == 3 then
				line = HighScalabilityLine.MoreLines[1]
				line2 = HighScalabilityLine.MoreLines[2]
				line3 = HighScalabilityLine.End - HighScalabilityLine.MorePoints[2]

				-- zero out all components of previous lines
				line3 = line3 - line.unit*line.unit:Dot(line3)
				line3 = line3 - line2.unit*line2.unit:Dot(line3)

				HighScalabilityLine.InternalLine = line3
			end

			-- resize the "line" graphic to be the correct size and orientation
			tempCFrame = CFrame.new(HighScalabilityLine.Start, HighScalabilityLine.Start + line)
			
			if HighScalabilityLine.Dimensions == 1 then  -- faster calculation for line
				HighScalabilityLine.AdornPart.Size = Vector3.new(4, 4, line.magnitude + 4)
				HighScalabilityLine.AdornPart.CFrame = tempCFrame + tempCFrame:vectorToWorldSpace(Vector3.new(2, 2, 2) - HighScalabilityLine.AdornPart.Size/2)
			else
				local boxSize = tempCFrame:vectorToObjectSpace(line + line2 + line3)
				HighScalabilityLine.AdornPart.Size = Vector3.new(4, 4, 4) + Vector3.new(math.abs(boxSize.X), math.abs(boxSize.Y), math.abs(boxSize.Z))
				HighScalabilityLine.AdornPart.CFrame = tempCFrame + tempCFrame:vectorToWorldSpace(boxSize/2)
			end

			-- make player able to see this ish
			if player then HighScalabilityLine.Adorn.Parent = player.PlayerGui end
			if HighScalabilityLine.NewHint then 
				if HighScalabilityLine.Dimensions == 1 and line and (line.magnitude &gt; 4) then hint("Press C to stamp in 2D") HighScalabilityLine.NewHint = false  
				elseif HighScalabilityLine.Dimensions == 2 and line2 and (line2.magnitude &gt; 4) then hint("Press C again to stamp in 3D") HighScalabilityLine.NewHint = false 
				elseif HighScalabilityLine.Dimensions == 3 then HighScalabilityLine.NewHint = false end  -- if we do cyclic, then let them know they're going back to line stamping
			end
		end
	end

	Data.Stamp.MovingLock = false

end


function onInsertMouseButton1Down()

	if Data.Stamp.Dragger or Data.Stamp.Decal then
		Data.Stamp.MouseDown = true
	end

	if (Data.Stamp.CurrentParts and Data.Stamp.CurrentParts[1] and Data.Stamp.CurrentParts[1].Name == "MegaClusterCube") and not eyeDropperConnection then
			-- only let them drag if they start dragging on the cluster!
			if Mouse and Mouse.Target and Mouse.Target:IsA("Terrain") then
				HighScalabilityLine.Dimensions = 1
				HighScalabilityLine.Start = Data.Stamp.CurrentParts[1].CFrame.p
			end
	end
end


function cancelAssetPlacement()
	HighScalabilityLine.Start = nil
	HighScalabilityLine.Adorn.Parent = nil

	gInitial90DegreeRotations = 0
	Data.Stamp.Cancelled = true

	if Data.Stamp["Model"] then
		Data.Stamp.Model.Parent = nil
	end

	if Data.Stamp.CurrentParts then
		for index, object in pairs(Data.Stamp.CurrentParts) do
			object.Parent = nil
		end
	
		Data.Stamp.CurrentParts.Parent = nil
	end

	if Data.Stamp.DecalSelection then
		Data.Stamp.DecalSelection:Remove()
		Data.Stamp.DecalSelection = nil
	end
	if Data.Stamp.Decal then
		Data.Stamp.Decal:Remove()
		Data.Stamp.Decal = nil
	end

	if Mouse then
		Mouse.Icon = "http://www.roblox.com/asset?id=66887745"
	end
	game.JointsService:ClearJoinAfterMoveJoints()

end


function collectParts(object, baseParts, scripts, decals)

	if object:IsA("BasePart") then
		baseParts[#baseParts+1] = object
	elseif object:IsA("Script") then
		scripts[#scripts+1] = object
	elseif object:IsA("Decal") then
		decals[#decals+1] = object
	end

	for index,child in pairs(object:GetChildren()) do
		collectParts(child, baseParts, scripts, decals)
	end

end

function getTargetPartBoundingBox(targetPart)

	if targetPart.Parent:FindFirstChild("RobloxModel") ~= nil then
		return getBoundingBox2(targetPart.Parent)
	else
		return getBoundingBox2(targetPart)
	end

end


function getBoundingBox2(partOrModel)

-- for models, the bounding box is defined as the minimum and maximum individual part bounding boxes
-- relative to the first part's coordinate frame.

	local minVec = Vector3.new(math.huge, math.huge, math.huge)
	local maxVec = Vector3.new(-math.huge, -math.huge, -math.huge)

	if partOrModel:IsA("Part") or partOrModel:IsA("WedgePart") or partOrModel:IsA("CornerWedgePart") or partOrModel:IsA("TrussPart")then
		minVec = -0.5 * partOrModel.Size
		maxVec = -minVec
	elseif partOrModel:IsA("Terrain") then
		minVec = Vector3.new(-2, -2, -2)
		maxVec = Vector3.new(2, 2, 2)
	else
		local part1 = partOrModel:GetChildren()[1]
		if partOrModel:IsA("Tool") then part1 = partOrModel.Handle if not part1 then return end end
		if part1:IsA("Flag") then part1 = partOrModel:FindFirstChild("Part") if not part1 then return end end
		for i, object in pairs(partOrModel:GetChildren()) do
			if (object:IsA("Part") or object:IsA("WedgePart") or object:IsA("CornerWedgePart") or object:IsA("TrussPart")) then
				boxMinInWorld = object.CFrame:pointToWorldSpace(-0.5 * object.Size)
				boxMinInPart1 = part1.CFrame:pointToObjectSpace(boxMinInWorld)
				boxMaxInWorld = object.CFrame:pointToWorldSpace(0.5 * object.Size)
				boxMaxInPart1 = part1.CFrame:pointToObjectSpace(boxMaxInWorld)

				local minX = minVec.x
				local minY = minVec.y
				local minZ = minVec.z
				local maxX = maxVec.x
				local maxY = maxVec.y
				local maxZ = maxVec.z
				if boxMinInPart1.x &lt; minVec.x then
					minX = boxMinInPart1.x
				end
				if boxMinInPart1.y &lt; minVec.y then
					minY = boxMinInPart1.y
				end
				if boxMinInPart1.z &lt; minVec.z then
					minZ = boxMinInPart1.z
				end
				if boxMaxInPart1.x &lt; minX then
					minX = boxMaxInPart1.x
				end
				if boxMaxInPart1.y &lt; minY then
					minY = boxMaxInPart1.y
				end
				if boxMaxInPart1.z &lt; minZ then
					minZ = boxMaxInPart1.z
				end

				if boxMinInPart1.x &gt; maxVec.x then
					maxX = boxMinInPart1.x
				end
				if boxMinInPart1.y &gt; maxVec.y then
					maxY = boxMinInPart1.y
				end
				if boxMinInPart1.z &gt; maxVec.z then
					maxZ = boxMinInPart1.z
				end
				if boxMaxInPart1.x &gt; maxX then
					maxX = boxMaxInPart1.x
				end
				if boxMaxInPart1.y &gt; maxY then
					maxY = boxMaxInPart1.y
				end
				if boxMaxInPart1.z &gt; maxZ then
					maxZ = boxMaxInPart1.z
				end

				minVec = Vector3.new(minX, minY, minZ)
				maxVec = Vector3.new(maxX, maxY, maxZ)
			end
		end
	end

	-- Adjust bounding box to reflect what the model or part author wants in  terms of justification
	local justifyValue = partOrModel:FindFirstChild("Justification")
	if justifyValue ~= nil then
		-- find the multiple of 4 that contains the model
		justify = justifyValue.Value
		two = Vector3.new(2, 2, 2)
		actualBox = maxVec - minVec - Vector3.new(0.01, 0.01, 0.01)
		containingGridBox = Vector3.new(4 * math.ceil(actualBox.x/4), 4 * math.ceil(actualBox.y/4), 4 * math.ceil(actualBox.z/4))
		adjustment = containingGridBox - actualBox
		minVec = minVec - 0.5 * adjustment * justify
		maxVec = maxVec + 0.5 * adjustment * (two - justify)
	end

	return minVec, maxVec

end


function getBoundingBoxInWorldCoordinates(partOrModel)
	local minVec = Vector3.new(math.huge, math.huge, math.huge)
	local maxVec = Vector3.new(-math.huge, -math.huge, -math.huge)

	if partOrModel:IsA("BasePart")then
		vec1 = partOrModel.CFrame:pointToWorldSpace(-0.5 * partOrModel.Size)
		vec2 = partOrModel.CFrame:pointToWorldSpace(0.5 * partOrModel.Size)
		minVec = Vector3.new(math.min(vec1.X, vec2.X), math.min(vec1.Y, vec2.Y), math.min(vec1.Z, vec2.Z))
		maxVec = Vector3.new(math.max(vec1.X, vec2.X), math.max(vec1.Y, vec2.Y), math.max(vec1.Z, vec2.Z))
	elseif partOrModel:IsA("Terrain") then
		-- we shouldn't have to deal with this case
		--minVec = Vector3.new(-2, -2, -2)
		--maxVec = Vector3.new(2, 2, 2)
	else
		local part1 = partOrModel:GetChildren()[1]
		for i, object in pairs(partOrModel:GetChildren()) do
			if object:IsA("BasePart") then
				boxMinInWorld = object.CFrame:pointToWorldSpace(-0.5 * object.Size)
				boxMaxInWorld = object.CFrame:pointToWorldSpace(0.5 * object.Size)

				local minX = minVec.x
				local minY = minVec.y
				local minZ = minVec.z
				local maxX = maxVec.x
				local maxY = maxVec.y
				local maxZ = maxVec.z
				if boxMinInWorld.x &lt; minX then
					minX = boxMinInWorld.x
				end
				if boxMinInWorld.y &lt; minY then
					minY = boxMinInWorld.y
				end
				if boxMinInWorld.z &lt; minZ then
					minZ = boxMinInWorld.z
				end
				if boxMaxInWorld.x &lt; minX then
					minX = boxMaxInWorld.x
				end
				if boxMaxInWorld.y &lt; minY then
					minY = boxMaxInWorld.y
				end
				if boxMaxInWorld.z &lt; minZ then
					minZ = boxMaxInWorld.z
				end

				if boxMinInWorld.x &gt; maxX then
					maxX = boxMinInWorld.x
				end
				if boxMinInWorld.y &gt; maxY then
					maxY = boxMinInWorld.y
				end
				if boxMinInWorld.z &gt; maxZ then
					maxZ = boxMinInWorld.z
				end
				if boxMaxInWorld.x &gt; maxX then
					maxX = boxMaxInWorld.x
				end
				if boxMaxInWorld.y &gt; maxY then
					maxY = boxMaxInWorld.y
				end
				if boxMaxInWorld.z &gt; maxZ then
					maxZ = boxMaxInWorld.z
				end

				minVec = Vector3.new(minX, minY, minZ)
				maxVec = Vector3.new(maxX, maxY, maxZ)
			end
		end
	end

	return minVec, maxVec
end


function getClosestAlignedWorldDirection(aVector3InWorld)

	local xDir = Vector3.new(1,0,0)
	local yDir = Vector3.new(0,1,0)
	local zDir = Vector3.new(0,0,1)
	local xDot = aVector3InWorld.x * xDir.x + aVector3InWorld.y * xDir.y + aVector3InWorld.z * xDir.z
	local yDot = aVector3InWorld.x * yDir.x + aVector3InWorld.y * yDir.y + aVector3InWorld.z * yDir.z
	local zDot = aVector3InWorld.x * zDir.x + aVector3InWorld.y * zDir.y + aVector3InWorld.z * zDir.z

	if math.abs(xDot) &gt; math.abs(yDot) and math.abs(xDot) &gt; math.abs(zDot) then
		if xDot &gt; 0 then
			return 0
		else
			return 3
		end
	elseif math.abs(yDot) &gt; math.abs(xDot) and math.abs(yDot) &gt; math.abs(zDot) then
		if yDot &gt; 0 then
			return 1
		else
			return 4
		end
	else
		if zDot &gt; 0 then
			return 2
		else
			return 5
		end
	end 

end


function getMouseTargetCFrame(targetPart)

	if targetPart.Parent:FindFirstChild("RobloxModel") ~= nil then
		if targetPart.Parent:IsA("Tool") then return targetPart.Parent.Handle.CFrame
		else return targetPart.Parent:GetChildren()[1].CFrame end
	else
		return targetPart.CFrame
	end

end


function surfaceToVector(surf)
	local vect = 1
	if surf &lt; 0 then
		surf = surf * -1
		vect = vect * -1
	end
	if surf == 1 then return vect*Vector3.new(1, 0, 0)
	elseif surf == 2 then return vect*Vector3.new(0, 1, 0)
	elseif surf == 3 then return vect*Vector3.new(0, 0, 1)
	elseif Mouse then return Vector3.FromNormalId(Mouse.TargetSurface) end  -- if we somehow got a "0", then we just revert to old behavior
	return Vector3.new(0,0,0)
end

function findConfigAtMouseTarget(partsTable)

-- *Critical Assumption* :
--				This function assumes the target CF axes are orthogonal with the target bounding box faces
--				And, it assumes the insert CF axes are orthongonal with the insert bounding box faces
--				Therefore, insertion will not work with angled faces on wedges or other "non-block" parts, nor
--				will it work for parts in a model that are not orthogonally aligned with the model's CF.

	local grid = 4.0
	local admissibleConfig = false
	local targetConfig = CFrame.new(0,0,0)

	local minBB, maxBB = getBoundingBox2(Data.Stamp.CurrentParts[1])
	local diagBB = maxBB - minBB

	local insertCFrame
	if Data.Stamp.CurrentParts[1]:IsA("Model") or Data.Stamp.CurrentParts[1]:IsA("Tool") then
		i = 1
		while (i &lt; (#Data.Stamp.CurrentParts[1]:GetChildren()) and not Data.Stamp.CurrentParts[1]:GetChildren()[i]:IsA("Part") and not Data.Stamp.CurrentParts[1]:GetChildren()[i]:IsA("TrussPart") and not Data.Stamp.CurrentParts[1]:GetChildren()[i]:IsA("WedgePart") and not Data.Stamp.CurrentParts[1]:GetChildren()[i]:IsA("CornerWedgePart")) do
			i = i + 1
		end
		insertCFrame = Data.Stamp.CurrentParts[1]:GetChildren()[i].CFrame
	else
		insertCFrame = Data.Stamp.CurrentParts[1].CFrame
	end

	if not isRestricted and Mouse then
		if Data.Stamp.CurrentParts[1]:IsA("Tool") then Mouse.TargetFilter = Data.Stamp.CurrentParts[1].Handle
		else Mouse.TargetFilter = Data.Stamp.CurrentParts[1] end
	end

	local targetPart = nil
	local success = pcall(function() targetPart = Mouse.Target end)

	if not success or targetPart == nil then
		return admissibleConfig, targetConfig
	end

	-- test mouse hit location
	local minBBTarget, maxBBTarget = getTargetPartBoundingBox(targetPart)
	local diagBBTarget = maxBBTarget - minBBTarget
	local targetCFrame = getMouseTargetCFrame(targetPart)
	local hitCFrame = CFrame.new(0,0,0)
	if Mouse then
		hitCFrame = Mouse.Hit
	end
	local mouseHitInWorld = hitCFrame.p

	-- find which axis of the insertion objects should match with the target surface
	-- this should use targetPart CFrame, not the model CFrame

	--[[ attempt at fixing Mouse.TargetSurface below...
	local targetModel = targetPart
	if not targetPart:FindFirstChild("RobloxModel") and targetPart.Parent and targetPart.Parent:FindFirstChild("RobloxModel") then targetModel = targetPart.Parent end
	local correctedTargetSurfaceVector = surfaceToVector(modelTargetSurface(targetModel, game.Workspace.CurrentCamera.CoordinateFrame.p, mouseHitInWorld))
	local targetVectorInWorld = targetPart.CFrame:vectorToWorldSpace(correctedTargetSurfaceVector)
	--]]

	if targetPart:IsA("Terrain") then
		if not cluster then cluster = game.Workspace.Terrain end

		cellID = cluster:WorldToCellPreferSolid(mouseHitInWorld)
		targetCFrame = CFrame.new(cluster:CellCenterToWorld(cellID.x, cellID.y, cellID.z))
	end
	
	local mouseHitInTarget = targetCFrame:pointToObjectSpace(mouseHitInWorld)
	local targetVectorInWorld = Vector3.new(0,0,0)
	if Mouse then
		targetVectorInWorld = targetCFrame:vectorToWorldSpace(Vector3.FromNormalId(Mouse.TargetSurface))
	end


	local targetRefPointInTarget
	local clampToSurface

	if getClosestAlignedWorldDirection(targetVectorInWorld) == 0 then
		targetRefPointInTarget = targetCFrame:vectorToObjectSpace(Vector3.new(1, -1, 1))
		insertRefPointInInsert = insertCFrame:vectorToObjectSpace(Vector3.new(-1, -1, 1))
		clampToSurface = Vector3.new(0,1,1)
	elseif getClosestAlignedWorldDirection(targetVectorInWorld) == 3 then
		targetRefPointInTarget = targetCFrame:vectorToObjectSpace(Vector3.new(-1, -1, -1))
		insertRefPointInInsert = insertCFrame:vectorToObjectSpace(Vector3.new(1, -1, -1))
		clampToSurface = Vector3.new(0,1,1)
	elseif getClosestAlignedWorldDirection(targetVectorInWorld) == 1 then
		targetRefPointInTarget = targetCFrame:vectorToObjectSpace(Vector3.new(-1, 1, 1))
		insertRefPointInInsert = insertCFrame:vectorToObjectSpace(Vector3.new(-1, -1, 1))
		clampToSurface = Vector3.new(1,0,1)		
	elseif getClosestAlignedWorldDirection(targetVectorInWorld) == 4 then
		targetRefPointInTarget = targetCFrame:vectorToObjectSpace(Vector3.new(-1, -1, 1))
		insertRefPointInInsert = insertCFrame:vectorToObjectSpace(Vector3.new(-1, 1, 1))
		clampToSurface = Vector3.new(1,0,1)
	elseif getClosestAlignedWorldDirection(targetVectorInWorld) == 2 then
		targetRefPointInTarget = targetCFrame:vectorToObjectSpace(Vector3.new(-1, -1, 1))
		insertRefPointInInsert = insertCFrame:vectorToObjectSpace(Vector3.new(-1, -1, -1))
		clampToSurface = Vector3.new(1,1,0)
	else
		targetRefPointInTarget = targetCFrame:vectorToObjectSpace(Vector3.new(1, -1, -1))
		insertRefPointInInsert = insertCFrame:vectorToObjectSpace(Vector3.new(1, -1, 1))
		clampToSurface = Vector3.new(1,1,0)
	end

	targetRefPointInTarget = targetRefPointInTarget * (0.5 * diagBBTarget) + 0.5 * (maxBBTarget + minBBTarget)
	insertRefPointInInsert = insertRefPointInInsert * (0.5 * diagBB) + 0.5 * (maxBB + minBB)
	
	-- To Do: For cases that are not aligned to the world grid, account for the minimal rotation
	-- needed to bring the Insert part(s) into alignment with the Target Part
	-- Apply the rotation here

	local delta = mouseHitInTarget - targetRefPointInTarget
	local deltaClamped = Vector3.new(grid * math.modf(delta.x/grid), grid * math.modf(delta.y/grid), grid * math.modf(delta.z/grid))
	deltaClamped = deltaClamped * clampToSurface
	local targetTouchInTarget = deltaClamped + targetRefPointInTarget

	local TargetTouchRelToWorld = targetCFrame:pointToWorldSpace(targetTouchInTarget)
	local InsertTouchInWorld = insertCFrame:vectorToWorldSpace(insertRefPointInInsert)
	local posInsertOriginInWorld = TargetTouchRelToWorld - InsertTouchInWorld

	local x, y, z, R00, R01, R02, R10, R11, R12, R20, R21, R22 = insertCFrame:components()
	targetConfig = CFrame.new(posInsertOriginInWorld.x, posInsertOriginInWorld.y, posInsertOriginInWorld.z, R00, R01, R02, R10, R11, R12, R20, R21, R22)
	admissibleConfig = true

	return admissibleConfig, targetConfig, getClosestAlignedWorldDirection(targetVectorInWorld)

end

function checkPartLimit()

	local numPoints = player.PointsUsed.Value
	local maxPoints = player.MaxPoints.Value

	if numPoints &lt; maxPoints then
		return true
	else
		return false
	end

	return true
end

function setupDraggableClone()
	if eyeDropperConnection then eyeDropperConnection:disconnect() eyeDropperConnection = nil end

	--if not Mouse.Target then return end
	click.Value = false

	if Data.Stamp.CurrentParts then
		for i = 1, #Data.Stamp.CurrentParts do
			if Data.Stamp.CurrentParts[i].Parent ~= nil then
				Data.Stamp.CurrentParts[i].Parent = partModel
			end
		end
	end
	
	if Data.Stamp["Model"] == nil then return end

	local clone = Data.Stamp.Model:Clone()
	local scripts = {}
	local parts = {}
	local decals = {}
	
	collectParts(clone, parts, scripts, decals)

	if #parts &gt; 0 then
		Data.Stamp.DisabledScripts = {}
		Data.Stamp.TransparencyTable = {}
		Data.Stamp.MaterialTable = {}
		Data.Stamp.CanCollideTable = {}
		Data.Stamp.AnchoredTable = {}
		Data.Stamp.DecalTransparencyTable = {}

		for index,script in pairs(scripts) do
			if not(script.Disabled) then
				script.Disabled = true
				Data.Stamp.DisabledScripts[#Data.Stamp.DisabledScripts +1] = script
			end
		end
		for index, part in pairs(parts) do
			Data.Stamp.TransparencyTable[part] = part.Transparency
			part.Transparency = gStaticTrans + (1-gStaticTrans)*part.Transparency
			Data.Stamp.MaterialTable[part] = part.Material
			part.Material = Enum.Material.Plastic
			Data.Stamp.CanCollideTable[part] = part.CanCollide
			part.CanCollide = false
			Data.Stamp.AnchoredTable[part] = part.Anchored
			part.Anchored = true
			part.archivable = false

			delay(0,function()
				local con = nil
				local exitLoop = false
				con = click.Changed:connect(function()
					if click.Value then
						con:disconnect()
						exitLoop = true
					end
				end)
				wait(fadeInDelayTime) -- give it some time to be completely transparent

				if exitLoop then return end -- if we already stamped, we don't need to do the rest of this
				
				local begTime = tick()
				local currTime = begTime
				while (currTime - begTime) &lt; transFadeInTime and part and part:IsA("BasePart") and part.Transparency &gt; gDesiredTrans and not exitLoop do
					local newTrans = 1 - (((currTime - begTime)/transFadeInTime) * (gStaticTrans - gDesiredTrans))
					if Data.Stamp.TransparencyTable[part] then part.Transparency = newTrans + (1-newTrans) * Data.Stamp.TransparencyTable[part] end
					wait(0.03)
					currTime = tick()
				end
				if part and part:IsA("BasePart") and not exitLoop then
					if Data.Stamp.TransparencyTable[part] then part.Transparency = gDesiredTrans + (1-gDesiredTrans)*Data.Stamp.TransparencyTable[part] end
				end
				if con then con:disconnect() end
			end)
		end

		for index, decal in pairs(decals) do
			Data.Stamp.DecalTransparencyTable[decal] = decal.Transparency
			decal.Transparency = gDesiredTrans + (1-gDesiredTrans)*decal.Transparency
		end
		
		clone.Parent = game.Workspace

		-- For Restricting Stamper Tool
		if(isRestricted) then

			-- mark a particular spot in BaseplateBumpers, so we can remove any stragglers later, when player leaves
			local cloneInsertionSpot = game.Workspace.BaseplateBumpers:FindFirstChild(player.Name)
			if cloneInsertionSpot == nil then
				cloneInsertionSpot = Instance.new("Model")
				cloneInsertionSpot.Name = player.Name
				cloneInsertionSpot.Parent = game.Workspace.BaseplateBumpers
			end

			clone.Parent = cloneInsertionSpot
		end

		-- disable all seats
		setSeatEnabledStatus(clone, true)
		setSeatEnabledStatus(clone, false)

		Data.Stamp.CurrentParts = clone:GetChildren()

		-- if auto-alignable, we enforce a pre-rotation to the canonical "0-frame"
		if autoAlignToFace() then
			if Data.Stamp.CurrentParts[1].PrimaryPart then modelInverse = Data.Stamp.CurrentParts[1].PrimaryPart.CFrame:inverse()
			else modelInverse = Data.Stamp.CurrentParts[1]:GetModelCFrame():inverse() end
			for i, object in pairs(Data.Stamp.CurrentParts[1]:GetChildren()) do
				if object:IsA("Flag") then object = object.Handle end
				if object:IsA("Part") or object:IsA("TrussPart") or object:IsA("WedgePart") or object:IsA("CornerWedgePart") or object:IsA("Seat") or object:IsA("VehicleSeat") then object.CFrame = modelInverse*object.CFrame end
			end
			gInitial90DegreeRotations = 0
		else

		-- pre-rotate if necessary
		local ry = gInitial90DegreeRotations * math.pi/2
		local rotCF = CFrame.fromEulerAnglesXYZ(0, ry, 0) 
		if Data.Stamp.CurrentParts[1]:IsA("Model") or Data.Stamp.CurrentParts[1]:IsA("Tool") then
			for i, object in pairs(Data.Stamp.CurrentParts[1]:GetChildren()) do
				if object:IsA("Flag") then object = object.Handle end
				if object:IsA("Part") or object:IsA("TrussPart") or object:IsA("WedgePart") or object:IsA("CornerWedgePart") or object:IsA("Seat") or object:IsA("VehicleSeat") then object.CFrame = rotCF * object.CFrame end
			end
		else
			Data.Stamp.CurrentParts[1].CFrame = rotCF * Data.Stamp.CurrentParts[1].CFrame
		end
		end

		-- After rotating, update the position
		configFound, targetCFrame = findConfigAtMouseTarget(Data.Stamp.TransparencyTable)
		if configFound then
			positionPartsAtCFrame3(Data.Stamp.TransparencyTable, targetCFrame)
		end
		-- to show joints during the mouse move
      game.JointsService:SetJoinAfterMoveInstance(Data.Stamp.CurrentParts[1])

		local mouseTarget = nil
		pcall(function() mouseTarget = Mouse.Target end)

      if mouseTarget and mouseTarget.Parent:FindFirstChild("RobloxModel") == nil then
			game.JointsService:SetJoinAfterMoveTarget(mouseTarget)
      else
			game.JointsService:SetJoinAfterMoveTarget(nil)
		end
      game.JointsService:ShowPermissibleJoints()

		for index, object in pairs(Data.Stamp.CurrentParts) do
			object.Parent = clone.Parent
		end

		clone:Remove()

		lastTargetCFrame = nil

	
		if billBoardOwnerGui then
			if #parts == 1 then
				billBoardOwnerGui.Parent = parts[1]
			else
				billBoardOwnerGui.Parent = parts[1].Parent
			end
		end

		HighScalabilityLine.NewHint = true -- show hint if they start dragging a high-scalability part

		Data.Stamp.Dragger = Instance.new("Dragger")
		--Begin a movement by faking a MouseDown signal
		Data.Stamp.Dragger:MouseDown(parts[1], Vector3.new(0,0,0), parts)
		Data.Stamp.Dragger:MouseUp()
	else
		--Nothing draggable in the Model
		Data.Stamp.Model:Remove()
		Data.Stamp.Model = nil
		Data.Stamp.TransparencyTable = nil
		Data.Stamp.MaterialTable = nil
		Data.Stamp.CanCollideTable = nil
		Data.Stamp.AnchoredTable = nil
		Data.Stamp.DisabledScripts = nil
	end

end


function noManualWelds(part)
	local partChildren = part:GetChildren()
	for i = 1, #partChildren do
		if partChildren[i]:IsA("ManualWeld") or partChildren[i]:IsA("Rotate") then
			return false
		end
	end
	return true
end

local debris = game:GetService("Debris")
function flashRedBox()
	errorBox.Parent = player.PlayerGui
	if Data.Stamp.CurrentParts[1]:IsA("Tool") then errorBox.Adornee = Data.Stamp.CurrentParts[1].Handle
	else errorBox.Adornee = Data.Stamp.CurrentParts[1] end

	delay(0,function()
		for i = 1, 3 do
			errorBox.Visible = true
			wait(0.13)
			errorBox.Visible = false
			wait(0.13)
		end
		errorBox.Adornee = nil
		errorBox.Parent = Tool
	end)
end


-- below function should work as a Region3 query, returning true if a single cluster part is within this region
function clusterPartsInRegion(startVector, endVector)

	if not cluster then return false end

	local startCell = cluster:WorldToCell(startVector)
	local endCell = cluster:WorldToCell(endVector)

	local startX = startCell.X
	local startY = startCell.Y
	local startZ = startCell.Z

	local endX = endCell.X
	local endY = endCell.Y
	local endZ = endCell.Z

	if startX &lt; cluster.MaxExtents.Min.X then startX = cluster.MaxExtents.Min.X end
	if startY &lt; cluster.MaxExtents.Min.Y then startY = cluster.MaxExtents.Min.Y end
	if startZ &lt; cluster.MaxExtents.Min.Z then startZ = cluster.MaxExtents.Min.Z end

	if endX &gt; cluster.MaxExtents.Max.X then endX = cluster.MaxExtents.Max.X end
	if endY &gt; cluster.MaxExtents.Max.Y then endY = cluster.MaxExtents.Max.Y end
	if endZ &gt; cluster.MaxExtents.Max.Z then endZ = cluster.MaxExtents.Max.Z end

	for x = startX, endX do
		for y = startY, endY do
			for z = startZ, endZ do
				if (cluster:GetCell(x, y, z).Value) &gt; 0 then return true end
			end
		end
	end

	return false
end

-- helper function to determine if a character can be pushed upwards by a certain amount
-- character is 5 studs tall, we'll check a 1.5 x 1.5 x 4.5 box around char, with center .5 studs below torsocenter
function spaceAboveCharacter(charTorso, newTorsoY)
	local partsAboveChar = game.Workspace:FindPartsInRegion3(Region3.new(Vector3.new(charTorso.Position.X, newTorsoY, charTorso.Position.Z) - Vector3.new(.75, 2.75, .75), Vector3.new(charTorso.Position.X, newTorsoY, charTorso.Position.Z) + Vector3.new(.75, 1.75, .75)), charTorso.Parent, 100)
	for j = 1, #partsAboveChar do
		if partsAboveChar[j].CanCollide and not partsAboveChar[j]:IsDescendantOf(Data.Stamp.CurrentParts[1]) then return false end
	end

	if clusterPartsInRegion(Vector3.new(charTorso.Position.X, newTorsoY, charTorso.Position.Z) - Vector3.new(.75, 2.75, .75), Vector3.new(charTorso.Position.X, newTorsoY, charTorso.Position.Z) + Vector3.new(.75, 1.75, .75)) then return false end

	return true
end


-- returns whether or not we want to cancel the stamp because we're blocked by this part
function isBlocker(part)
	if not part then return false end
	if not part.Parent then return false end
	if part:FindFirstChild("Humanoid") then return false end
	if part:FindFirstChild("RobloxStamper") or part:FindFirstChild("RobloxModel") then return true end
	if part:IsA("Part") and not part.CanCollide then return false end
	if part == game.Workspace then return true end
	if part == game.Lighting then return false end
	return isBlocker(part.Parent)
end

function onInsertMouseButton1Up()
	if guiScriptIsLoadingSomething or variables.InsertAsset.Updated.Value then return end -- don't try to stamp while we're loading!

	if eyeDropperConnection then 
		eyeDropperConnection:disconnect()
		eyeDropperConnection = nil
		return
	end

	if Data.Stamp.MouseDown then
		Data.Stamp.MouseDown = false
		if Data.Stamp.Dragger then

			--Place the object where the mouse is currently positioned
			-- For Restricting Stamper Tool

			while Data.Stamp.MouseLock do wait() end
			onInsertMouseMove()
			Data.Stamp.MouseLock = true

			if(isRestricted) then
				-- if player tries to stamp out of bounds, tell them they can't
				if not inBounds(Data.Stamp.TransparencyTable) then
					variables.ShowInvalidPlacement.Value = true
					Data.Stamp.MouseLock = false
					HighScalabilityLine.Start = nil
					HighScalabilityLine.Adorn.Parent = nil
					return
				end
			end

			-- if unstampable face, then don't let us stamp there!
			if unstampableSurface then
				Data.Stamp.MouseLock = false
				HighScalabilityLine.Start = nil
				HighScalabilityLine.Adorn.Parent = nil
				flashRedBox()
				return
			end

			-- Prevent part from being stamped on top of a player

			local minBB, maxBB = getBoundingBoxInWorldCoordinates(Data.Stamp.CurrentParts[1])
			local configFound, targetCFrame = findConfigAtMouseTarget(Data.Stamp.TransparencyTable)

			if configFound and not HighScalabilityLine.Adorn.Parent then
				if clusterPartsInRegion(minBB+insertBoundingBoxOverlapVector, maxBB-insertBoundingBoxOverlapVector) then Data.Stamp.MouseLock = false flashRedBox() return end

				local blockingParts = game.Workspace:FindPartsInRegion3(Region3.new(minBB+insertBoundingBoxOverlapVector, maxBB-insertBoundingBoxOverlapVector), Data.Stamp.CurrentParts[1], 100)
				for b = 1, #blockingParts do
					-- below if we only want to block stamping on self
					--if blockingParts[b].Parent == script.Parent.Parent then return end
					
					-- below if we want to block stamping on self and also stamping that intersects a model we've previously stamped on our baseplate
					--		  should work as soon as Region3 queries are fixed
					--      NOTE TO SELF:  See if partModel applies when isRestricted is false
					--if blockingParts[b]:IsDescendantOf(partModel) or blockingParts[b].Parent == script.Parent.Parent then Data.Stamp.MouseLock = false flashRedBox() break end --return end
					if isBlocker(blockingParts[b]) then Data.Stamp.MouseLock = false flashRedBox() return end-- still error if overlapping another model [should return here too!]
				end

				local alreadyPushedUp = {}
				-- if no blocking model below, then see if stamping on top of a character
				for b = 1, #blockingParts do
					--if blockingParts[b].Parent == script.Parent.Parent then
--						local blockingPersonTorso = script.Parent.Parent:FindFirstChild("Torso")
						if blockingParts[b].Parent and not alreadyPushedUp[blockingParts[b].Parent] and blockingParts[b].Parent:FindFirstChild("Humanoid") and blockingParts[b].Parent:FindFirstChild("Humanoid"):IsA("Humanoid") then
						local blockingPersonTorso = blockingParts[b].Parent:FindFirstChild("Torso")
						alreadyPushedUp[blockingParts[b].Parent] = true

						if blockingPersonTorso then
							-- if so, let's push the person upwards so they pop on top of the stamped model/part (but only if there's space above them)
							local newY = maxBB.Y + 3
							if spaceAboveCharacter(blockingPersonTorso, newY) then
								blockingPersonTorso.CFrame = blockingPersonTorso.CFrame + Vector3.new(0, newY - blockingPersonTorso.CFrame.p.Y, 0)
							else
								-- if no space, we just error
								Data.Stamp.MouseLock = false
								flashRedBox()
								return
								-- should return here too!
							end
						end
						
						--break
					end
				end
			elseif (not configFound) then
				HighScalabilityLine.Start = nil
				HighScalabilityLine.Adorn.Parent = nil
				Data.Stamp.MouseLock = false 
				return 
			end -- if no config then don't stamp!

			-- something will be stamped!  so set the "StampedSomething" toggle to true
			local localChar = game.Players.LocalPlayer.Character
			if localChar then
				local stampTracker = localChar:FindFirstChild("StampTracker")
				if stampTracker and not stampTracker.Value then stampTracker.Value = true end
			end

			-- also, show hints again if high scalability part
			HighScalabilityLine.NewHint = true

			if Data.Stamp.Model and Data.Stamp.Model:GetChildren()[1] and Data.Stamp.Model:GetChildren()[1].Name == "MegaClusterCube" then
					local line = HighScalabilityLine.InternalLine
					local cMax = game.Workspace.Terrain.MaxExtents.Max
					local cMin = game.Workspace.Terrain.MaxExtents.Min

					local clusterMaterial = 1 -- default is grass
					local clusterType = 0 -- default is brick
					local clusterOrientation = 0 -- default is 0 rotation

					local autoWedgeClusterParts = false
					if Data.Stamp.CurrentParts[1]:FindFirstChild("AutoWedge") then autoWedgeClusterParts = true end

					if Data.Stamp.CurrentParts[1]:FindFirstChild("ClusterMaterial") then
						clusterMaterial = Data.Stamp.CurrentParts[1].ClusterMaterial
						if (clusterMaterial:IsA("Vector3Value")) then
							-- extract all info from vector
							clusterType = clusterMaterial.Value.Y
							clusterOrientation = clusterMaterial.Value.Z
							clusterMaterial = clusterMaterial.Value.X
						else
							clusterMaterial = clusterMaterial.Value
						end
					end
		
					if HighScalabilityLine.Adorn.Parent and HighScalabilityLine.Start and ((HighScalabilityLine.Dimensions &gt; 1) or (line and line.magnitude &gt; 0)) then
						local startCell = game.Workspace.Terrain:WorldToCell(HighScalabilityLine.Start)

						local xInc = {0,0,0}
						local yInc = {0,0,0}
						local zInc = {0,0,0}
			
						local incrementVect = {nil, nil, nil}
						local stepVect = {Vector3.new(0, 0, 0), Vector3.new(0, 0, 0), Vector3.new(0, 0, 0)}

						local worldAxes = {Vector3.new(1, 0, 0), Vector3.new(0, 1, 0), Vector3.new(0, 0, 1)}

						local lines = {}
						if HighScalabilityLine.Dimensions &gt; 1 then table.insert(lines, HighScalabilityLine.MoreLines[1]) end
						if line and line.magnitude &gt; 0 then table.insert(lines, line) end
						if HighScalabilityLine.Dimensions &gt; 2 then table.insert(lines, HighScalabilityLine.MoreLines[2]) end

						for i = 1, #lines do
							lines[i] = Vector3.new(math.floor(lines[i].X+.5), math.floor(lines[i].Y+.5), math.floor(lines[i].Z+.5)) -- round to integers

							if lines[i].X &gt; 0 then xInc[i] = 1 elseif lines[i].X &lt; 0 then xInc[i] = -1 end
							if lines[i].Y &gt; 0 then yInc[i] = 1 elseif lines[i].Y &lt; 0 then yInc[i] = -1 end
							if lines[i].Z &gt; 0 then zInc[i] = 1 elseif lines[i].Z &lt; 0 then zInc[i] = -1 end

							incrementVect[i] = Vector3.new(xInc[i], yInc[i], zInc[i])
							if incrementVect[i].magnitude &lt; .9 then incrementVect[i] = nil end
						end


						if not lines[2] then lines[2] = Vector3.new(0, 0, 0) end
						if not lines[3] then lines[3] = Vector3.new(0, 0, 0) end

						while (stepVect[3].magnitude*4 &lt;= lines[3].magnitude) do
							local outerStepVectIndex = 1
							while outerStepVectIndex &lt; 4 do
							stepVect[2] = Vector3.new(0, 0, 0)
						while (stepVect[2].magnitude*4 &lt;= lines[2].magnitude) do
							local innerStepVectIndex = 1
							while innerStepVectIndex &lt; 4 do
							stepVect[1] = Vector3.new(0, 0, 0)
						while (stepVect[1].magnitude*4 &lt;= lines[1].magnitude) do
							local stepVectSum = stepVect[1] + stepVect[2] + stepVect[3]
							local cellPos = Vector3int16.new(startCell.X + stepVectSum.X, startCell.Y + stepVectSum.Y, startCell.Z + stepVectSum.Z)
							if cellPos.X &gt;= cMin.X and cellPos.Y &gt;= cMin.Y and cellPos.Z &gt;= cMin.Z and cellPos.X &lt; cMax.X and cellPos.Y &lt; cMax.Y and cellPos.Z &lt; cMax.Z then
								-- check if overlaps player or part:
								local cellCenter = game.Workspace.Terrain:CellCenterToWorld(cellPos.X, cellPos.Y, cellPos.Z)
								local cellBlockingParts = game.Workspace:FindPartsInRegion3(Region3.new(cellCenter - Vector3.new(2, 2, 2) + insertBoundingBoxOverlapVector, cellCenter + Vector3.new(2, 2, 2) - insertBoundingBoxOverlapVector), Data.Stamp.CurrentParts[1], 100)

								local skipThisCell = false
								for b = 1, #cellBlockingParts do
									if isBlocker(cellBlockingParts[b]) then skipThisCell = true break end
								end
								
								if not skipThisCell then
									-- pop players up above any set cells
									local alreadyPushedUp = {}
									-- if no blocking model below, then see if stamping on top of a character
									for b = 1, #cellBlockingParts do
										if cellBlockingParts[b].Parent and not alreadyPushedUp[cellBlockingParts[b].Parent] and cellBlockingParts[b].Parent:FindFirstChild("Humanoid") and cellBlockingParts[b].Parent:FindFirstChild("Humanoid"):IsA("Humanoid") then
											local blockingPersonTorso = cellBlockingParts[b].Parent:FindFirstChild("Torso")
											alreadyPushedUp[cellBlockingParts[b].Parent] = true

											if blockingPersonTorso then
												-- if so, let's push the person upwards so they pop on top of the stamped model/part (but only if there's space above them)
												local newY = cellCenter.Y + 5
												if spaceAboveCharacter(blockingPersonTorso, newY) then
													blockingPersonTorso.CFrame = blockingPersonTorso.CFrame + Vector3.new(0, newY - blockingPersonTorso.CFrame.p.Y, 0)
												else
													-- if no space, we just skip this one
													skipThisCell = true
													break
												end
											end
										end
									end
								end
						
								if not skipThisCell then  -- if we STILL aren't skipping...  then we're good to go!
									-- set it
									cluster:SetCell(cellPos.X, cellPos.Y, cellPos.Z, clusterMaterial, clusterType, clusterOrientation)
											
									-- auto-wedge it?
									if (autoWedgeClusterParts) then
										game.Workspace.Terrain:AutowedgeCells(Region3int16.new(Vector3int16.new(cellPos.x - 1, cellPos.y - 1, cellPos.z - 1), Vector3int16.new(cellPos.x + 1, cellPos.y + 1, cellPos.z + 1)))
									end
								end
							end

							stepVect[1] = stepVect[1] + incrementVect[1]
						end
							if incrementVect[2] then
								while innerStepVectIndex &lt; 4 and worldAxes[innerStepVectIndex]:Dot(incrementVect[2]) == 0 do innerStepVectIndex = innerStepVectIndex + 1 end
								if innerStepVectIndex &lt; 4 then 
									stepVect[2] = stepVect[2] + worldAxes[innerStepVectIndex]*worldAxes[innerStepVectIndex]:Dot(incrementVect[2])
								end
								innerStepVectIndex = innerStepVectIndex + 1
							else stepVect[2] = Vector3.new(1, 0, 0) innerStepVectIndex = 4 end -- skip all remaining loops
							if (stepVect[2].magnitude*4 &gt; lines[2].magnitude) then innerStepVectIndex = 4 end
						end
						end
							wait()
							if incrementVect[3] then 
								while outerStepVectIndex &lt; 4 and worldAxes[outerStepVectIndex]:Dot(incrementVect[3]) == 0 do outerStepVectIndex = outerStepVectIndex + 1 end
								if outerStepVectIndex &lt; 4 then
									stepVect[3] = stepVect[3] + worldAxes[outerStepVectIndex]*worldAxes[outerStepVectIndex]:Dot(incrementVect[3]) 
								end
								outerStepVectIndex = outerStepVectIndex + 1
							else stepVect[3] = Vector3.new(1, 0, 0) outerStepVectIndex = 4 end -- skip all remaining loops
							if (stepVect[3].magnitude*4 &gt; lines[3].magnitude) then outerStepVectIndex = 4 end
						end
						end

						-- and also get rid of any HighScalabilityLine stuff if it's there
						HighScalabilityLine.Start = nil
						HighScalabilityLine.Adorn.Parent = nil
						Data.Stamp.MouseLock = false
						return
					end

				-- not High-Scalability-Line-Based, so behave normally [and get rid of any HSL stuff]
				HighScalabilityLine.Start = nil
				HighScalabilityLine.Adorn.Parent = nil

				-- if target point is in cluster, just use cluster:SetCell
				if cluster then
					-- if targetCFrame is inside cluster, just set that cell to 1 and return
					local cellPos = cluster:WorldToCell(targetCFrame.p)

					if cellPos.X &gt;= cMin.X and cellPos.Y &gt;= cMin.Y and cellPos.Z &gt;= cMin.Z and cellPos.X &lt; cMax.X and cellPos.Y &lt; cMax.Y and cellPos.Z &lt; cMax.Z then
						cluster:SetCell(cellPos.X, cellPos.Y, cellPos.Z, clusterMaterial, clusterType, clusterOrientation)

						-- auto-wedge it
						if (autoWedgeClusterParts) then
							game.Workspace.Terrain:AutowedgeCells(Region3int16.new(Vector3int16.new(cellPos.x - 1, cellPos.y - 1, cellPos.z - 1), Vector3int16.new(cellPos.x + 1, cellPos.y + 1, cellPos.z + 1)))
						end

						Data.Stamp.MouseLock = false
						return
					end
				end
			end

			-- Post process: after positioning the part or model, restore transparency, material, anchored and collide states and create joints
			if Data.Stamp.CurrentParts[1]:IsA("Model") or Data.Stamp.CurrentParts[1]:IsA("Tool") then
				
				if Data.Stamp.CurrentParts[1]:IsA("Model") then
					-- Tyler's magical hack-code for allowing/preserving clones of both Surface and Manual Welds...  just don't ask X&lt;
					manualWeldTable = {}
					manualWeldParentTable = {}
					saveTheWelds(Data.Stamp.CurrentParts[1])
					Data.Stamp.CurrentParts[1]:BreakJoints()
					Data.Stamp.CurrentParts[1]:MakeJoints()
					restoreTheWelds()
				end
				
				-- if it's a model, we also want to fill in the playerID and playerName tags, if it has those (e.g. for the friend-only door)
				playerIdTag = Data.Stamp.CurrentParts[1]:FindFirstChild("PlayerIdTag")
				playerNameTag = Data.Stamp.CurrentParts[1]:FindFirstChild("PlayerNameTag")
				if playerIdTag ~= nil then
					tempPlayerValue = getPlayer()
					if tempPlayerValue ~= nil then playerIdTag.Value = tempPlayerValue.userId end
				end
				if playerNameTag ~= nil then
					tempPlayerValue = getPlayer()
					if tempPlayerValue ~= nil then playerNameTag.Value = tempPlayerValue.Name end
				end
				-- ...and tag all inserted models for subsequent origin identification
				-- if no RobloxModel tag already exists, then add it.
				if Data.Stamp.CurrentParts[1]:FindFirstChild("RobloxModel") == nil then
					local stringTag = Instance.new("BoolValue", Data.Stamp.CurrentParts[1])
					stringTag.Name = "RobloxModel"

					if Data.Stamp.CurrentParts[1]:FindFirstChild("RobloxStamper") == nil then
						local stringTag2 = Instance.new("BoolValue", Data.Stamp.CurrentParts[1])
						stringTag2.Name = "RobloxStamper"
					end
				end

			else
				Data.Stamp.CurrentParts[1]:BreakJoints()
				if Data.Stamp.CurrentParts[1]:FindFirstChild("RobloxStamper") == nil then
					local stringTag2 = Instance.new("BoolValue", Data.Stamp.CurrentParts[1])
					stringTag2.Name = "RobloxStamper"
				end
			end
			
			-- make sure all the joints are activated before restoring anchor states
			if not createJoints then game.JointsService:CreateJoinAfterMoveJoints() end

			click.Value = true
			--Fix the transparency and material of all the parts
			for part, transparency in pairs(Data.Stamp.TransparencyTable) do
				part.Transparency = transparency
				part.archivable = true
			end
			for part, material in pairs(Data.Stamp.MaterialTable) do
				part.Material = material
			end
			for part, collide in pairs(Data.Stamp.CanCollideTable) do
				part.CanCollide = collide
			end
			for part, anchored in pairs(Data.Stamp.AnchoredTable) do
				part.Anchored = anchored
			end
			for decal, transparency in pairs(Data.Stamp.DecalTransparencyTable) do
				decal.Transparency = transparency
			end

			if (Data.Stamp.CurrentParts[1] and Data.Stamp.CurrentParts[1].Name == "MegaClusterCube") then
				Data.Stamp.CurrentParts[1].Transparency = 0
			end

			-- re-enable all seats
			setSeatEnabledStatus(Data.Stamp.CurrentParts[1], true)

			Data.Stamp.TransparencyTable = nil
			Data.Stamp.MaterialTable = nil
			Data.Stamp.CanCollideTable = nil
			Data.Stamp.AnchoredTable = nil

			-- ...and tag all inserted models for subsequent origin identification
			-- if no RobloxModel tag already exists, then add it.
			if Data.Stamp.CurrentParts[1]:FindFirstChild("RobloxModel") == nil then
				local stringTag = Instance.new("BoolValue", Data.Stamp.CurrentParts[1])
				stringTag.Name = "RobloxModel"
			end
						
			-- set our object back to the player's plate
			Data.Stamp.CurrentParts[1].Parent = partModel

			--Re-enable the scripts
			for index,script in pairs(Data.Stamp.DisabledScripts) do
				script.Disabled = false
			end
			--Now that they are all marked enabled, reinsert them into the world so they start running
			for index,script in pairs(Data.Stamp.DisabledScripts) do
				local oldParent = script.Parent
				script.Parent = nil
				script:Clone().Parent = oldParent
			end
			Data.Stamp.DisabledScripts = nil
			Data.Stamp.Dragger = nil
			Data.Stamp.CurrentParts.Parent = nil
			Data.Stamp.CurrentParts = nil

			Data.Stamp.MouseLock = false

			--Now set up a new instance of the object to allow a second copy to be stamped down
			variables.Stamped.Value = true
			variables.Stamped.Value = false
			if isRestricted then
				if checkPartLimit() then
					setupDraggableClone()
				else
					variables.ShowMaxedOut.Value = true
				end
			else
				setupDraggableClone()
			end

		end
	end
end


------------------------ EyeDropper Code -------------------------------------------

function onEyeDropperMouseButton1Down()
	if eyeDropperMoveConnection then 
		eyeDropperMoveConnection:disconnect()
	end
	clearSelection()
	if Mouse then
		Mouse.Icon = "http://www.roblox.com/asset?id=66887745"
	end

	-- deny any attempt to clone something that wasn't stamped using the Stamper tool
	if not Mouse or not Mouse.Target then
		startEyeDropperOperation()
		return
	end

	local isTerrainEyedroppering = false
	if Mouse.Target == game.Workspace.Terrain then
		-- want to eyedropper a terrain piece; gotta do a little extra footwork
		print("Eyedroppering Terrain Piece")
		local newTerrainPiece

		-- gotta make the fake part here
		local hitCell = game.Workspace.Terrain:WorldToCellPreferSolid(Mouse.Hit.p)
		local cellMat, cellType, cellOrient = game.Workspace.Terrain:GetCell(hitCell.x, hitCell.y, hitCell.z)

		if (cellType.Value == 1 or cellType.Value == 4) then newTerrainPiece = Instance.new("WedgePart") newTerrainPiece.formFactor = "Custom"
		elseif (cellType.Value == 2) then newTerrainPiece = Instance.new("CornerWedgePart")
		else newTerrainPiece = Instance.new("Part") newTerrainPiece.formFactor = "Custom" end
		newTerrainPiece.Name = "MegaClusterCube"
		newTerrainPiece.Size = Vector3.new(4, 4, 4)
		newTerrainPiece.BottomSurface = "Smooth"
		newTerrainPiece.TopSurface = "Smooth"

		-- can add decals or textures here if feeling particularly adventurous...  for now, can make a table of look-up colors
		newTerrainPiece.BrickColor = getClosestColorToTerrainMaterial(cellMat.Value)

		local sideways = 0
		local flipped = math.pi
		if cellType.Value == 4 then sideways = -math.pi/2 end
		if cellType.Value == 2 or cellType.Value == 3 then flipped = 0 end
		newTerrainPiece.CFrame = CFrame.Angles(0, math.pi/2*cellOrient.Value + flipped, sideways)

		if cellType.Value == 3 then
			local inverseCornerWedgeMesh = Instance.new("SpecialMesh")
			inverseCornerWedgeMesh.MeshType = "FileMesh"
			inverseCornerWedgeMesh.MeshId = "http://www.roblox.com/asset?id=66832495"
			inverseCornerWedgeMesh.Scale = Vector3.new(2, 2, 2)
			inverseCornerWedgeMesh.Parent = newTerrainPiece
		end

		local materialTag = Instance.new("Vector3Value")
		materialTag.Value = Vector3.new(cellMat.Value, cellType.Value, cellOrient.Value)
		materialTag.Name = "ClusterMaterial"
		materialTag.Parent = newTerrainPiece

		local tempModel = Instance.new("Model")
		newTerrainPiece.Parent = tempModel

		Data.Stamp.Model = tempModel
		Data.Stamp.Model:BreakJoints()

		isTerrainEyedroppering = true
	end

	local stamperTag = Mouse.Target.Parent:FindFirstChild("RobloxStamper")
	if stamperTag == nil then stamperTag = Mouse.Target:FindFirstChild("RobloxStamper") end
	if stamperTag == nil and not isTerrainEyedroppering then
		startEyeDropperOperation()
		return
	end

	local eyeDropperInstance
	-- find out if the target part is part of a Roblox Set Model
	local robloxModelTag = Mouse.Target.Parent:FindFirstChild("RobloxModel")
	if robloxModelTag ~= nil then
		eyeDropperInstance = Mouse.Target.Parent
	else
		eyeDropperInstance = Mouse.Target
	end
	
	-- do not allow certain objects to be captured with eye-dropper
	-- for now, locked parts
	if eyeDropperInstance:IsA("Part") and eyeDropperInstance.Locked and not isTerrainEyedroppering then
		startEyeDropperOperation()
	else
		if not isTerrainEyedroppering then
			local cloneInstance = eyeDropperInstance:clone()
			local tempModel = Instance.new("Model")
			cloneInstance.Parent = tempModel

			-- once more, we make sure it's on grid before eyedroppering
			if not isOnGrid(tempModel) then startEyeDropperOperation() return end

			Data.Stamp.Model = tempModel
			Data.Stamp.Model:BreakJoints()
		end

		-- will create and position clone without requiring user to move the mouse		

		if isRestricted then
			if checkPartLimit() then
				setupDraggableClone()
				if Mouse and not mouseButton1UpCon then mouseButton1UpCon = Mouse.Button1Up:connect(onInsertMouseButton1Up) end
			else
				variables.ShowMaxedOut.Value = true
			end
		else
			setupDraggableClone()
			if Mouse and not mouseButton1UpCon then mouseButton1UpCon = Mouse.Button1Up:connect(onInsertMouseButton1Up) end
		end

		variables.SwitchLoaderToDialog.AssetImage.Value = "0"
		variables.SwitchLoaderToDialog.DialogType.Value = "SideDialog"
		variables.SwitchLoaderToDialog.Value = true
	end
end

function onEyeDropperMouseMove() 
	if not(inGui) and not(inPalette) then
		if not Mouse or not Mouse.Target then clearSelection() return end
		local part = Mouse.Target
		if part:IsA("Terrain") and Mouse.Hit then
			selectionBox.Color = BrickColor.Green()
			setTerrainSelection(Mouse.Hit.p)
		elseif canEyeDropperObject(part) then
			local model = findModel(part)
			if model and isOnGrid(model) then 		
				selectionBox.Color = BrickColor.Green()
				setSelection(model)
			elseif (not model) and isOnGrid(part) then
				selectionBox.Color = BrickColor.Green()
				setSelection(part)
			else
				clearSelection()
			end
		else
			clearSelection()
		end
	end
end

function startEyeDropperOperation()

	cancelAssetPlacement()
	pressedEsc = false
	signalInsertComplete("EyeDropper")

	if mouseButton1UpCon then mouseButton1UpCon:disconnect() mouseButton1UpCon = nil end

	if eyeDropperConnection then
		eyeDropperConnection:disconnect()
		eyeDropperConnection = nil
	end
	if eyeDropperMoveConnection then eyeDropperMoveConnection:disconnect() end
	if Mouse then
		--Mouse.Icon ="rbxasset://textures//DropperCursor.png"
		Mouse.Icon = "http://www.roblox.com/asset?id=67163166"
		eyeDropperConnection = Mouse.Button1Up:connect(onEyeDropperMouseButton1Down)
		eyeDropperMoveConnection = Mouse.Move:connect(onEyeDropperMouseMove)
	end

end

function findModel(part)

	if isRestricted then
		while part ~= nil do
			if part.className == "Model" and part.Name ~= playerModel.Name and part.Name ~= "GarbageParts" then
				return part
			elseif part.Name == playerModel.Name or part.Name == "GarbageParts" then
				return nil
			end
			part = part.Parent
		end
		return nil

	else
		while part ~= game.Workspace do
			if part:FindFirstChild("RobloxModel") then
				return part
			end
			part = part.Parent
		end
		return nil
	end

end

------------------------ End EyeDropper Code ---------------------------------------




------------------------ Start Selection Highlighting Code --------------------------
function setTerrainSelection(point)
	if selectionBox then
		local cell = game.Workspace.Terrain:WorldToCellPreferSolid(point)
		local cellCenter = game.Workspace.Terrain:CellCenterToWorld(cell.X, cell.Y, cell.Z)
		terrainSelectionBox.CFrame = CFrame.new(cellCenter)
		selectionBox.Adornee = terrainSelectionBox
	end
end
	
function setSelection(partOrModel)
	if partOrModel ~= currentSelection then
		clearSelection()
		currentSelection = partOrModel
		selectionBox.Adornee = currentSelection
	end
end

function clearSelection()
	if currentSelection ~= nil then
		for part, color in pairs(currentSelectionColors) do
			part.BrickColor = color
		end
		selectionBox.Adornee = nil
	end
	currentSelectionColors = {}
	-- I put these inside if statements, because we can't assume these exist. (Jahr, 12-29-2010)
	if currentSelection then currentSelection = nil end
	if selectionBox then selectionBox.Adornee = nil end
end

------------------------ End Selection Highlighting Code --------------------------

function autoAlignToFace()
	local aatf = Data.Stamp.CurrentParts[1]:FindFirstChild("AutoAlignToFace")
	if aatf then return aatf.Value else return false end
end


function autoAlignHelper()
	local model = Data.Stamp.CurrentParts[1]
	local aatfTag = model:FindFirstChild("AutoAlignToFace")
	if not aatfTag then
		aatfTag = Instance.new("IntValue")
		aatfTag.Name = "AutoAlignToFace"
		aatfTag.Parent = Data.Stamp.CurrentParts[1]
		aatfTag.Value = 3
	end
	aatfTag.Value = aatfTag.Value + 1
	if aatfTag.Value &gt; 3 then aatfTag.Value = 0 end
end

function unstampableFaceHelper()
	if not Mouse or not Mouse.Target then return end
	local model = Mouse.Target
	if not model then return end
	if not model:FindFirstChild("RobloxModel") then model = model.Parent end
	if not model then return end
	if not model:FindFirstChild("RobloxModel") then return end

	local ufhTag = model:FindFirstChild("UnstampableFaces")
	if not ufhTag then
		ufhTag = Instance.new("StringValue")
		ufhTag.Name = "UnstampableFaces"
		ufhTag.Parent = model
		ufhTag.Value = ""
	end
	
	local hitFace = modelTargetSurface(model, game.Workspace.CurrentCamera.CoordinateFrame.p, Mouse.Hit.p)

	-- put string list into table form
	breakingFaceList = {}
	for bf = -3, 3 do
		breakingFaceList[bf] = false
	end
	for bf in string.gmatch(ufhTag.Value, "[^,]+") do
		breakingFaceList[tonumber(bf)] = true
	end

	-- toggle value of hit face
	breakingFaceList[hitFace] = not breakingFaceList[hitFace]

	-- put table form back into string value
	ufhTag.Value = ""
	local seenAValueSoFar = false
	for bf = -3, 3 do
		if bf ~= 0 then -- ignore 0 face, since that doesn't exist
			if breakingFaceList[bf] then 
				if seenAValueSoFar then ufhTag.Value = ufhTag.Value .. "," .. tostring(bf)
				else ufhTag.Value = tostring(bf) seenAValueSoFar = true end
			end
		end
	end
end

function justificationHelper(whichAxis)
	local model = Data.Stamp.CurrentParts[1]
	local justTag = model:FindFirstChild("Justification")
	if not justTag then
		justTag = Instance.new("Vector3Value")
		justTag.Name = "Justification"
		justTag.Parent = Data.Stamp.CurrentParts[1]
		justTag.Value = Vector3.new(1, 1, 1)
	end
	local oldValue = justTag.Value
	if whichAxis == 1 then
		if oldValue.X == 2 then justTag.Value = Vector3.new(0, oldValue.Y, oldValue.Z)
		else justTag.Value = Vector3.new(oldValue.X+1, oldValue.Y, oldValue.Z) end
	elseif whichAxis == 2 then
		if oldValue.Y == 2 then justTag.Value = Vector3.new(oldValue.X, 0, oldValue.Z)
		else justTag.Value = Vector3.new(oldValue.X, oldValue.Y+1, oldValue.Z) end
	elseif whichAxis == 3 then
		if oldValue.Z == 2 then justTag.Value = Vector3.new(oldValue.X, oldValue.Y, 0)
		else justTag.Value = Vector3.new(oldValue.X, oldValue.Y, oldValue.Z+1) end
	end
end

function onInsertKeyDown(key)
	key = string.lower(key)
	if Data.Stamp.Dragger then
		if key == 'c' and Data.Stamp.CurrentParts[1].Name == "MegaClusterCube" and HighScalabilityLine.InternalLine and HighScalabilityLine.InternalLine.magnitude &gt; 0 and HighScalabilityLine.Dimensions &lt; 3 then
			HighScalabilityLine.MorePoints[HighScalabilityLine.Dimensions] = HighScalabilityLine.End
			HighScalabilityLine.MoreLines[HighScalabilityLine.Dimensions] = HighScalabilityLine.InternalLine
			HighScalabilityLine.Dimensions = HighScalabilityLine.Dimensions + 1
			HighScalabilityLine.NewHint = true
		end

		if key == 'r' and not autoAlignToFace() then
			-- Update orientation value if this is a fake terrain part
			if Data.Stamp.CurrentParts[1].Name == "MegaClusterCube" then
				local clusterValues = Data.Stamp.CurrentParts[1]:FindFirstChild("ClusterMaterial")
				if clusterValues and clusterValues:IsA("Vector3Value") then
					clusterValues.Value = Vector3.new(clusterValues.Value.X, clusterValues.Value.Y, (clusterValues.Value.Z+1)%4)
				end
			end

			-- Rotate the parts or all the parts in the model
			local ry = math.pi/2
			local rotCF = CFrame.fromEulerAnglesXYZ(0, ry, 0)
			gInitial90DegreeRotations = gInitial90DegreeRotations + 1
			if Data.Stamp.CurrentParts[1]:IsA("Model") or Data.Stamp.CurrentParts[1]:IsA("Tool") then
				for i, object in pairs(Data.Stamp.CurrentParts[1]:GetChildren()) do
					if object:IsA("Flag") then object = object.Handle end
					if object:IsA("Part") or object:IsA("TrussPart") or object:IsA("WedgePart") or object:IsA("CornerWedgePart") or object:IsA("Seat") or object:IsA("VehicleSeat") then
						object.CFrame = rotCF * object.CFrame
					end
				end
			else
				Data.Stamp.CurrentParts[1].CFrame = rotCF * Data.Stamp.CurrentParts[1].CFrame
			end
			-- After rotating, update the position
			configFound, targetCFrame = findConfigAtMouseTarget(Data.Stamp.TransparencyTable)
			if configFound then
				positionPartsAtCFrame3(Data.Stamp.CurrentParts[1], targetCFrame)
				
				-- update everything else in MouseMove
				onInsertMouseMove()
			end
		end
	end
	if key == 'e'  then
		startEyeDropperOperation()
	elseif key == 'q' then
		pressedEsc = true
		if eyeDropperConnection then
			eyeDropperConnection:disconnect()
			eyeDropperConnection = nil
		end
		if eyeDropperMoveConnection then eyeDropperMoveConnection:disconnect() end

		if Mouse and not mouseButton1UpCon then mouseButton1UpCon = Mouse.Button1Up:connect(onInsertMouseButton1Up) end

		clearSelection()
		cancelAssetPlacement()
		Data.Loading.Cancelled = true
		signalInsertComplete("Main")
	end
	
	-- admin-only tools: helpful functions for construction purposes
	if adminAccess then
		if key == 'L' or key == 'l' then
			-- autoalign helper
			if Data.Stamp.Dragger then autoAlignHelper() onInsertMouseMove() end
		elseif key == 'U' or key == 'u' then
			-- unstampable face helper
			unstampableFaceHelper()
		--elseif key == 'C' or key == 'c' then
--			if Data.Stamp.Dragger then justificationHelper() end -- the 'c' stands for "Centering" since "j" is already reserved by GuiScript
		--end
		elseif key == 'X' or key == 'x' then  -- change x justification
			if Data.Stamp.Dragger then justificationHelper(1) onInsertMouseMove() end
		elseif key == 'Y' or key == 'y' then  -- change y justification
			if Data.Stamp.Dragger then justificationHelper(2) onInsertMouseMove() end
		elseif key == 'Z' or key == 'z' then  -- change z justification
			if Data.Stamp.Dragger then justificationHelper(3) onInsertMouseMove() end
		end
	end
end


function onEquippedLocal(newMouse)
	Mouse = newMouse

	player = getPlayer()

	-- if equip goes through while in backpack (so getPlayer() returns nil), we don't want to process anything else
	if not player then return end

	--[[if game:FindFirstChild("NetworkClient") and game.CoreGui.Version &gt;= 7 then  only show billboards in online mode
		if not billBoardOwnerGui then billBoardOwnerGui = generateOwnerGui(player.Name) end
	end]]

	if isRestricted then
		if game.Workspace:FindFirstChild("BuildingAreas") then
			local areas = game.Workspace.BuildingAreas:GetChildren()
			for i = 1, #areas do
				if areas[i]:FindFirstChild("Player") and areas[i].Player.Value == Tool.Parent.Name then
					playerModel = areas[i]:FindFirstChild("PlayerArea")
					break
				end
			end
		end
	else
		playerModel = game.Workspace

		-- give them a topHint gui too, if they don't have it since the place won't already have it	
		if not player.PlayerGui:FindFirstChild("topHint") then
			local topHintGui = script.Parent:FindFirstChild("topHint")
			if topHintGui then
				topHintGui:Clone().Parent = player.PlayerGui
			end
		end
	end

	if not playerModel then return end

	-- used to move object when walking
	cameraChangeCon = game.Players.LocalPlayer.Character.Humanoid.Running:connect(function(speed)
		if speed &gt; 0 then
			walking = true
			while walking and cameraChangeCon do
				onInsertMouseMove()
				wait(1.0/30.0)
			end
		else
			walking = false
		end
	end)
	if Mouse then
		mouseMoveCon = newMouse.Move:connect(onInsertMouseMove)
		mouseButton1DownCon = newMouse.Button1Down:connect(onInsertMouseButton1Down)
		mouseButton1UpCon = newMouse.Button1Up:connect(onInsertMouseButton1Up)
		newMouse.KeyDown:connect(onInsertKeyDown)
	end

	if(isRestricted) then
		local takenAreas = game.Workspace.BuildingAreas:GetChildren()

		waitForChild(player, "playerNumber")

		if(player.playerNumber.Value == 0) then
			buildingPlate = nil
			partModel = nil
		else
			waitForChild(game.Workspace, "BuildingAreas")
			local buildingAreas = game.Workspace.BuildingAreas
			waitForChild(buildingAreas, "Area"..tostring(player.playerNumber.Value))
			local targetArea = buildingAreas:FindFirstChild("Area"..tostring(player.playerNumber.Value))
			
			waitForChild(targetArea, "PlayerArea")
			waitForChild(targetArea.PlayerArea, "BasePlate")

			buildingPlate = targetArea.PlayerArea.BasePlate
			partModel = targetArea.PlayerArea
		end
	else
		partModel = game.Workspace
	end

	selectionBox = Instance.new("SelectionBox")
	selectionBox.Name = "Model Delete Selection"
	selectionBox.Color = BrickColor.Red()
	selectionBox.Adornee = nil
	selectionBox.Parent = player.PlayerGui

	alreadyMoving = false
end


function onUnequipped()
	Mouse = nil
	if mouseMoveCon then mouseMoveCon:disconnect() end
	if mouseButton1DownCon then mouseButton1DownCon:disconnect() end
	if mouseButton1UpCon then mouseButton1UpCon:disconnect() end
	if cameraChangeCon then cameraChangeCon:disconnect() cameraChangeCon = nil end
	if billBoardOwnerGui then billBoardOwnerGui:Remove() end

	cancelAssetPlacement()

	clearSelection()
	if selectionBox then selectionBox:Remove() end
end
----------------------------------------------------------------------------------------




-- Lua Start Script
Tool.Equipped:connect(function(newMouse) onEquippedLocal(newMouse) end)

waitForChild(variables,"InsertAsset")
waitForChild(variables.InsertAsset, "Updated")
variables.InsertAsset.Updated.Changed:connect(function(prop)
	if variables.InsertAsset.Updated.Value == true then
		pressedEsc = false
		beginInsertAssetStamp(variables.InsertAsset.AssetName.Value, variables.InsertAsset.AssetId.Value,
			variables.InsertAsset.Image.Value, variables.InsertAsset.StampMode.Value)
		variables.InsertAsset.Updated.Value = false
	end
end)

waitForChild(variables, "SwitchMode")
waitForChild(variables.SwitchMode, "Mode")
variables.SwitchMode.Changed:connect(function()
	if variables.SwitchMode.Value == true then
		if variables.SwitchMode.Mode.Value == "Clone" then
			startEyeDropperOperation()
		end
		variables.SwitchMode.Value = false
	end
end)

waitForChild(variables, "ReloadCurrentAsset")
variables.ReloadCurrentAsset.Changed:connect(function()
	if variables.ReloadCurrentAsset.Value == true then
		setupDraggableClone()
		variables.ReloadCurrentAsset.Value = false
	end
end)

Tool.Unequipped:connect(function() onUnequipped() end)
----------------------------------------------------------------------------------------


</ProtectedString>
			</Properties>
		</Item>
		<Item class="ScreenGui" referent="RBX153">
			<Properties>
				<string name="Name">topHint</string>
			</Properties>
			<Item class="ImageLabel" referent="RBX154">
				<Properties>
					<bool name="Active">false</bool>
					<Color3 name="BackgroundColor3">4288914085</Color3>
					<float name="BackgroundTransparency">1</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<Content name="Image"><null></null></Content>
					<string name="Name">_preview</string>
					<UDim2 name="Position">
						<XS>0</XS>
						<XO>0</XO>
						<YS>0</YS>
						<YO>0</YO>
					</UDim2>
					<UDim2 name="Size">
						<XS>1</XS>
						<XO>0</XO>
						<YS>1</YS>
						<YO>0</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<bool name="Visible">false</bool>
					<int name="ZIndex">1</int>
				</Properties>
				<Item class="Frame" referent="RBX155">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">Bkg</string>
						<UDim2 name="Position">
							<XS>0.5</XS>
							<XO>-250</XO>
							<YS>0</YS>
							<YO>10</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>400</XO>
							<YS>0</YS>
							<YO>40</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">3</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
				<Item class="TextButton" referent="RBX156">
					<Properties>
						<bool name="Active">true</bool>
						<bool name="AutoButtonColor">true</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">0</token>
						<token name="FontSize">5</token>
						<bool name="Modal">false</bool>
						<string name="Name">Label</string>
						<UDim2 name="Position">
							<XS>0.25</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>10</YO>
						</UDim2>
						<bool name="Selected">false</bool>
						<UDim2 name="Size">
							<XS>0.5</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>40</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<string name="Text">Saved changes</string>
						<Color3 name="TextColor3">4294967295</Color3>
						<bool name="TextScaled">false</bool>
						<Color3 name="TextStrokeColor3">4278190080</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0</float>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
			</Item>
			<Item class="LocalScript" referent="RBX157">
				<Properties>
					<bool name="Disabled">true</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Add</string>
					<ProtectedString name="Source">-- This script's job is to destroy previous topHint instance (if exists) and clone and run a new _topHint script (naming it "topHint")
-- When this script is finished, it disables and resets itself.

function waitForChild(instance, name)
	while not instance:FindFirstChild(name) do
		instance.ChildAdded:wait()
	end
end

function waitForNoChild(instance, name)
	while instance:FindFirstChild(name) do
		instance.ChildRemoved:wait()
	end
end

function waitForAnyChild(instance)
	while not instance:GetChildren()[1] do
		instance.ChildAdded:wait()
	end
end

waitForChild(script, "Label")
waitForChild(script, "Time")
waitForChild(script, "Width")
waitForChild(script.Parent, "_topHint")
waitForChild(script.Parent._topHint, "Label")
waitForChild(script.Parent._topHint, "HideTime")
waitForChild(script.Parent._topHint, "Width")

local width = 0.55--script.Width.Value
--width = math.min(0.55,width/script.Parent.AbsoluteSize.X)

local quickReplace = true

-- If there's already an instance, do you quickly replace the text and width (true), or animate out then in? (false)

if (script.Parent:FindFirstChild("topHint")~=nil) then
	-- If there's already an instance...
	if(quickReplace) then
		-- If quickReplace is true...
		local bkg = script.Parent.Bkg
		local label = script.Parent.Label
		local ys = bkg.Position.Y.Scale
		local yo = bkg.Position.Y.Offset
		bkg.Position = UDim2.new((1 - width)/2,0, ys, yo)
		bkg.Size = UDim2.new(width,0, 0, 40)
		label.Text = script.Label.Value
		script.Parent.topHint.HideTime.Value = time() + script.Time.Value
	else
		-- If quickReplace is false...
		script.Parent.Delete.Disabled = false
		-- Wait for instance to be removed
		waitForNoChild(script.Parent, "topHint")
		waitForNoChild(script.Parent, "Bkg")
		waitForNoChild(script.Parent, "Label")
	end
else
	-- There's no previous instance.
	-- Clone and enable a new instance
	local topHint = script.Parent._topHint:Clone()
	topHint.Parent = script.Parent
	topHint.Name = "topHint"
	topHint.Label.Value = script.Label.Value
	topHint.HideTime.Value = time() + script.Time.Value
	topHint.Width.Value = width
	topHint.Disabled = false
end

script.Disabled = true
</ProtectedString>
				</Properties>
				<Item class="NumberValue" referent="RBX158">
					<Properties>
						<string name="Name">Width</string>
						<double name="Value">0</double>
					</Properties>
				</Item>
				<Item class="StringValue" referent="RBX159">
					<Properties>
						<string name="Name">Label</string>
						<string name="Value"></string>
					</Properties>
				</Item>
				<Item class="NumberValue" referent="RBX160">
					<Properties>
						<string name="Name">Time</string>
						<double name="Value">0</double>
					</Properties>
				</Item>
			</Item>
			<Item class="LocalScript" referent="RBX161">
				<Properties>
					<bool name="Disabled">true</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">_topHint</string>
					<ProtectedString name="Source">function waitForChild(instance, name)
	while not instance:FindFirstChild(name) do
		instance.ChildAdded:wait()
	end
end

function waitForNoChild(instance, name)
	while instance:FindFirstChild(name) do
		instance.ChildRemoved:wait()
	end
end

function waitForAnyChild(instance)
	while not instance:GetChildren()[1] do
		instance.ChildAdded:wait()
	end
end

-- This script creates the graphics for the new topHint, and animates it.
-- Before calling this script, we've already made sure: there's no other "topHint", "Bkg", and "Label"
-- Then, if time~=0, it waits "time" and then calls "Remove" script

waitForChild(script, "Label")
waitForChild(script, "HideTime")
waitForChild(script, "Width")

local container = script.Parent
local labelText = script.Label.Value
local hideTime = script.HideTime.Value
local width = script.Width.Value

-- SETTINGS
local tweenTime = 0.3 -- animation time (seconds)
local topY = -50
local bottomY = 10
local easing = "Sine.easeInOut"
--

local bkg = Instance.new("Frame")
bkg.Parent = container
bkg.Name = "Bkg"
bkg.Position = UDim2.new((1 - width)/2,0, ys, yo)
bkg.Size = UDim2.new(width,0, 0, 40)
bkg.Style = "RobloxRound"

function destroy()
	script.Parent.Delete.Disabled = false
end

local label = Instance.new("TextButton")
label.Parent = container
label.Name = "Label"
label.BackgroundTransparency = 1
label.FontSize = "Size14"
label.Position = UDim2.new((1 - width)/2,0, 0, topY)
label.Size = UDim2.new(width,0, 0, 40)
label.Text = labelText
label.TextColor3 = Color3.new(1, 1, 1)
label.MouseButton1Click:connect(destroy)

bkg:TweenPosition(UDim2.new(bkg.Position.X.Scale,bkg.Position.X.Offset,bkg.Position.Y.Scale,bottomY),
		Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,tweenTime,true)

label:TweenPosition(UDim2.new(label.Position.X.Scale,label.Position.X.Offset,label.Position.Y.Scale,bottomY),
		Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,tweenTime,true)

if(hideTime~=0) then
	while(time() &lt; hideTime) do wait(0.1) end
	destroy()
end</ProtectedString>
				</Properties>
				<Item class="NumberValue" referent="RBX162">
					<Properties>
						<string name="Name">Width</string>
						<double name="Value">0</double>
					</Properties>
				</Item>
				<Item class="StringValue" referent="RBX163">
					<Properties>
						<string name="Name">Label</string>
						<string name="Value"></string>
					</Properties>
				</Item>
				<Item class="NumberValue" referent="RBX164">
					<Properties>
						<string name="Name">HideTime</string>
						<double name="Value">0</double>
					</Properties>
				</Item>
			</Item>
			<Item class="LocalScript" referent="RBX165">
				<Properties>
					<bool name="Disabled">true</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Delete</string>
					<ProtectedString name="Source">function waitForChild(instance, name)
	while not instance:FindFirstChild(name) do
		instance.ChildAdded:wait()
	end
end

function waitForNoChild(instance, name)
	while instance:FindFirstChild(name) do
		instance.ChildRemoved:wait()
	end
end

function waitForAnyChild(instance)
	while not instance:GetChildren()[1] do
		instance.ChildAdded:wait()
	end
end

local topHint = script.Parent:FindFirstChild("topHint")
local bkg = script.Parent:FindFirstChild("Bkg")
local label = script.Parent:FindFirstChild("Label")

-- SETTINGS
local tweenTime = 0.3 -- animation time (seconds)
local topY = -50 -- top position (Y Offset)
local easing = "Back.easeInOut"
--

if(topHint~=nil) then
	topHint:Remove()
end

if(bkg~=nil) then
	bkg:TweenPosition(UDim2.new(bkg.Position.X.Scale,bkg.Position.X.Offset,bkg.Position.Y.Scale,topY),
		Enum.EasingDirection.InOut,Enum.EasingStyle.Quad,tweenTime,true)
end

if(label~=nil) then
	label:TweenPosition(UDim2.new(label.Position.X.Scale,label.Position.X.Offset,label.Position.Y.Scale,topY),
		Enum.EasingDirection.InOut,Enum.EasingStyle.Quad,tweenTime,true)
end

wait(tweenTime)
if(bkg~=nil) then bkg:Remove() end
if(label~=nil) then label:Remove() end

script.Disabled = true
</ProtectedString>
				</Properties>
			</Item>
			<Item class="LocalScript" referent="RBX166">
				<Properties>
					<bool name="Disabled">true</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">_readme</string>
					<ProtectedString name="Source">--
-- Top Hint
--
--  * This is a string of text that's top-centered in the window. (White text on black background)
--  * It should be used for messages from the client, and never from the place creator. 
--
-- FEATURES:
--  * Auto-hides previous messages before showing yours.
--  * Always centered, regardless of length.
--  * Clicking the message hides it.
-- 
-- USE IT FOR:
--  * Quick task-related (non-essential) hints
--  * Showing the current modal state
--  * Tool hints (for the currently equipped tool)
--  * Keyboard shortcuts
--
-- NEVER USE IT FOR:
--  * Essential information (Use a popup instead)
--  * Messages from users or place creators.  This is for client messages only.
--
-- ARGUMENTS:
--  Label:  The message
--  Width:  Text and background width (pixels) -- This should be removed when textWidth is added to Lua
--  Time:   Seconds before hiding itself (If 0, it never hides)
--
-- USAGE:
local topHint = script.Parent.topHint  -- path to topHint ScreenGui
topHint.Add.Label.Value = "Press D to return to main menu."
topHint.Add.Width.Value = 290
topHint.Add.Time.Value = 7
topHint.Add.Disabled = true  -- flip it off then on, in case it's currently running.
topHint.Add.Disabled = false
--
-- TO HIDE MANUALLY:
topHint.Delete.Disabled = false
-- Clicking the message also hides it.</ProtectedString>
				</Properties>
			</Item>
		</Item>
	</Item>
	<Item class="Tool" referent="RBX167">
		<Properties>
			<bool name="CanBeDropped">true</bool>
			<bool name="Enabled">true</bool>
			<CoordinateFrame name="Grip">
				<X>0</X>
				<Y>0</Y>
				<Z>-0.699999988</Z>
				<R00>0</R00>
				<R01>0</R01>
				<R02>1</R02>
				<R10>1</R10>
				<R11>0</R11>
				<R12>-0</R12>
				<R20>-0</R20>
				<R21>1</R21>
				<R22>-0</R22>
			</CoordinateFrame>
			<string name="Name">WiringTool</string>
			<Content name="TextureId"><url>rbxasset://../../../shareddata/textures/56954008.png</url></Content>
			<string name="ToolTip">Wiring Tool</string>
		</Properties>
		<Item class="Part" referent="RBX168">
			<Properties>
				<bool name="Anchored">false</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">0</token>
				<token name="BottomSurfaceInput">0</token>
				<int name="BrickColor">199</int>
				<CoordinateFrame name="CFrame">
					<X>-325.666901</X>
					<Y>16.8977261</Y>
					<Z>-19.8920441</Z>
					<R00>0.637222171</R00>
					<R01>-0.676772952</R01>
					<R02>0.368681878</R02>
					<R10>0.770636916</R10>
					<R11>0.564617038</R11>
					<R12>-0.295510411</R12>
					<R20>-0.00817063451</R20>
					<R21>0.47242564</R21>
					<R22>0.881332636</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<float name="Elasticity">0.5</float>
				<float name="Friction">0.300000012</float>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">true</bool>
				<token name="Material">256</token>
				<string name="Name">Handle</string>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<Vector3 name="RotVelocity">
					<X>-10.6016808</X>
					<Y>2.35600305</Y>
					<Z>-31.4032288</Z>
				</Vector3>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">0</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>29.2822094</X>
					<Y>-6.62870216</Y>
					<Z>-9.34984112</Z>
				</Vector3>
				<token name="formFactorRaw">2</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>1</X>
					<Y>0.800000012</Y>
					<Z>2</Z>
				</Vector3>
			</Properties>
			<Item class="SpecialMesh" referent="RBX169">
				<Properties>
					<token name="LODX">2</token>
					<token name="LODY">2</token>
					<Content name="MeshId"><url>rbxasset://../../../shareddata/fonts/16884681.mesh</url></Content>
					<token name="MeshType">5</token>
					<string name="Name">Mesh</string>
					<Vector3 name="Offset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<Vector3 name="Scale">
						<X>0.600000024</X>
						<Y>0.600000024</Y>
						<Z>0.600000024</Z>
					</Vector3>
					<Content name="TextureId"><url>rbxasset://../../../shareddata/textures/16884673.png</url></Content>
					<Vector3 name="VertexColor">
						<X>1</X>
						<Y>1</Y>
						<Z>1</Z>
					</Vector3>
				</Properties>
			</Item>
		</Item>
		<Item class="LocalScript" referent="RBX170">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">WiringScript</string>
				<ProtectedString name="Source">function waitForChild(parent, child)
	while not parent:FindFirstChild(child) do
		parent.ChildAdded:wait()
	end
end

local Tool = script.Parent
local mouseMoveCon, mouseButtonDownCon = nil

local eventTable = {}
local receiverTable = {}
local ServiceConnections = {}
local adornmentTable = {}

local eventBadgeCount = {}
local receiverBadgeCount = {}

local root = nil

local isRestricted = (game.PlaceId == 41324860 or game.PlaceId == 129686177)

waitForChild(Tool, "PlayerOwner")
local playerOwner = Tool.PlayerOwner

local CONNECT_BILLBOARD_GUI = "ConnectBillboardGui"
local WIRE_LASSO = "WireLasso"
local WIRE_TEXTURE = "http://www.roblox.com/asset?id=56954045"
--local WIRE_TEXTURE = "rbxasset://Textures/ui/playerlist_small_hide_dn.png"
local KILL_WIRE_TEXTURE = "rbxasset://Textures/ui/CloseButton_dn.png"
local STATIC_PLAYER_GUI = nil
local STATIC_BASE_PLATE = nil
local SELECTED_SOURCE = nil
local SELECTED_SINK = nil
local WIRE_LASSO_MAP = {}
local WIRING_PANEL_MAP = {}
local LAST_HOVERED_PART = nil
local SCREEN_MESSAGE = nil
local ANNOTATIONS = {}
local KNOWN_SOURCE_PARTS = {}
local KNOWN_SINK_PARTS = {}
local BASE_ANNOTATION_TRANSPARENCY = 0.5
local BASE_WIRE_TRANSPARENCY = 0.5
local BASE_WIRE_RADIUS = .06
local ENHANCED_WIRE_RADIUS = .12
local SOURCE_BUTTON_TEXT_COLOR = Color3.new(1, .5, 0)
local SOURCE_BUTTON_ICON_TEXTURE = "http://www.roblox.com/asset?id=61334830"
local SOURCE_BUTTON_ICON_HOVER_TEXTURE = "http://www.roblox.com/asset?id=61335012"
local SINK_BUTTON_TEXT_COLOR = Color3.new(0, 1, 0)
local SINK_BUTTON_ICON_TEXTURE = "http://www.roblox.com/asset?id=60730993"
local SINK_BUTTON_ICON_HOVER_TEXTURE = "http://www.roblox.com/asset?id=61335025"
local BUTTON_HOVER_TEXT_COLOR = Color3.new(1, 1, 1)
local BUTTON_ICON_WIDTH = 50
local DISCONNECT_ICON_HOVER_TEXTURE = "http://www.roblox.com/asset?id=55130256"
local DISCONNECT_SOURCE_ICON_TEXTURE = "http://www.roblox.com/asset?id=55130237"
local DISCONNECT_SINK_ICON_TEXTURE = "http://www.roblox.com/asset?id=55130219"
local TAIL_TEXTURE = "http://www.roblox.com/asset?id=55134078"
local USE_BILLBOARD_GUI = true
local LAST_CLICK_TIME = 0
local CLICK_HELP_TIME_DELTA = .8
local SOURCE_BADGE_TEXTURE = "http://www.roblox.com/asset?id=60730993"
local SINK_BADGE_TEXTURE = "http://www.roblox.com/asset?id=61334830"

local ALL_TEXTURES = { SOURCE_BUTTON_ICON_TEXTURE, SOURCE_BUTTON_ICON_HOVER_TEXTURE,
		SINK_BUTTON_ICON_TEXTURE, SINK_BUTTON_ICON_HOVER_TEXTURE,
		DISCONNECT_ICON_HOVER_TEXTURE, DISCONNECT_SOURCE_ICON_TEXTURE,
		DISCONNECT_SINK_ICON_TEXTURE, TAIL_TEXTURE, WIRE_TEXTURE, SOURCE_BADGE_TEXTURE, SINK_BADGE_TEXTURE}

for idx, asset in ipairs(ALL_TEXTURES) do
	game:GetService("ContentProvider"):Preload(asset)
end

function clearSelection()
	SELECTED_SOURCE = nil
	SELECTED_SINK = nil
	getLocalLasso().From = nil
	getLocalLasso().To = nil
end

function clearScreenMessage()
	if SCREEN_MESSAGE ~= nil then
		SCREEN_MESSAGE:Remove()
		SCREEN_MESSAGE = nil
	end
end

function clearHover()
	if LAST_HOVERED_PART ~= nil then
		local lastHover = LAST_HOVERED_PART
		if not ANNOTATIONS[lastHover] then
			lastHover = findModel(lastHover)
		end

		ANNOTATIONS[lastHover].Transparency = BASE_ANNOTATION_TRANSPARENCY
		if WIRING_PANEL_MAP[lastHover] ~= nil then
			WIRING_PANEL_MAP[lastHover]:Remove()
			WIRING_PANEL_MAP[lastHover] = nil
		end
		setPartWireTransparency(LAST_HOVERED_PART, BASE_WIRE_TRANSPARENCY, BASE_WIRE_RADIUS, "")
	end
end

function getPlayerGui()
	if STATIC_PLAYER_GUI == nil then
		STATIC_PLAYER_GUI = game.Players:GetPlayerFromCharacter(Tool.Parent).PlayerGui
	end
	return STATIC_PLAYER_GUI
end

function findMyBasePlate()
	if isRestricted then
		if STATIC_BASE_PLATE == nil then
			local buildingAreas = game.Workspace.BuildingAreas:GetChildren()
			for i = 1, #buildingAreas do
				if buildingAreas[i]:FindFirstChild("Player") then
					if buildingAreas[i].Player.Value == game.Players.LocalPlayer.Name then
						waitForChild(buildingAreas[i],"PlayerArea")
						STATIC_BASE_PLATE = buildingAreas[i].PlayerArea
					end
				end
			end
		end
		return STATIC_BASE_PLATE
	end

	return nil
end

function getLocalLasso()
	if not game.Players.LocalPlayer.PlayerGui:FindFirstChild("lasso") then
		local lasso = Instance.new("FloorWire")
		lasso.Name = "lasso"
		lasso.Parent = game.Players.LocalPlayer.PlayerGui
		lasso.Color = BrickColor.new("Really black")
	end

	return game.Players.LocalPlayer.PlayerGui.lasso
end

function findModel(part)
	if isRestricted then
		local basePlate = findMyBasePlate()
		while part ~= nil do
			if part.className == "Model" and part.Name ~= basePlate.Name and part.Name ~= "GarbageParts" then
				return part
			elseif part.Name == basePlate.Name or part.Name == "GarbageParts" then
				return nil
			end
			part = part.Parent
		end
	else
		local origPart = part
		while part ~= nil do
			if part.className == "Model" then
				return part
			elseif part.Name == "Workspace" or part.Name == "game" then
				return origPart
			end
			part = part.Parent
		end
	end

	return nil
end

function createVisualAnnotation(part, guiMain)
	local selection = Instance.new("SelectionBox", guiMain)
	selection.Name = "Annotation"
	selection.Color = BrickColor.new("Lime green")
	selection.Transparency = BASE_ANNOTATION_TRANSPARENCY
	selection.Adornee = part
	return selection
end

function isInteractivePart(obj)
	if obj == nil then return false end
	if obj:IsA("Part") then
		for idx, child in ipairs(obj:GetChildren()) do
			if child:IsA("CustomEvent") or child:IsA("CustomEventReceiver") then
				return true
			end
		end
	end
	return false
end

function applyToConnectorsWires(sourceOrSink, fn)
	if sourceOrSink:IsA("CustomEvent") then
		for idx, recv in ipairs(sourceOrSink:GetAttachedReceivers()) do
			fn(WIRE_LASSO_MAP[sourceOrSink][recv])
		end
	else
		local source = sourceOrSink.Source
		if source ~= nil then
			fn(WIRE_LASSO_MAP[source][sourceOrSink])
		end
	end
end

function warnNoWireableParts()
	local topHint = nil
	pcall(function() topHint = getPlayerGui().Gui.Hints.CenterHint end)
	
	if topHint then
		topHint.Add.Label.Value = "No Wiring Parts!  Add Wiring Parts using the Stamper Tool."
		topHint.Add.Width.Value = 580
		topHint.Add.Time.Value = 10
		topHint.Add.Disabled = true  -- flip it off then on, in case it's currently running.
		topHint.Add.Disabled = false
	end
end

function warnNotClickingWireablePart()
	if getPlayerGui():FindFirstChild("CenterHint", true) then
		local topHint = getPlayerGui().Gui.Hints.CenterHint
		topHint.Add.Label.Value = "This part isn't wireable :("
		topHint.Add.Width.Value = 580
		topHint.Add.Time.Value = 2
		topHint.Add.Disabled = true  -- flip it off then on, in case it's currently running.
		topHint.Add.Disabled = false
	end
end

--------------------------------------------------------------------------------
-- Screen messages (when source/sink is selected)

function stylizeScreenMessageLabel(label, text)
	label.Text = text
	label.FontSize = Enum.FontSize.Size24
	label.Font = Enum.Font.ArialBold
	label.BackgroundTransparency = 1
	label.BorderSizePixel = 0
	label.Size = UDim2.new(0, label.TextBounds.x, 0, label.TextBounds.y)
	label.TextColor3 = Color3.new(1, 1, 1)
end

function createSourceIcon(parent, precedingText)
	local sourceIcon = Instance.new("ImageLabel", frame)
	sourceIcon.Archivable = false
	sourceIcon.Image = SOURCE_BUTTON_ICON_TEXTURE
	sourceIcon.Size = UDim2.new(0, 30, 0, 30)
	sourceIcon.BackgroundTransparency = 1
	sourceIcon.BorderSizePixel = 0
	sourceIcon.Position = UDim2.new(0,
			precedingText.Position.X.Offset + precedingText.TextBounds.x + 5,
			0, precedingText.Position.Y.Offset +
				((precedingText.Size.Y.Offset - sourceIcon.Size.Y.Offset) / 2))
	return sourceIcon
end

function createSinkIcon(parent, precedingText)
	local sinkIcon = Instance.new("ImageLabel", frame)
	sinkIcon.Archivable = false
	sinkIcon.Image = SINK_BUTTON_ICON_TEXTURE
	sinkIcon.Size = UDim2.new(0, 30, 0, 30)
	sinkIcon.BackgroundTransparency = 1
	sinkIcon.BorderSizePixel = 0
	sinkIcon.Position = UDim2.new(0,
			precedingText.Position.X.Offset + precedingText.TextBounds.x + 5,
			0, precedingText.Position.Y.Offset +
				((precedingText.Size.Y.Offset - sinkIcon.Size.Y.Offset) / 2))
	return sinkIcon
end

function addToAllXPositions(objs, offset)
	for idx, obj in ipairs(objs) do
		pos = obj.Position
		obj.Position = UDim2.new(0, pos.X.Offset + offset, 0, pos.Y.Offset)
	end
end

function showSourceScreenMessage(source)
	gui = Instance.new("ScreenGui", getPlayerGui())
	gui.Archivable = false
	frame = Instance.new("Frame", gui)
	frame.Archivable = false
	frame.Style = Enum.FrameStyle.RobloxRound

	local line1part1 = Instance.new("TextLabel", frame)
	line1part1.Archivable = false
	stylizeScreenMessageLabel(line1part1, "Choose a")

	sinkIcon = createSinkIcon(frame, line1part1)
	
	line1part2 = Instance.new("TextLabel", frame)
	line1part2.Archivable = false
	stylizeScreenMessageLabel(line1part2, "receiver to trigger when")
	line1part2.Position = UDim2.new(0,
		sinkIcon.Position.X.Offset + sinkIcon.Size.X.Offset + 5, 0, 0)

	line1height = math.max(sinkIcon.Size.Y.Offset, line1part1.Size.Y.Offset)

	line2part1 = Instance.new("TextLabel", frame)
	line2part1.Archivable = false
	stylizeScreenMessageLabel(line2part1, source.Parent.Name)
	line2part1.Position = UDim2.new(0, 0, 0, line1height)
	
	sourceIcon = createSourceIcon(frame, line2part1)

	line2part2 = Instance.new("TextLabel", frame)
	stylizeScreenMessageLabel(line2part2, "signals ")
	line2part2.Position = UDim2.new(0,
		sourceIcon.Position.X.Offset + sourceIcon.Size.X.Offset + 5,
		0, line2part1.Position.Y.Offset)

	line2part3 = Instance.new("TextLabel", frame)
	stylizeScreenMessageLabel(line2part3, source.Name)
	line2part3.TextColor3 = SOURCE_BUTTON_TEXT_COLOR
	line2part3.Position = UDim2.new(0,
		line2part2.Position.X.Offset + line2part2.Size.X.Offset,
		0, line2part1.Position.Y.Offset)

	-- re-center
	line1width = line1part2.Position.X.Offset + line1part2.Size.X.Offset
	line2width = line2part3.Position.X.Offset + line2part3.Size.X.Offset

	if line1width &gt; line2width then
		local halfDelta = (line1width - line2width) / 2
		addToAllXPositions({line2part1, sourceIcon, line2part2, line2part3}, halfDelta)
	else
		local halfDelta = (line2width - line1width) / 2
		addToAllXPositions({line1part1, sinkIcon, line1part2}, halfDelta)
	end

	frame.Size = UDim2.new(0, math.max(line1width, line2width) + 15,
			0, 2 * line1height + 5)
	frame.Position = UDim2.new(.5, -frame.Size.X.Offset/2, 0, 0)

	clearScreenMessage()
	SCREEN_MESSAGE = gui
end

function showSinkScreenMessage(sink)
	gui = Instance.new("ScreenGui", getPlayerGui())
	frame = Instance.new("Frame", gui)
	frame.Style = Enum.FrameStyle.RobloxRound

	local line1part1 = Instance.new("TextLabel", frame)
	stylizeScreenMessageLabel(line1part1, "Choose which")

	local sourceIcon = createSourceIcon(frame, line1part1)
	
	line1part2 = Instance.new("TextLabel", frame)
	stylizeScreenMessageLabel(line1part2, "signal will cause")
	line1part2.Position = UDim2.new(0,
		sourceIcon.Position.X.Offset + sourceIcon.Size.X.Offset + 5, 0, 0)

	local line1height = math.max(sourceIcon.Size.Y.Offset, line1part1.Size.Y.Offset)

	line2part1 = Instance.new("TextLabel", frame)
	stylizeScreenMessageLabel(line2part1, sink.Parent.Name .. " to")
	line2part1.Position = UDim2.new(0, 0, 0, line1height)
	
	local sinkIcon = createSinkIcon(frame, line2part1)

	line2part2 = Instance.new("TextLabel", frame)
	stylizeScreenMessageLabel(line2part2, sink.Name)
	line2part2.TextColor3 = SINK_BUTTON_TEXT_COLOR
	line2part2.Position = UDim2.new(0,
		sinkIcon.Position.X.Offset + sinkIcon.Size.X.Offset,
		0, line2part1.Position.Y.Offset)

	-- re-center
	line1width = line1part2.Position.X.Offset + line1part2.Size.X.Offset
	line2width = line2part2.Position.X.Offset + line2part2.Size.X.Offset

	if line1width &gt; line2width then
		local halfDelta = (line1width - line2width) / 2
		addToAllXPositions({line2part1, sinkIcon, line2part2}, halfDelta)
	else
		local halfDelta = (line2width - line1width) / 2
		addToAllXPositions({line1part1, sourceIcon, line1part2}, halfDelta)
	end

	frame.Size = UDim2.new(0, math.max(line1width, line2width) + 15,
			0, 2 * line1height + 5)
	frame.Position = UDim2.new(.5, -frame.Size.X.Offset/2, 0, 0)

	clearScreenMessage()
	SCREEN_MESSAGE = gui
end

--------------------------------------------------------------------------------
-- Hover

function setPartWireTransparency(part, transparency, wireRadius, texture)
	for idx, child in ipairs(part:GetChildren()) do
		if child:IsA("CustomEvent") then
			for idx2, recv in ipairs(child:GetAttachedReceivers()) do
				addWireUiIfNotAlreadyThere(child, recv)
				WIRE_LASSO_MAP[child][recv].Transparency = transparency
				WIRE_LASSO_MAP[child][recv].WireRadius = wireRadius
				WIRE_LASSO_MAP[child][recv].Texture = texture
				WIRE_LASSO_MAP[child][recv].Color = BrickColor.new("Really black")
			end
		elseif child:IsA("CustomEventReceiver") then
			local source = child.Source
			if source ~= nil then
				addWireUiIfNotAlreadyThere(source, child)
				WIRE_LASSO_MAP[source][child].Transparency = transparency
				WIRE_LASSO_MAP[source][child].WireRadius = wireRadius
				WIRE_LASSO_MAP[source][child].Texture = texture
				WIRE_LASSO_MAP[source][child].Color = BrickColor.new("Really black")
			end
		end
	end
end

function canHighlight(part,model)
	if (KNOWN_SOURCE_PARTS[part] and SELECTED_SOURCE == nil) or (KNOWN_SINK_PARTS[part] and SELECTED_SINK == nil) then
		return true, part
	elseif (KNOWN_SOURCE_PARTS[model] and SELECTED_SOURCE == nil) or (KNOWN_SINK_PARTS[model] and SELECTED_SINK == nil) then
		return true, model
	end

	return false, nil
end

function hoverListener(mouse)
	if mouse.Target == nil then return end

	local part = mouse.Target
	local model = findModel(part)
	if LAST_HOVERED_PART ~= part and findModel(LAST_HOVERED_PART) ~= model then
		clearHover()
		local highlight, instance = canHighlight(part,model)
		if highlight then
			LAST_HOVERED_PART = part
			ANNOTATIONS[model].Transparency = 0
			buildScreenPanel(model, mouse.X, mouse.Y)
			setPartWireTransparency(part, 0, ENHANCED_WIRE_RADIUS, "")
		else
			LAST_HOVERED_PART = nil
		end

		-- Point the temporary wire to the LAST_HOVERED_PART if not nil,
		-- otherwise point it at the character
		local otherEndOfWire = game.Players.LocalPlayer.Character.Humanoid.Torso
		if LAST_HOVERED_PART ~= nil then
			otherEndOfWire = LAST_HOVERED_PART
		end
		if SELECTED_SOURCE ~= nil then
			getLocalLasso().To = otherEndOfWire
		end
		if SELECTED_SINK ~= nil then
			getLocalLasso().From = otherEndOfWire
		end
	end
end

--------------------------------------------------------------------------------
-- Connect / Disconnect dialog

function addWireUiIfNotAlreadyThere(source, sink)
	if WIRE_LASSO_MAP[source] == nil then
		WIRE_LASSO_MAP[source] = {}
	end
	if WIRE_LASSO_MAP[source][sink] ~= nil then
		return
	end

	pairLasso = Instance.new("FloorWire", getPlayerGui())
	pairLasso.From = source.Parent
	pairLasso.To = sink.Parent
	pairLasso.Transparency = BASE_WIRE_TRANSPARENCY
	pairLasso.Texture = ""
	pairLasso.Name = WIRE_LASSO
	pairLasso.Color = BrickColor.new("Really black")
	WIRE_LASSO_MAP[source][sink] = pairLasso
end

function connectHelper(source, sink)
	-- clear wires coming to sink
	local old_source = sink.Source
	if old_source ~= nil then
		wire = WIRE_LASSO_MAP[old_source][sink]
		if wire ~= nil then
			wire:Remove()
			WIRE_LASSO_MAP[old_source][sink] = nil
		end
		sink.Source = nil
	end

	sink.Source = source
	addWireUiIfNotAlreadyThere(source, sink)
end

function makeSourceConnectCallback(source)
	return function()
		clearHover()
		if SELECTED_SINK ~= nil then
			connectHelper(source, SELECTED_SINK)
			clearSelection()
			clearScreenMessage()
			for part, val in pairs(KNOWN_SINK_PARTS) do
				local model = findModel(part)
				ANNOTATIONS[model].Transparency = BASE_ANNOTATION_TRANSPARENCY
			end
		else
			SELECTED_SOURCE = source
			getLocalLasso().From = source.Parent
			getLocalLasso().To = game.Players.LocalPlayer.Character.Humanoid.Torso
			showSourceScreenMessage(SELECTED_SOURCE)
			for part, val in pairs(KNOWN_SOURCE_PARTS) do
				if not KNOWN_SINK_PARTS[part] then
					local model = findModel(part)
					ANNOTATIONS[model].Transparency = 1
				end
			end
		end
	end
end

function makeSinkConnectCallback(sink)
	return function()
		clearHover()
		if SELECTED_SOURCE ~= nil then
			connectHelper(SELECTED_SOURCE, sink)
			clearSelection()
			clearScreenMessage()
			for part, val in pairs(KNOWN_SOURCE_PARTS) do
				local model = findModel(part)
				ANNOTATIONS[model].Transparency = BASE_ANNOTATION_TRANSPARENCY
			end
		else
			SELECTED_SINK = sink
			getLocalLasso().From = game.Players.LocalPlayer.Character.Humanoid.Torso
			getLocalLasso().To = sink.Parent
			showSinkScreenMessage(SELECTED_SINK)
			for part, val in pairs(KNOWN_SINK_PARTS) do
				if not KNOWN_SOURCE_PARTS[part] then
					local model = findModel(part)
					ANNOTATIONS[model].Transparency = 1
				end
			end
		end
	end
end

function makeControlButton(y_position, frame, sourceOrSink, textColor, iconImage, iconHoverImage, callbackBuilder)
	local button = Instance.new("TextButton", frame)
	button.Position = UDim2.new(.025, 0, 0, y_position)
	button.Text = sourceOrSink.Name
	button.TextXAlignment = Enum.TextXAlignment.Left
	button.Style = Enum.ButtonStyle.Custom
	button.BorderSizePixel = 0
	button.BackgroundTransparency = 1
	button.BackgroundColor3 = Color3.new(0, 0 ,0)
	button.TextColor3 = textColor
	button.Font = Enum.Font.ArialBold
	button.FontSize = Enum.FontSize.Size18
	button.ZIndex = 2
	button.Size = UDim2.new(.95, 0, 0, button.TextBounds.y)
	
	local icon = Instance.new("ImageLabel", button)
	icon.Image = iconImage
	icon.ZIndex = 2
	icon.Position = UDim2.new(0, button.TextBounds.x + 10, 0, -8)
	icon.Size = UDim2.new(0, 30, 0 , 30)
	icon.BackgroundTransparency = 1

	button.MouseEnter:connect(function()
		applyToConnectorsWires(sourceOrSink, function(wire)
			wire.Texture = WIRE_TEXTURE
			wire.Velocity = 2
		end)
		button.BackgroundTransparency = 0
		button.TextColor3 = BUTTON_HOVER_TEXT_COLOR
		icon.Image = iconHoverImage
	end)
	local leaveCallback = function()
		applyToConnectorsWires(sourceOrSink, function(wire)
			wire.Texture = ""
		end)
		button.BackgroundTransparency = 1
		button.TextColor3 = textColor
		icon.Image = iconImage
	end
	button.MouseLeave:connect(leaveCallback)
	button.MouseButton1Click:connect(function()
		callbackBuilder(sourceOrSink)()
		leaveCallback()
	end)
	return button
end

function makeDisconnectCallback(source, sink)
	clearHover()
	sink.Source = nil
	if WIRE_LASSO_MAP[source] ~= nil then
		lassoUi = WIRE_LASSO_MAP[source][sink]
		if lassoUi ~= nil then
			lassoUi:Remove()
			WIRE_LASSO_MAP[source][sink] = nil
		end
	end
end

function makeDisconnectButton(y_position, frame, localConnector, foreignConnector, textColor, iconImage)
	local source = nil
	local sink = nil
	if localConnector:IsA("CustomEvent") then
		source = localConnector
		sink = foreignConnector
	else
		source = foreignConnector
		sink = localConnector
	end

	local button = Instance.new("TextButton", frame)
	button.Position = UDim2.new(0, 17, 0, y_position)
	button.Text = foreignConnector.Name .. " (" .. foreignConnector.Parent.Name .. ")" 
	button.TextXAlignment = Enum.TextXAlignment.Left
	button.Style = Enum.ButtonStyle.Custom
	button.BackgroundTransparency = 1
	button.BackgroundColor3 = Color3.new(0, 0 ,0)
	button.TextColor3 = textColor
	button.BorderSizePixel = 0
	button.Font = Enum.Font.Arial
	button.FontSize = Enum.FontSize.Size18
	button.ZIndex = 3
	button.Size = UDim2.new(.95, -10, 0, button.TextBounds.y + 2)
	
	local icon = Instance.new("ImageLabel", button)
	icon.Image = iconImage
	icon.Parent = button
	icon.Position = UDim2.new(0, button.TextBounds.x + 10, 0, 2)
	icon.Size = UDim2.new(0, 15, 0 , 15)
	icon.BackgroundTransparency = 1

	local buttonCons = {}

	table.insert(buttonCons,
		button.MouseButton1Click:connect(function() 
			makeDisconnectCallback(source, sink)
		end)
	)
	table.insert(buttonCons,
		button.MouseEnter:connect(function()
			button.BackgroundTransparency = 0
			button.TextColor3 = BUTTON_HOVER_TEXT_COLOR
			icon.Image = DISCONNECT_ICON_HOVER_TEXTURE
			WIRE_LASSO_MAP[source][sink].Color = BrickColor.new("Really red")
		end)
	)
	table.insert(buttonCons,
		button.MouseLeave:connect(function()
		button.BackgroundTransparency = 1
		button.TextColor3 = textColor
		icon.Image = iconImage
		WIRE_LASSO_MAP[source][sink].Color = BrickColor.new("Really black")
	end)
	)

	table.insert(buttonCons,
		button.AncestryChanged:connect(function(child,parent)
			if parent == nil then
				for i = 1, #buttonCons do
					buttonCons[i]:disconnect()
				end
			end
		end)
	)

	return button
end

function getPartSourcesAndSinks(part, sources,sinks)
	for idx, child in ipairs(part:GetChildren()) do
		if child:IsA("CustomEvent") then
			table.insert(sources, child)
		elseif child:IsA("CustomEventReceiver") then
			table.insert(sinks, child)
		end
	end
end

function getSourcesAndSinks(instance,sources,sinks)
	if instance:IsA("BasePart") then
		getPartSourcesAndSinks(instance, sources,sinks)
	elseif instance:IsA("Model") then
		local modelChildren = instance:GetChildren()
		for i = 1, #modelChildren do
			if modelChildren[i]:IsA("BasePart") then
				getPartSourcesAndSinks(modelChildren[i],sources,sinks)
			elseif modelChildren[i]:IsA("Model") then
				getSourcesAndSinks(modelChildren[i],sources,sinks)
			end
		end
	end
end

local function findFirstConnector(node)
	if node:IsA("BasePart") then
		for idx, child in ipairs(node:GetChildren()) do
			if connector == nil and (child:IsA("CustomEvent") or child:IsA("CustomEventReceiver")) then
				return child
			end
		end
	else
		local children = node:GetChildren()
		if #children == 0 then
			return nil
		end
		for i = 1, #children do
			local subConnector = findFirstConnector(children[i])
			if subConnector then return subConnector end
		end
	end
end

function buildScreenPanel(part, x, y)
	sources = {}
	sinks = {}
	getSourcesAndSinks(part,sources,sinks)

	local gui = nil
	local mouseFrame = nil
	if USE_BILLBOARD_GUI then
		gui = Instance.new("BillboardGui", getPlayerGui())
		gui.Name = "WiringGui"
		gui.StudsOffset = Vector3.new(0, 1.5, 0)
		gui.ExtentsOffset = Vector3.new(0,0, 0)
		gui.Adornee = part
		gui.Active = true
		gui.AlwaysOnTop = true
	else 
		gui = Instance.new("ScreenGui", getPlayerGui())
	end

	frame = Instance.new("Frame", gui)
	frame.Style = Enum.FrameStyle.RobloxRound
	frame.ZIndex = 1
	frame.Active = true

	local maxWidth = 0
	local y_position = 5

	if SELECTED_SOURCE == nil then
		for idx, source in ipairs(sources) do
			local button = makeControlButton(y_position, frame, source, SOURCE_BUTTON_TEXT_COLOR,
					SOURCE_BUTTON_ICON_TEXTURE, SOURCE_BUTTON_ICON_HOVER_TEXTURE,
					makeSourceConnectCallback)
			maxWidth = math.max(1.25 * (button.TextBounds.x + BUTTON_ICON_WIDTH), maxWidth)
			y_position = y_position + button.TextBounds.y

			receivers = source:GetAttachedReceivers()
			for sub_idx, receiver in ipairs(receivers) do
				y_position = y_position + 2
				addWireUiIfNotAlreadyThere(source, receiver)
				local button = makeDisconnectButton(y_position, frame, source, receiver,
					SINK_BUTTON_TEXT_COLOR, DISCONNECT_SINK_ICON_TEXTURE)
				y_position = y_position + button.TextBounds.y
				maxWidth = math.max(1.15 * (button.TextBounds.x + 17 + 25), maxWidth)
			end
			y_position = y_position + 5
		end
	end

	if SELECTED_SINK == nil then
		for idx, sink in ipairs(sinks) do
			local button = makeControlButton(y_position, frame, sink, SINK_BUTTON_TEXT_COLOR,
					SINK_BUTTON_ICON_TEXTURE, SINK_BUTTON_ICON_HOVER_TEXTURE,
					makeSinkConnectCallback)
			maxWidth = math.max(1.25 * (button.TextBounds.x + BUTTON_ICON_WIDTH), maxWidth)
			y_position = y_position + button.TextBounds.y

			local sender = sink.Source
			if sender ~= nil then
				y_position = y_position + 2
				-- addWire takes source first
				addWireUiIfNotAlreadyThere(sender, sink)
				local button = makeDisconnectButton(y_position, frame, sink, sender,
					SOURCE_BUTTON_TEXT_COLOR, DISCONNECT_SOURCE_ICON_TEXTURE)
				y_position = y_position + button.TextBounds.y
				maxWidth = math.max(1.15 * (button.TextBounds.x + 17 + 25), maxWidth)
			end
			y_position = y_position + 5
		end
	end

	-- set size and position
	if not getPlayerGui():FindFirstChild("ScreenGui") then
		local screenGui = Instance.new("ScreenGui")
		screenGui.Parent = getPlayerGui()
	end

	local screenSize = getPlayerGui().ScreenGui.AbsoluteSize
	local menuWidth = maxWidth
	local menuHeight = y_position + 17.5
	if USE_BILLBOARD_GUI then

		
		local size = Vector3.new(0,0,0)
		if gui.Adornee:IsA("BasePart") then
			size = gui.Adornee.Size
		elseif gui.Adornee:IsA("Model") then
			size = gui.Adornee:GetModelSize()
		end

		local xSize= size.X
		if size.Y &gt; xSize then
			xSize = size.Y
		end

		gui.Size = UDim2.new(0, menuWidth,0,menuHeight + 150)
		gui.SizeOffset = Vector2.new(0, -50.0 / (menuHeight + 150));
		
		local tail = Instance.new("ImageLabel", frame)
		tail.Size = UDim2.new(0, 32, 0, 32)
		tail.Position = UDim2.new(.5, -16, 1, 8)
		tail.Image = TAIL_TEXTURE
		tail.BackgroundTransparency = 1
		tail.Visible = true

		f = Instance.new("Frame", gui)
		f.Size = UDim2.new(1, 0, 1, 0)
		f.BackgroundTransparency = 1
		f.ZIndex = 1
		f.Active = true
		b = Instance.new("TextButton", f)
		b.ZIndex = 1
		b.BackgroundTransparency = 1
		b.Text = ""
		b.BorderSizePixel = 0
		b.Size = UDim2.new(1, 0, 1, 0)
		b.MouseButton1Click:connect(function()
			local foundConnector = findFirstConnector(findModel(LAST_HOVERED_PART))
			if foundConnector ~= nil and foundConnector:IsA("CustomEvent") then
				makeSourceConnectCallback(foundConnector)()
			elseif foundConnector ~= nil and foundConnector:IsA("CustomEventReceiver") then
				makeSinkConnectCallback(foundConnector)()
			end
		end)
	else
		x = math.min(x - 9, screenSize.x - menuWidth) 
		y = math.min(y - 9, screenSize.y - menuHeight)
		frame.Position = UDim2.new(0, x, 0, y)
	end

	frame.Size = UDim2.new(0, menuWidth, 0, menuHeight)
	frame.Position = UDim2.new(0.5,-menuWidth/2,0.05,0)
	WIRING_PANEL_MAP[part] = gui
end

function inBaseplate(instance)
	if instance == STATIC_BASE_PLATE then return true end

	local instanceCopy = instance

	while instanceCopy and (instanceCopy.Parent ~= nil or instanceCopy.Parent ~= game.Workspace) do
		if instanceCopy.Parent == STATIC_BASE_PLATE then
			return true
		end
		instanceCopy = instanceCopy.Parent
	end

	return false
end

--------------------------------------------------------------------------------
-- Tool.Equipped/Unequipped

Tool.Equipped:connect(function(mouse)
	local player = game.Players:getPlayerFromCharacter(Tool.Parent)
	if not player then return end

	if playerOwner.Value and playerOwner.Value ~= player then return end
	playerOwner.Value = player

	playerGui = getPlayerGui()
	LAST_HOVERED_PART = nil

	if isRestricted then
		root = findMyBasePlate()
	else
		root = game.Workspace
	end

	local interactiveCount = setUpConfigurationService()

	if not interactiveCount or interactiveCount == 0 then
		warnNoWireableParts()
	end

	getLocalLasso().Texture = WIRE_TEXTURE
	getLocalLasso().WireRadius = ENHANCED_WIRE_RADIUS
	clearSelection()

	mouse.Icon = "http://www.roblox.com/asset?id=66887773"
	mouseMoveCon = mouse.Move:connect(function() hoverListener(mouse) end)
	mouseButtonDownCon = mouse.Button1Down:connect(function()
		if LAST_HOVERED_PART ~= nil then return end

		clearSelection()
		clearScreenMessage()
		clearHover()
		local annotationCount = 0
		for part, annotation in pairs(ANNOTATIONS) do
			annotation.Transparency = BASE_ANNOTATION_TRANSPARENCY
			annotationCount = annotationCount + 1
		end
		if annotationCount == 0 then
			warnNoWireableParts()
		elseif time() - LAST_CLICK_TIME &lt; CLICK_HELP_TIME_DELTA then
			warnNotClickingWireablePart()
		end
		LAST_CLICK_TIME = time()
	end)
	-- TODO: onkeydown/onmouse2down, prevent hover from triggering
	-- until the up event comes
end)

Tool.Unequipped:connect(function()
	playerGui = getPlayerGui()

	destroyConfigurationService()

	if mouseMoveCon then mouseMoveCon:disconnect() end
	if mouseButtonDownCon then mouseButtonDownCon:disconnect() end

	if playerGui:FindFirstChild("CenterHint", true) then
		local centerHint = getPlayerGui().Gui.Hints.CenterHint
		centerHint.Delete.Disabled = false
	end

	-- TODO: simplify these side effects
	-- call clearHover before removing annotations, because
	-- clear hover resets annotation boxes. Also before clearing
	-- lassos because this may create lassos
	clearHover()

	for part, gui in pairs(WIRING_PANEL_MAP) do
		if gui then gui:Remove() end
	end
	WIRING_PANEL_MAP = {}

	for source, submap in pairs(WIRE_LASSO_MAP) do
		for sink, wire in pairs(submap) do
			wire:Remove()
		end
	end
	WIRE_LASSO_MAP = {}

	for k,box in pairs(ANNOTATIONS) do
		box:Remove()
	end
	ANNOTATIONS = {}

	KNOWN_SOURCE_PARTS = {}
	KNOWN_SINK_PARTS = {}

	clearSelection()
	clearScreenMessage()
	LAST_HOVERED_PART = nil
end)

function findBillboard(guiTable)
	if not guiTable then return end

	for i = 1, #guiTable do
		if guiTable[i] and guiTable[i]:IsA("BillboardGui") then
			return guiTable[i]
		end
	end
end

function getBillboard(adornee)
	local guiKey = adornee

	
	local billboard = findBillboard(adornmentTable[guiKey])
	if not billboard then
		local screen = Instance.new("BillboardGui")
		screen.Name = adornee.Name .. "BadgeGUI"
		screen.Size = UDim2.new(1.5,0,1.5,0)
		screen.Enabled = true
		screen.Active = true
		screen.AlwaysOnTop = true
		screen.ExtentsOffset = Vector3.new(0,0,0)
		screen.Adornee = adornee
		screen.Parent = game.Players.LocalPlayer.PlayerGui

		if not adornmentTable[guiKey] then return end
		table.insert(adornmentTable[guiKey],screen)

		local badgeFrame = Instance.new("Frame")
		badgeFrame.Name = "BadgeFrame"
		badgeFrame.Size = UDim2.new(2,0,1,0)
		badgeFrame.Position = UDim2.new(-0.5,0,0,0)
		badgeFrame.BackgroundTransparency = 1
		badgeFrame.Parent = screen

		return screen
	end

	return billboard
end

function repositionBadges(badgeFrame)
	local badges = badgeFrame:GetChildren()
	if #badges == 1 then
		badges[1].Position = UDim2.new(0.25,0,0,0)
	elseif #badges == 2 then
		badges[1].Position = UDim2.new(0,0,0,0)
		badges[2].Position = UDim2.new(0.5,0,0)
	end
end

function hasBadge(adornee, type)
	local screen = getBillboard(adornee)
	return screen:FindFirstChild(type .. "Badge",true)
end

function removeBadge(adornee, type)
	local screen = getBillboard(adornee)
	local badge = screen:FindFirstChild(type .. "Badge",true)
	if badge then badge:remove() end
end

function createBadge(adornee,type)
	local screen = getBillboard(adornee)

	local wiringBadge = Instance.new("ImageLabel")
	wiringBadge.Name = type .. "Badge"
	wiringBadge.BackgroundTransparency = 1
	if type == "Receiver" then
		wiringBadge.Image = SOURCE_BADGE_TEXTURE
	else
		wiringBadge.Image = SINK_BADGE_TEXTURE
	end

	wiringBadge.Position = UDim2.new(0.25,0,0,0)
	wiringBadge.Size = UDim2.new(0.5,0,1,0)
	wiringBadge.Parent = screen.BadgeFrame
	wiringBadge.Changed:connect(function(prop)
		if prop == "AbsoluteSize" then
			if wiringBadge.AbsoluteSize.X &lt; 10 then
				wiringBadge.Visible = false
			else
				wiringBadge.Visible = true
			end
		end
	end)

	repositionBadges(screen.BadgeFrame)
end

function upAdorneeCount(adornee,type)
	local typeLower = string.lower(type)
	if typeLower == "receiver" then
		if not receiverBadgeCount[adornee] then
			receiverBadgeCount[adornee] = 1
		else
			receiverBadgeCount[adornee] = receiverBadgeCount[adornee] + 1
		end
	elseif typeLower == "event" then
		if not eventBadgeCount[adornee] then
			eventBadgeCount[adornee] = 1
		else
			eventBadgeCount[adornee] = eventBadgeCount[adornee] + 1
		end
	end
end

function downAdorneeCount(adornee,type)
	local typeLower = string.lower(type)
	if typeLower == "receiver" then
		if receiverBadgeCount[adornee] then
			receiverBadgeCount[adornee] = receiverBadgeCount[adornee] - 1
			if receiverBadgeCount[adornee] &lt; 1 then
				receiverBadgeCount[adornee] = nil
			end
		end
	elseif typeLower == "event" then
		if eventBadgeCount[adornee] then
			eventBadgeCount[adornee] = eventBadgeCount[adornee] - 1
			if eventBadgeCount[adornee] &lt; 1 then
				eventBadgeCount[adornee] = nil
			end
		end
	end
end

function createAdornment(adornee,adornColor,type)
	upAdorneeCount(adornee,type)

	if receiverBadgeCount[adornee] == 1 or eventBadgeCount[adornee] == 1 then
		local box = Instance.new("SelectionBox")
		box.Color = adornColor
		box.Name = adornee.Name .. "Selection" .. tostring(type)
		box.Adornee = adornee
		box.Transparency = 0.5
		box.Parent = game.Players.LocalPlayer.PlayerGui
		if not adornmentTable[adornee] then
			adornmentTable[adornee] = {}
		end

		ANNOTATIONS[adornee] = box
		table.insert(adornmentTable[adornee],box)

		if not hasBadge(adornee,type) then
			createBadge(adornee,type)
		end
	end
end

function doRemoveAdornment(adornee, type)
	local key = adornee
	if not adornmentTable[key] then return end
	for i = 1, #adornmentTable[key] do
		if adornmentTable[key] and adornmentTable[key][i] then
			if string.find(adornmentTable[key][i].Name,type) then
				adornmentTable[key][i]:remove()
				adornmentTable[key][i] = nil
			end
		end
	end
end

function removeAdornment(adornee, type)
	downAdorneeCount(adornee,type)

	if type == "Receiver" then
		if not receiverBadgeCount[adornee]then
			removeBadge(adornee, type)
			doRemoveAdornment(adornee, type)
		end
	elseif type == "Event" then
		if not eventBadgeCount[adornee] then
			removeBadge(adornee, type)
			doRemoveAdornment(adornee, type)
		end
	end
end

function eventReceiverAdded(receiver,wirePartCount)
	if isRestricted then
		if not inBaseplate(receiver) then return wirePartCount end
	end
	receiverTable[receiver] = findModel(receiver.Parent)
	createAdornment(receiverTable[receiver], BrickColor.new("Lime green"), "Receiver")
	setPartWireTransparency(receiver.Parent, BASE_WIRE_TRANSPARENCY, BASE_WIRE_RADIUS, "")

	KNOWN_SINK_PARTS[receiver.Parent] = true
	KNOWN_SINK_PARTS[receiverTable[receiver]]= true

	if wirePartCount then
		return wirePartCount + 1
	else
		return 0
	end

end

function eventAdded(event,wirePartCount)
	if isRestricted then
		if not inBaseplate(event) then return wirePartCount end
	end
	eventTable[event] = findModel(event.Parent)
	createAdornment(eventTable[event], BrickColor.new("Bright orange"), "Event")
	setPartWireTransparency(event.Parent, BASE_WIRE_TRANSPARENCY, BASE_WIRE_RADIUS, "")

	KNOWN_SOURCE_PARTS[event.Parent] = true
	KNOWN_SOURCE_PARTS[eventTable[event]]= true

	if wirePartCount then
		return wirePartCount + 1
	else
		return 0
	end
end

function eventReceiverRemoved(receiver)
	if not receiverTable[receiver] then return end

	KNOWN_SINK_PARTS[receiver.Parent] = false
	KNOWN_SINK_PARTS[receiverTable[receiver]]= false

	removeAdornment(receiverTable[receiver],"Receiver")
	receiverTable[receiver] = nil
end

function eventRemoved(event)
	if not eventTable[event] then return end

	KNOWN_SOURCE_PARTS[event.Parent] = false
	KNOWN_SOURCE_PARTS[eventTable[event]]= false

	removeAdornment(eventTable[event], "Event")
	eventTable[event] = nil
end

function setUpConfigurationService()
	local wirePartCount = 0
	ServiceConnections = {}
	local collectionService = game:GetService("CollectionService")

	-- first lets check if anything already exists
	local receivers = collectionService:GetCollection("CustomEventReceiver")
	if receivers then
		for pos, receiver in pairs(receivers) do
			wirePartCount = eventReceiverAdded(receiver, wirePartCount)
		end
	end

	local events = collectionService:GetCollection("CustomEvent")
	if events then
		for pos, event in pairs(events) do
			wirePartCount = eventAdded(event, wirePartCount)
		end
	end

	-- Now lets listen for any future additions/removals
	ServiceConnections[#ServiceConnections+1] = collectionService.ItemAdded:connect(function(instance)
		if instance:IsA("CustomEventReceiver") then
			eventReceiverAdded(instance)
		elseif instance:IsA("CustomEvent") then
			eventAdded(instance)
		end 
	end)
	ServiceConnections[#ServiceConnections+1] = collectionService.ItemRemoved:connect(function(instance)
		if instance:IsA("CustomEventReceiver") then
			eventReceiverRemoved(instance)
		elseif instance:IsA("CustomEvent") then
			eventRemoved(instance)
		end
	end)

	return wirePartCount
end

function destroyConfigurationService()
	-- first lets destroy the collection service
	for index, connection in pairs(ServiceConnections) do
		connection:disconnect()
	end
	ServiceConnections = {}

	-- now lets remove all of our collection service objects that were generated
	for event, object in pairs(eventTable) do
		eventRemoved(event)
	end
	for eventReceiver, object in pairs(receiverTable) do
		eventReceiverRemoved(eventReceiver)
	end
end

</ProtectedString>
			</Properties>
		</Item>
		<Item class="ObjectValue" referent="RBX171">
			<Properties>
				<string name="Name">PlayerOwner</string>
				<Ref name="Value">null</Ref>
			</Properties>
		</Item>
	</Item>
</roblox>